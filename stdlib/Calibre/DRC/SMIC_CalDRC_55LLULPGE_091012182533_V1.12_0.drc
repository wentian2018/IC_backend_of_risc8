#! tvf
namespace import tvf::*


#//##############################
#//#  <Choice 1>   IO Voltage   #
#//##############################

#//There are 2 kinds of voltage combinations, Please select one according to your own design.
#//For 55nm Logic LL 1.0/1.2/1.8/2.5V process or 2.5v overdrive to 3.3v, set this option to 1825;
#//For 55nm Logic LL 1.0/1.2/1.8/3.3V process, set this option to 1833;
#//Default value is 1825

set IO 1825


#//#########################################################
#//#  <Choice 2>   Total metal and Top metal choice        #
#//#########################################################

# Notice that below metal and via only means M1~M8,TM1,TV1,TM2,TV2,STM1,STV1,STM2,STV2
# Notice that below choice "set MTT2_UTV2 1" is for ultra Thick top metal and its via, they also use the same layer "TM2" and "TV2" with Second 4X Top Metal and Second 4X Top Via.

set total_metal 7          ; # Please set the total metal counts based on your design
                            ; # Valid value for this switch "total_metal" is 4,5,6,7,8,9,10

set top_metal 1             ; # Please set the top metal counts based on your design
                            ; # Valid value for this switch "top_metal" is 1,2
                            ; # Please change the default value "2" into "1" if there is only one top metal in your design

set MTT2_UTV2 1             ; # Please set the Ultra Thick top metal count based on your design
                            ; # Valid value for this switch "MTT2_UTV2" is 0,1
                            ; # The value "0" means that there is no this kind of top metal and top via in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal and top via exists in your design
 
set STM1_STV1 0             ; # Please set the top metal "STM1" and top via "STV1" count based on your design
                            ; # Valid value for this switch "STM1_STV1" is 0,1
                            ; # The value "0" means that there is no this kind of top metal and top via in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal and top via exists in your design

set STM2_STV2 0             ; # Please set the top metal "STM2" and top via "STV2" count based on your design
                            ; # Valid value for this switch "STM2_STV2" is 0,1
                            ; # The value "0" means that there is no this kind of top metal and top via in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal and top via exists in your design


#//##########################################
#//#  <Choice 3>   Recommended rules Choice #
#//##########################################

#The rules with the superscript of [R] in DR are recommended rules which require performing DRC runset,
#but DRC checking is not gated for recommended rules. Pls consult with process integration engineer if customers have the doubt.

set Recommended_rules_CHECK YES         ; # Please set the value for the switch to "YES" OR "NO" only based on the descriptions above.
                                        ; # Default value is "YES" to check recommended rules including TV1.2b[R], TV2.2b [R], UTV2.2b [R], 
                                        ; # DNW.5a[R], DNW.6[R], DNW.7[R], PA.1[R], PA.2[R], PA.3[R], RDLPA.1[R], RDLPA.2[R],  
                                        ; # AA.13[R], AA.14[R], PSUB.15[R], PSUB.16[R],   
                                        ; # TV2.10[R], RDL.5[R]
                                        ; # Please change the value "YES" into "NO" if recommended rules shouldn't be checked. 

set Recommended_rules_OTHER NO          ; # Please set the value for the switch to "YES" OR "NO" only based on the descriptions above.
                                        ; # Default value is "NO" not to check other recommended rules
                                        ; # Please change the value "NO" into "YES" if recommended rules need to be checked.
 
#//#########################################
#//#  <Choice 4>   Guidelines rules choice #  
#//#########################################
VERBATIM {
/*It's stongly recommended to follow layout guidelines for design. And the guidelines require performing DRC runset,
 but DRC checking is not gated for them.Pls consult with integration engineers if customer has the problem. 
 SMIC spice model and PDK is based on SMIC design rule guidelines.The Guidelines rules are listed as below:
      AA, NW and poly Resistor guidelines 
      Poly E-Fuse guidelines
      HRP guidelines
      Latch-up guidelines
      DUP guidelines
      LDMOS layout guidelines
      LOGO guidelines
      Metal slot guidelines
      Guide ring layout guidelines
      MOM guidelines
      Al fuse guidelines
      Fuse repairing alignment mark guidelines
      ESD guideline
      CT_14_G */}

#set Guidelines_rules_CHECK YES          ; # Please set the value for the switch to "YES" OR "NO" only based on the descriptions above.
#                                        ; # Default value is "YES" to check Guidelines rules.
#                                        ; # Please change the value "YES" into "NO" if Guidelines rules shouldn't be checked.

set Latch_Up_CHECK      YES  ; # Default value is "YES" to check Latch-Up rules.
                             ; # Please change the value "YES" into "NO" if not to check Latch-Up rules.     
set DUP_CHECK           YES  ; # Default value is "YES" to check DUP rules.
                             ; # Please change the value "YES" into "NO" if not to check DUP rules.
set LDMOS_CHECK         YES  ; # Default value is "YES" to check LDMOS rules.
                             ; # Please change the value "YES" into "NO" if not to check LDMOS rules.
set LOGO_CHECK          YES  ; # Default value is "YES" to check LOGO rules.
                             ; # Please change the value "YES" into "NO" if not to check LOGO rules.
set Metal_Slot_CHECK    YES  ; # Default value is "YES" to check Metal Slot rules.
                             ; # Please change the value "YES" into "NO" if not to check Metal Slot rules.
set Guard_ring_CHECK    YES  ; # Default value is "YES" to check Guard Ring rules.
                             ; # Please change the value "YES" into "NO" if not to check Guard Ring rules.
set MOM_CHECK           YES  ; # Default value is "YES" to check MOM rules.
                             ; # Please change the value "YES" into "NO" if not to check MOM rules.
set ESD_CHECK           NO   ; # Default value is "NO" not to check ESD rules.
                             ; # Please change the value "NO" into "YES" if want to check ESD rules.
set Al_Fuse_CHECK       NO   ; # Default value is "NO" not to check Al Fuse rules.
                             ; # Please change the value "NO" into "YES" if want to check Al Fuse rules.
set Poly_EFuse_CHECK    NO   ; # Default value is "NO" not to check Poly EFuse rules.
                             ; # Please change the value "NO" into "YES" if want to check Poly EFuse rules.
set LMARK_CHECK         NO   ; # Default value is "NO" not to check LMARK rules.
                             ; # Please change the value "NO" into "YES" if want to check LMARK rules.
set CT_GT_G_CHECK       NO   ; # Default value is "NO" to check CT_14_G, GT_19_G,MOM_4_G
                             ; # Please change the value "NO" into "YES" if not to check CT_14_G.


#//###################################
#//#  <Choice 5>   ALLOW_V01         #
#//###################################

# If DRC needs to allow via size 0.1*0.1, then "set ALLOW_V01 YES"
# If DRC needs to highlight via size 0.1*0.1, then "set ALLOW_V01 NO"
# Default is "set ALLOW_V01 YES"

set ALLOW_V01 YES



#//##################################
#//#  <Choice 6>   BORDER Rules     #
#//##################################
VERBATIM {
/*Chip edge BORDER layer and layout pattern rules are defined to avoid any layout pattern extending out to the scribe lane regions.
Border rule is only applied for chip level, IP level doesn't need to follow it.*/}

set BORDER_CHECK YES        ; # Please set the value for the switch to "YES" OR "NO" only based on the descriptions above.
                            ; # Default value is "YES" to check BORDER rules.
                            ; # Please change the value "YES" into "NO" if BORDER rules shouldn't be checked.

#//*************************************
#//*  <Choice 7>  Latch Up selection   *
#//*************************************

set DEFINE_PAD_BY_TEXT  1    ;# valid value is 0, 1. default 1
                             ;# when¿?VDD?¿,¿?VCC?¿,¿?VSS?¿,¿?GND?¿ as text name using layer ALPATXT on ALPA,
                             ;# if valid value is 0, it is regarded as I/O PAD; if valid value is 1, it is regarded POWER PAD.    
                                     

set CONNECT_ALL_RESISTOR 0   ;#valid value is 0,1   default 0 
                             ;#when resistors are between PAD and AA injector   
                             ;#if valid value is 0,the connection is broken; if valid value is 1,the connection is not broken;

set LU_3_CHECK ACCURATE       ;#valid value is ACCURATE,FAST default ACCURATE
                              ;#choose LU.3[G] check mode.
#//*************************************
#//*  <Choice 8>  DFM Check selection  *
#//*************************************

set DFM_Priority1 NO          ;#valid value is NO,YES   default NO
                              ;#if valid value is NO, not to check DFM_Priority1 rules; if valid value is YES, check DFM_Priority1 rules.
                              ;#all the DFM rules don't gating tape-out


set DFM_except_Priority1 NO ;#valid value is NO,YES  default NO
                             ;#if valid value is NO, not to check DFM_except_Priority1 rules; if valid value is YES, check DFM_except_Priority1 rules.
                             ;#all the DFM rules don't gating tape-out
                            
#//***********************************************
#//   SMIC internal choice
#//***********************************************
#/*This switch can control all the recommended or guideline rules.
#  the default set is NO,Change "NO" to "YES" could open all the recommended or guideline rules.
#  NOTICE:this switch is only for SMIC PDE internal use.
#  Customer or other users please keep the default set "NO".
#  SMIC don't bear any responsibility for use this switch!
#*/
set OPEN_ALL_RECOMMENDED_GUIDELINE NO


##################################################The END for choice setting#############################################################################

if { [string equal $OPEN_ALL_RECOMMENDED_GUIDELINE YES] ==1 } {
set Latch_Up_CHECK      YES 
set DUP_CHECK           YES
set LDMOS_CHECK         YES 
set LOGO_CHECK          YES
set Metal_Slot_CHECK    YES
set Guard_ring_CHECK    YES 
set MOM_CHECK           YES
set ESD_CHECK           YES 
set Al_Fuse_CHECK       YES 
set Poly_EFuse_CHECK    YES  
set LMARK_CHECK         YES  
set CT_GT_G_CHECK       YES
}

#--------------------------------------------------------------------------------------------
# Usher should not modify the below script.
# Vaild metal option setting control.
# Below matrix shows all of available 6 combinations for choice.
set combinations {
{4 1 0 0 0}
{4 1 1 0 0}
{4 1 0 0 1}
{5 1 0 0 0}
{5 1 1 0 0}
{5 1 0 0 1}
{6 1 0 0 0}
{6 1 1 0 0}
{6 1 0 0 1}
{7 1 0 0 0}
{7 1 1 0 0}
{7 1 0 0 1}
{8 1 0 0 0}
{8 1 1 0 0}
{8 1 0 0 1}
{9 1 0 0 0}
{9 1 1 0 0}
{9 1 0 0 1}
{5 2 0 0 0}
{5 2 0 1 0}
{5 2 0 1 1}
{5 2 1 0 0}
{5 2 1 1 0}
{6 2 0 0 0}
{6 2 0 1 0}
{6 2 0 1 1}
{6 2 1 0 0}
{6 2 1 1 0}
{7 2 0 0 0}
{7 2 0 1 0}
{7 2 0 1 1}
{7 2 1 0 0}
{7 2 1 1 0}
{8 2 0 0 0}
{8 2 0 1 0}
{8 2 0 1 1}
{8 2 1 0 0}
{8 2 1 1 0}
{9 2 0 0 0}
{9 2 0 1 0}
{9 2 0 1 1}
{9 2 1 0 0}
{9 2 1 1 0}
{10 2 0 0 0}
{10 2 0 1 0}
{10 2 0 1 1}
{10 2 1 0 0}
{10 2 1 1 0}
}
if { [lsearch -start 0 -all -inline $combinations "$total_metal $top_metal $MTT2_UTV2 $STM1_STV1 $STM2_STV2"] eq "" } {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
}





VERBATIM {
//==============================================================================================================

  VARIABLE PA_su 1.25        //; In Smic LOTA, ALPA will be generated by the formual "(PA su 1.25) + RDL",
                            //; If CTM's LOTA not follows the value "1.25'" of PA grow, please fix it in the opition,
                            //; Be care that the value should not be smaller than 1.25um.


//********************************************************************************       
//                           CALIBRE DRC PROGRAM		         	    
//********************************************************************************       


//=================================================================================
//|                                                                               |
//|  0.055um Calibre DRC rule file for                                            |
//|                                                                               |
//|                                                                               |
//|       SMIC:          55nm Logic Salicide 1.2/1.8/2.5/3.3V Low Leakage and     |
//|                      0.9/1.8/2.5V Ultra Low Power and 1.0/1.8/2.5/3.3V Generic Process Design Rules |
//|                                                                               |
//|       Doc. No:       TD-LO55-DR-2002    Doc.Rev: 5      Tech.Dev.Rev:1.12     |
//|                                                                               |
//|                                                                               |
//|       SMIC Technologies                                                       |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//|    DISCLAIMER                                                                 |
//|                                                                               |
//|   SMIC hereby provides the quality information to you but makes no claims,    |
//| promises or guarantees about the accuracy, completeness, or adequacy of the   |
//| information herein. The information contained herein is provided on an "AS IS"|
//| basis without any warranty, and SMIC assumes no obligation to provide support |
//| of any kind or otherwise maintain the information.                            |
//|                                                                               |
//|   SMIC disclaims any representation that the information does not infringe any|
//| intellectual property rights or proprietary rights of any third parties.SMIC  |
//| makes no other warranty, whether express, implied or statutory as to any      |
//| matter whatsoever, including but not limited to the accuracy or sufficiency of|
//| any information or the merchantability and fitness for a particular purpose.  |
//| Neither SMIC nor any of its representatives shall be liable for any cause of  |
//| action incurred to connect to this service.                                   |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//|    STATEMENT OF USE AND CONFIDENTIALITY                                       |
//|                                                                               |
//|   The following/attached material contains confidential and proprietary       |
//| information of SMIC. This material is based upon information which SMIC       |
//| considers reliable, but SMIC neither represents nor warrants that such        |
//| information is accurate or complete, and it must not be relied upon as such.  |
//| This information was prepared for informational purposes and is for the use by|
//| SMIC's customer only. SMIC reserves the right to make changes in the          |
//| information at any time without notice.                                       |
//|   No part of this information may be reproduced, transmitted, transcribed,    |
//| stored in a retrieval system, or translated into any human or computer        |
//| language, in any form or by any means, electronic, mechanical, magnetic,      |
//| optical, chemical, manual, or otherwise, without the prior written consent of |
//| SMIC. Any unauthorized use or disclosure of this material is strictly         |
//| prohibited and may be unlawful. By accepting this material, the receiving     |
//| party shall be deemed to have acknowledged, accepted, and agreed to be bound  |
//| by the foregoing limitations and restrictions. Thank you.                     |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//|   This file includes SVRF/TVF Technology under license by Mentor Graphics     |
//| Corporation.  "SVRF/TVF Technology" shall mean Mentor Graphics' Standard      |
//| Verification Rule Format ("SVRF") and Tcl Verification Format ("TVF")         |
//| proprietary syntaxes for expressing process rules.  You shall not use SVRF/TVF|
//| Technology unless you are a Mentor Graphics customer with a license to use the|
//| applicable Mentor Graphics software. The exact terms of your obligations and  |
//| rights are governed by your respective license.  You shall not use SVRF/TVF   |
//| Technology except: (a) for your internal business purposes and (b) for use    |
//| with Mentor Graphics' Calibre tools. All SVRF/TVF Technology constitutes or   |
//| contains trade secrets and confidential information of Mentor Graphics or its |
//| licensors. You shall not make SVRF/TVF Technology available in any form to any|
//| person other than your employees and on-site contractors, excluding Mentor    |
//| Graphics competitors, whose job performance requires access and who are under |
//| obligations of confidentiality.                                               |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//| -. Skip the following rules:                                                  |
//|	  1)	  Current Density Rule						  |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//| Validated with Calibre version      2013.4_15.12                              |
//|                                                                               |
//| Revision History :                                                            |
//|   Rev               Date          Who                      What               |
//| V1.12_0         02-Aug-2016   Huan Yang   1.add DNW_5a_R,DNW_8,DNW_9,DNW_10,AA_8a,AA_11,AA_12_R,AA_13_R,AA_14_R,AA_15,AA_16_R,NW_9,PSUB_13,   |
//|                                                PSUB_14,PSUB_15_R,PSUB_16_R,VTNH_9,VTPH_9,LVN_9,LVP_9,GT_3e,GT_6_R,GT_6a_R,GT_13a,GT_14,GT_15, |
//|                                                GT_16,GT_17,GT_18_R,GT_19_G,GT_20,GT_21,GT_22,SN_9a,SN_9a_R,SP_9a_R,SN_11a,SN_13,SP_9a,SP_11a, |
//|                                                SP_15,SAB_2a,SAB_10a,SAB_12_R,SAB_13,CT_2c_R, CT_2d_R,CT_5a_R,CT_6a_R,CT_7c_R,CT_11,CT_12,     |
//|                                                CT_13_R,CT_14_G,V1_14,Vn_14,Vn_13_R,Vn_15_R ,TV1_9,TV1_10_R,STV1_10, TV2_10,TV2_11_R,RDL_5_R,  |
//|                                                ALPA_4_R,ALPA_5_R,SRAM_1b,SRVTNH_5,SRVTPH_5,Convention_1,Convention_2,Convention_3,RESAA_1a_R, |
//|                                                RESAA_4_R,RESP1_1a_R,EFU_1b_G,EFU_1c_G,EFU_2b_G,EFU_2c_G ,HRP_3_R,DUP_1_G,DUP_2_G,DUP_5_G,     |
//|                                                DUP_6_G,SRCK_26, due to DR update                                                              | 
//|                                           2.update AA_3a,AA_3b,AA_5,AA_7,VTNH_1,VTNH_3,VTNH_5,VTPH_1,VTPH_3,VTPH_5,LVN_1,LVN_3,LVP_1,LVP_3,   |
//|                                               DG_13,GT_3c_R,GT_3d_R,GT_4,GT_8,GT_13,SAB_5,SAB_10,CT_1,M1_2a,V1_1,TM1_5,STV1_9,STM1_2a,STM1_5, | 
//|                                               STV2_9,STM2_2a,STM2_5,TV2_1,TM2_1,TM2_2a,MTT2_1,MTT2_2a,MTT2_6,MTT2_7,MTT2_8,PA_1,PA_2,PA_3,    | 
//|                                               PA_1_R,PA_2_R,PA_3_R,RDV_1,RDV_2,RDV_3,RDV_4,RDV_5,RDL_1,RDL_2a,RDL_2b,RDL_3,RDL_4,ALPA_1,      |
//|                                               ALPA_2,ALPA_3,RDLPA2_1,RDLPA2_2,RDLPA2_3,RDLPA2_4,RDLPA2_5,BD_1,SRAA_5,SRGT_3c,SRGT_5c,RESAA_1, |
//|                                               RESNWAA_1,RESNWAA_2,RESNWAA_3,RESNWAA_4,RESNWST_1, RESNWST_9,RESP1_1, due to DR update,delet    |
//|                                               BD_3,EFU_1_2_G,EFU_1_2_NOSHR_G,EFU_3_G,EFU_3_NOSHR_G,EFU_4_G,EFU_4_NOSHR_G,EFU_5_6_G,           |
//|                                               EFU_5_6_NOSHR_G,EFU_7_G,EFU_7_NOSHR_G,EFU_8_G,EFU_8_NOSHR_G,EFU_10_G,EFU_11_G, due to DR delet, | 
//|                                           3.modify PSUB_9_R,PSUB_10_R,PSUB_11_R,PSUB_12_R to PSUB_9,PSUB_10,PSUB_11,PSUB_12, modify GT_7b_R,  | 
//|                                              GT_7c_R to GT_7b,GT_7c,modify RESP1_4 to RESP1_4_R,due to DR update.                             |
//|                                           4.optimize DNW_6_R,AA_1,AA_2b,AA_8,PSUB_6,LVN_5,LVN_7,LVP_5,LVP_7,DG_5,TG_5,SAB_11,CT_4a,CT_4b,     |
//|                                              M1_1,M1_3,M1_5,M1_6al,M1_6ah,M1_6c,M1_6d,M1_6e_mim_R,M1_6e_max_R,Mn_6al,Mn_6ah,Mn_6c,Mn_6d,      |
//|                                              Mn_6e_mim_R,Mn_6e_max_R,TM1_1,TM1_2a,TM1_4,TM1_6a,TM1_6b,STM1_6_l,STM1_6_h,STM2_8_l,STM2_8_h,HRP_9 |
//|                                           5.update LD_7_G,LD_7_NOSHR_G,LD_8a_G,LD_8a_NOSHR_G,LD_8b_G,LD_8b_NOSHR_G,GT_6a_R,GT_17,             |
//|                                              DFM_18 due to avoid miss violation                                                               |
//|                                           6.update DNW_3,GT_6, due to miss violation,                                                         |
//|                 24-Aug-2016               7.update NLL/PLL/NLH/PLH group rules and SRAM.1b due to DR update,update STV1_3a_3b,STV1_5a_5b,     |
//|                                              STV2_3a_3b,STV2_5a_5b due to false alarm in sealring,update GT_6,GT_6_R,PSUB_8,DFM_43 due to     |
//|                                              miss violation,update DNW_4 due to false alarm                                                   |
//|                 20_Sep-2016               8.Modify GT_6,GT_6_R,PSUB_8,DFM_43,SRAM_1b due to DR updated,add MOM_4_G due to DR update           |
//|                 09-Oct-2016               9.Optimize GT_9a,GT_9b due to false alarm in CTM's layout                                           |
//|                 14-Oct-2016              10.Modify DNW_7_R to DNW_7 due to DR update                                                          |
//|                 01-Nov-2016              11.Fix Latch_up issue due to avoid miss violation                                                    |
//|                 15-Nov-2016              12.Modify M4_2d,M5_2d,M6_2d,M7_2d,M8_2d to M4_2d_R,M5_2d_R,M6_2d_R,M7_2d_R,M8_2d_R due to DR update  |
//|-------------------------------------------------------------------------------|
//| V1.11_0	15-Dec-2015	Iori Wang	1. DR version up, update reference document info.
//|                                             2. Update UHVT group rule follow DR.
//|
//|V1.10_2_5       01-Sep-2015   Iori Wang      Update file version number only.  |
//|V1.10_4           08-Jul-2015    Lilian     1.modify UHVT.4 to fix false alarm |
//|                                                                               |
//|                                                                               |
//|   Rev               Date          Who                      What               |
//|-------------------------------------------------------------------------------|
//|V1.10_3           28-Apr-2015    Lilian      1.Add UHVT drawn layer            |
//|                                             2.Add Ultra Low Leakage rules code|
//|                                                                               |
//|                                                                               |
//|   Rev               Date          Who                      What               |
//|-------------------------------------------------------------------------------|
//|V1.0_2R           14-Oct-2013    Hu_Tang    Enhance LU_3_a_G, LU_3_b_G and procedure Mn_2b to reduce false alarm
//|V1.0_1R           06-Sep-2013    Hu_Tang    Enhance ESD_3_G, PA_1, PA_1_R, RDV_4, TM2DUMCK_1_2(for MTT2), RESP1_6
//|                                            Change MARKG into MARKGi in layers' definition of GR_* rules' codes
//|                                            Enahcne SRCK_18(ISOLATION),connection for AA resistor
//|                                            Enhance the procedure Mn_2b for wide metal space rules
//|                                            Update AA_7
//|                                            Add 3 conventional rules
//|                                            Update MTT2_2b, ALPA_2, RDL_2 for inductor
//|                                            Update AAi definition
//|V1.0_0R           02-Jan-2013    Hu_Tang    Change runset format into TVF
//|                                            Update PSUB_12_R,MTT2_6,BD_1,SRCK_24,skew_edge_check,connection for NW rules,metal density rules,
//|                                                   SRGT_4b,SRCT_4a,SRCT_6
//|                                            Add BD_4,SRAM_1,LD_14,SRCK_25,ESD rules,ALF_8,ALF_9,MTT2_12,
//|                                            Enhance PSUB_5,AA_4,AA_6,AA_7,SRAA_4,SRAA_6,SAB_5,CT_10
//|                                            Delete EXCLU in whole runset
//|PreV3.5.4=V1.9_0R_20120723   Hu_Tang        Enhance Mn_2b,Mn_2c
//|PreV3.5.4=V1.9_0R_20120416   Hu_Tang        Update Convention_latchup.a and Convention_latchup.b according to new 65nm ESD DR
//|                                            Enhance RDL_2b,ALPA_1
//|                                            Update definition of GT_EMPTY,AA_EMPTY,M1_SRE,CT_SRE,V1_SRE
//|                                            Add layer definition for M8R,M7R
//|PreV3.5.4=V1.9_0R_20120409_1 Hu_Tang        (DR update to v14.1R_20120406)
//|                                            Exclude the area covered by INST for NLL_1~NLL_11,PLL_1~PLL_11,NLH_1~NLH_11,PLH_1~PLH_11
//|------------------------------------------------------------------------------------------------------------------------------------
//|V3.5.4=V1.9_0R  19-Mar-2012  Hu_Tang 1.delete Convention_FLT_NW,Convention_BAD_INST,PR_1~PR_9
//|                                        delete the codes for old seal ring rules
//|                                        add codes for new seal ring and guard ring rules
//|                                        Add definition for new layer "MARKS"
//|                                        Distinguish datatype for "MARKG" and add new definition "MARKG = MARKGi OR MARKS"
//|                                        modify the definition for V1_slot~V5_slot,V1ia~V5ia,V1~V5,TV1,TV2
//|                                        delete the definition for TV1_slot,TV2_slot,SCT,CT_slot
//|                                        modify Vn_1,TV1_1,TV2_1,UTV2_1,TV2_1,CT_1
//|                                     2.update VTNH_2,VTPH_2,,VTPH_6, VTPH_7, VTNH_6, VTNH_7,LVN_2,LVP_2, 
//|                                     3.update DG_5,DG_4,TG_4,DG_12,TG_3,TG_5,TG_13
//|                                       delete DG_7,TG_8
//|                                       add DG_13,TG_14
//|                                     4.update RDLPA2_5,RDL_2b, RDL_2c
//|                                     5.Change from "NOT EXCLU" into  "NOT INSIDE EXCLU" in layer definition
//|                                     6.delete NC and PC rule codes
//|                                     7.Update DNW.3
//|                                       DNW.6_R rename from DNW_NOTE.1 
//|                                       DNW.7_R rename from DNW_NOTE.2
//|                                     8.update NLL_6_8,NLH_6_8,NLHT_6_8,PLL_6_8,PLH_6_8,PLHT_6_8
//|                                       delete NLL_5,NLH_5,PLH_5,PLL_5,NLHT_5,PLHT_5
//|                                       change NLL_9 rule No to NLL_10
//|                                       change NLL_10 rule No to NLL_11
//|                                       change PLL_9 rule No to PLL_10
//|                                       change PLL_10 rule No to PLL_11
//|                                       change NLH_9 rule No to NLH_10
//|                                       change NLH_10 rule No to NLH_11
//|                                       change PLH_9 rule No to PLH_10
//|                                       change PLH_10 rule No to PLH_11
//|                                       add NLL_12,PLL_12,NLH_12,PLH_12
//|                                       change the rule number for NLH,NLHT,PLH,PLHT rules
//|                                     9.interchange SN.5 and SN.6 rule No, 
//|                                       update SN_6_8,SP_6_8
//|                                       change SP_12 rule No to SP_13
//|                                       update SN_10,SP_5,SN_5
//|                                       add SN_12,SP_12
//|                                     10.delete NW_NOTE.1,NW_NOTE.5
//|                                        add NW_7a,
//|                                        update NW_6,NW_7b
//|                                     11.PSUB_9_R rename from PSUB_note.6 
//|                                        PSUB_10_R rename from PSUB_note.1a/1b
//|                                        PSUB_11_R rename from PSUB_note.2
//|                                        PSUB_12_R rename from PSUB_note.3
//|                                        update PSUB_10,PSUB_12,PSUB_8,PSUB_2
//|                                     12.delete HR,PDRF all codes
//|                                     13.update GT_7a,GT_11,GT_8,
//|                                        add GT_7b_R,GT_7c_R,GT_3c_R
//|                                     14.delete rule EFU.9
//|                                     15.delete 13R HRP_9,HRP_10,HRP_11
//|                                        rename from 13R HRP_2 to 14R HRP_4,
//|                                        rename from 13R HRP_3 to 14R HRP_5
//|                                        rename from 13R HRP_4 to 14R HRP_6
//|                                        rename from 13R HRP_5 to 14R HRP_7
//|                                        rename from 13R HRP_6 to 14R HRP_8
//|                                        rename from 13R HRP_7 to 14R HRP_9
//|                                        rename from 13R HRP_8 to 14R HRP_10
//|                                        add 14R HRP_11,HRP_12,HRP_1,HRP_2,HRP_14
//|                                     16.delete LD.1b,LD.5b,LD_9,LD_12
//|                                        update LD_6,LD_7
//|                                        rename from LD.8 to LD.8a and update the codes.
//|                                        rename from LD.10 to LD.9
//|                                        rename LD_11 from LD_13
//|                                        add LD_8b,LD_10,LD_12
//|                                     17.update RESAA_1,RESAA_7,RESAA_10,RESAA_3,RESAA_5
//|                                        add RESAA_9
//|                                     18.change rule number from RNWAA_* into RESNWAA_*
//|                                        update RESNWAA_7,RESNWAA_8,RESNWAA_9
//|                                        add RESNWAA_11
//|                                        add RESNWAA_10
//|                                     19.change rule number from RNWSTI_* into RESNWST_*
//|                                        update RESNWST_8,RESNWST_6,RESNWST_7,RESNWST_4,
//|                                     20.add RESP1_8,RESP1_9,RESP1_10
//|                                        update RESP1_1,RESP1_3,RESP1_5,RESP1_6
//|                                     21.add layer definition for NPR1 and ESD1
//|                                     22.update AA_10a,AA_2a,
//|                                        add AA_10b_R
//|                                        change rule number AA_Note2 into AA_10c_R.
//|                                     23.remane CT_7->CT_7a,CT_8->7b,
//|                                        update CT_1, CT_2b, CT_10,CT_7a_7b,
//|                                        delete CT_5b
//|                                     24.rename M1_Note4_l/M1_Note4_h ->M1_6e_min_R/M1_6e_max_R
//|                                        delete M1_DUM38
//|                                        rename Mn_Note5_l/M1_Note5_h ->Mn_6e_min_R/M2_6e_max_R
//|                                        delete Mn_DUM38
//|                                        update M1_6b,Mn_6b,M2_4,
//|                                        change the rule number for M1_7
//|                                     25.delete V1_7,V1_8
//|                                        rename V1_3->V1_3a,V1_4->V1_3b,V1_5->V1_5a,V1_6->V1_5b
//|                                        delete Vn_7,Vn_8
//|                                        rename Vn_3->Vn_3a,Vn_4->Vn_3b,Vn_5->Vn_5a,Vn_6->Vn_5b
//|                                        update Vn_Note1
//|                                        rename Vn_11_12_R from Vn_Note1
//|                                     26.All TV1a.*  and TM1a.* rule rename to TV1.* and TM1.* rule
//|                                        rename TV1a.2->TV1.2a,TV1a_3_4_7->TV1_3a_3b,
//|                                        delete TV1a_5_6_8,
//|                                        Add TV1.2b_R,TV1_5
//|                                     27.All TV2a.*  and TM2a.* rule rename to TV2.* and TM2.* rule
//|                                        rename TV2a.2->TV2.2a,TV2a_3_4_7->TV2_3a_3b,
//|                                        delete TV2a_5_6_8,
//|                                        Add TV2.2b_R,TV2_5
//|                                     28.update MTT2 and UTV2 rules
//|                                     29.rename PA_Note* to PA_*_R
//|                                     30.add codes for SRAM rules and dummy check rules.
//|                                     31.delete "* NOT INSIDE INST" in some general rules in order to check SRAM area also.
//|                                     32.distinguish the data type for all layers
//|                                        update the definition for CT,GATE,Vn,TV1,TV2
//|                                     33.FOR SWITCH:
//|                                        delete the switch "ALPA_drawn","Vnote_check","DRC UNSELECT CHECK"
//|                                        add the switch "BORDER_CHECK" for BORDER rules
//|                                        add the switch "Recommended_rules_CHECK" and "Guidelines_rules_CHECK" for recommended rules and guidelines rules
//|                                     34.update the format for the whole runset
//| -------  -------------  -----------  ----------------------------------------------------------------------------------------------------------------------|
//|  3.5.3    29-June-2011   Zhitao Chen Remove "INSIDE OF LAYER NWi" in NW_NOTE.5|
//|                                       Optimize description for choice GBD.    |
//|  3.5.2    24-June-2011   Zhitao Chen Optimize wide metal space check algorithm|
//|  3.5.1    14-June-2011   Zhitao Chen NW_NOTE.6 ==> NW_NOTE.5, 0.25=>0.23 .    |
//|  3.5      11-June-2011   Zhitao Chen Split DFM rules into another runset.     |
//|  3.4      1-June-2011    Zhitao Chen Copied from old file first.              |
//|                                       Then modified for number of metals.     |
//|                                      Remove PI rule. Add RDLPA2_4/5 ALF_7.    |
//|                                      RDL_4 updated.                           |
//|                                      AA_10a and AA_Note2 25% changed to 23%.  |
//|                                      M1/Mn_DUM38 TM1/2_DUM14 added.           |
//|                                      PSUB_NOTE.6 added.                       |
//|                                      Fix confusing of <0.5 and <=0.5 in       |
//|                                       V1_Note and Vn_Note1.                   |
//|                                      Add OPPOSITE option in SN_2 and SP_2.    |
//|                                      Change Vnote_check_No to Vnote_check YES.|
//|                                      NW_NOTE.6 default changed to checked.    |
//|                                      Implement PA_Note1.                      |
//|                                      PA_Note1/2/3 default changed to checked. |
//|                                      DG_12/TG_13 0.24 => 0.33 in SD direction.|
//|                                      Update CT_1 CT_10 RDV_2 for seal ring.   |
//|                                       Add seal ring rules SEAL_*. (GSEAL)     |
//|                                      Exclude MOM in DFM5.                     |
//|                                      Add V1_10/Vn_10.                         |
//|                                      Remove 55nm option.                      |
//|                                                                               |
//|*******************************************************************************|
//|                                                                               |
//| Old File Name: SmicDR13R2R_cal65_mixlog_sali_p1mt10_2tm_10182533_IPlevel.drc  |
//|                                                                               |
//|  3.3      22-April-2011  Zhitao Chen DFM Priority2 default changed to NO.     |
//|                                      Density rules AA_Note2 GT_Note3 relaxed. |
//|                                      M1_2* Mn_2* updated following document.  |
//|                                       Optimize coding of M1_2c and Mn_2c.     |
//|                                      DFM1a_2a implemented, GT_4a renamed GT_4.|
//|                                      Move GT_4b to DFM1b_2b Priority1.        |
//|                                      DFM4 implemented.                        |
//|                                      DFM18 (Priority2) removed. That's because|
//|                                       it's difficult to implement it correctly|
//|                                       which is limited by Calibre DRC tool.   |
//|                                      DFM21 code updated following discussion  |
//|                                       with DFM rule owner Daniel Lu.          |
//|                                      Move TV1a_2b TV2a_2b to DFM22 priority2. |
//|                                      DFM23-25 added as Priority2.             |
//|                                       (more strict rules than NW_4/6/7)       |
//|                                      NW_5 implemented back.                   |
//|                                      Create option ALLOW_V01 default NO.      |
//|                                       It controls whether allow 0.1 sized via.|
//|                                      Update and fix TM1 and TM2 space rules.  |
//|                                      Mn_Note4(n=2...8) renamed to Mn_Note5.   |
//|                                       Coding of LD_13 optimized.              |
//|                                                                               |
//|  3.2      18-April-2011  Zhitao Chen Update E-fuse rules EFU_*.               |
//|                                      Update LDMOS rules LD_1a/b, LD_5a/b.     |
//|                                      GT_11 RESP1_2 updated for HRP false alarm|
//|                                      Mixed signal rules added, except MIM.    |
//|                                        NWRES AA/STI rules are off by default. |
//|                                      TM2DUM_Note2 renamed to TTM2_14.         |
//|                                      Convention_BPMO and BAD_IMP removed.     |
//|                                                                               |
//|*******************************************************************************|
//|                                                                               |
//| Old File Name:  SmicDR13R_cal65_log_sali_p1mt10_2tm_10182533_IPlevel.drc      |
//|                                                                               |
//|  3.1.c    05-April-2011  Zhitao_Chen Add Calibre version for validation above.|
//|                                        Default voltage choice changed to 1825 |
//|                                        Add RESAA_10.                          |
//|                                        PSUB_5/PSUB_NOTE.5 for 65nm/55nm.      |
//|                                        M1_Note4 and Mn_Note4 updated.         |
//|                                        SINGULAR removed from SN_1/2 SP_1/2.   |
//|                                        Description of potential changed to net|
//|                                        Description DG_5/6 TG_6 LD_6 updated.  |
//|                                        RDLPA2_2 10 --> 5. BD_1 BD_2 BD_3 added|
//|                                        INDMY/MARKF/MARKG disables from rules: |
//|                                          TM2a_7, TM2b_8.                      |
//|                                        Max metal width 8-->12.                |
//|                                        TM1a_6 TM1b_6 & M1/Mn density updated. |
//|                                        This is IP level runset, it follows    |
//|                                          stricter value from 10R to 13R.      |
//|                                          See table in attachment of DR doc.   |
//|                                        Top via array rules implemented.       |
//|                                                                               |
//|  3.1.b    09-Mar-2011    Carolyn Y   Modify AADUM_9_19(add "AADUM cross NW is |
//|					   not allow").				  |
//|  3.1.a    25-Feb-2011    Carolyn Y   DR update 13R_v3(temp) :		  |
//|					 1.Modified DNW.3(1.0->0.4),deleted DNW.6.|
//|					 2.Modified AADUM_20_2, PODUM_20_23(add   |
//|					   MARKF&MARKG).			  |
//|					 3.Added PSUB_NOTE.5 for 55nm technology. |
//|					 4.Changed LDAA_? rule NO. to LD_? .	  |	
//|					   Splited LDAA_1->LD_1a&LD_1b,		  |
//|					   Splited LDAA_5->LD_5a&LD_5b.		  |
//|					 5.Added Mn.2b, Modified TM1b_2b/TM2b_2b  | 
//|					   (parallel segment 2um->0.4um).         |
//|					 6.Modified Mn_6a(exclude INDMY area),    |
//|					   Mn_6cMn_6c(exclude INDMY area,30%->40%).|
//|   3.0     15-Feb-2011    Carolyn Y   Merge DFM rules.			  |
//|					 Delete DFM.3, DFM.7, DFM.8.		  |
//|					 Add DFM.21(Priority1).			  |
//|					 Modify LDAA_5(transistors->channel gate) |
//|					 Optimize Vn_Note 			  | 
//|   2.2     19-Nov-2010    Seek Rui    Correct NC_3;                            |
//|                                      Optimize Vn_Note.                        |
//|                                      Optimize Via_slot defination.            |
//|   2.1     29-Oct-2010    Seek Rui    Modify PSUB_NOTE.3,CT_6,GT_5:            |
//|                                         these rules will not report error in  |
//|                                         INDMY area.                           |
//|                                      Delete Vn_Note2.                         |
//|                                      Add a note for "VIRTUAL CONNECT".        |
//|   2.0     07-Oct-2010    Carolyn Y   DR update to 12R :      		  |
//|					 Add GT.Note4 and add a switch for 55nm;  |
//|					    Mn.6b&c; LDMOS rule.		  |
//|					 Modify SAB.1/2(0.36->0.40).		  |
//|					    Vn.4&7(0.025->0.03),Vn.6&8(0.01->0.02)|
//|					    DNW.2(4.0->3.5), DNW.4(1.0->0.4),	  |
//|					    DNW.5(3.0->2.5).			  |
//|					    SAB.1/SAB.2(0.36->0.40).		  |
//|					    HR.5/HR.6/HR.8(add opposite), NLHT.5. |
//|					    AA.4, AA.7, GT.5, NLHT_6_8, PLHT_6_8, |
//|					    Convention_BPMO (exclude LDMOS check).|
//|					 Optimize Vn_slot, GVn.			  |
//|					    The option of IO voltage.		  |
//|*******************************************************************************|
//| Old File Name :  SmicDR11R_cal65_log_sali_p1mt8_2tm_10182533.drc              |
//|   1.3     03-Sep-2010    Seek Rui    Correct Vn.Note2.                        |
//|   1.2     28-Jul-2010    Seek Rui    Add SRAM block layer EXDRC.              |
//|                                      Update ALPA rules for short violation,   |
//|                                         and set opition for ALPA check.       |
//|                                      Modify on GT_6, no need to check for     |
//|                                                             L shape poly.     |
//|                                      Merge Vn_Note1a & Vn_Note1b to Vn_Note.  |
//|   1.1     20-Jul-2010    Seek Rui    Modify the runset grid 0.005->0.001.     |
//|                                      Set opition for Vn Note check, default off|
//|                                      Opitimize on Vn.Note, wide metal with    |
//|                                        no via will also reported by this rule.|
//|   1.0     16-Jul-2010    Seek Rui    Opitimize AA_2b: Avoide false error      |
//|                                                   coursed by AA crossing DG/TG|
//|                                                TTM2_10: Redefine the active   |
//|                                                         device and native     |
//|                                                         device for this check.|
//|                                     Modify with DR update to 11R:             |
//|                                      Layer EXCLU will be regard as NO DRC area|
//|                                      Add layers:                              |
//|                                              HR(34:0),EFUSE(81:2),VARJUN(94:0)|
//|                                           PDRF(104:0),DMPNP(134:0),DSTR(138:0)|
//|                                              M1R(171:0)~M8R(178:0),TM1R(201:0)|
//|                                                       TM2R(202:0),MARKG(189:0)|
//|                                                    MOMDMY(211:1), DTDMY(191:3)|
//|                                      Opitimize defination:                    |
//|                                        HVNW: NW INTERACT TG->NW NOT OUTSIDE TG|
//|                                        MVNW: NW INTERACT DG->NW NOT OUTSIDE DG|
//|                                        EFU : GT INTERACT GTFUSE->GT INTERACT EFUSE |
//|                                        GMn : Mn TOUCH HMn->(Mn TOUCH HMn) AND MARKG|
//|                                      Add rules:                               |
//|                                        DNW_6,DNW_NOTE.2,PSUB_NOTE.3,          |
//|                                        VTNH_8,VTPH_8,LVN_8,LVP_8,DG_7,DG_8,   |
//|                                        DG_9,DG_10,DG_11,DG_12,TG_8,TG_9,TG_10 |
//|                                        TG_11,TG_12,TG_13,GT.13;               |
//|                                        HR rules, PDRF rules;
//|                                        ALPA rules, and set a opition for it;  |
//|                                        V1_Note.a,V1_Note.b,Vn_Note1.a,        |
//|                                        Vn_Note1.b,Vn_Note2,                   |
//|                                        RDV_5,RDL_4
//|                                      Modify rules:                            |
//|           SmicDR14.1R_20120406_cal65_log_sali_p1mt10_2tm_1012182533_PreV3.5.4=V1.9_0R_20120416.drc                             AA_2a : 0.12->0.11;                    |
//|                                        NW_1/NW_3: 0.32->0.36;                 |
//|                                        NW_6/NW_7: 0.47->0.72;                 |
//|                                        PSUB_1/PSUB_4: 0.32->0.36;             |
//|                                        VTNH_6/VTNH_7: 0.20->0.185;            |
//|                                        VTPH_6/VTPH_7: 0.20->0.185;            |
//|                                        LVN_6/LVN_7: 0.20->0.185;              |
//|                                        LVP_6/LVN_7: 0.20->0.185;              |
//|                                        DG_4/TG_4:Check poly direction enclose;|
//|                                        DG_5/TG_5:Check pattern outside DTDMY; |
//|                                        GT_5: 0.12->0.115;                     | 
//|                                        GT_6: 0.10->0.14;                      |
//|                                        GT_11: Check excpet MOM area;          |
//|                                        NLL_8/NLH_8/NLHT_8/PLL_8/PLH_8/PLHT_8/ |
//|                                        SN_8/SP_8: 0.17->0.16;                 |
//|                                        CT_5: 0.03->0.015;                     |
//|                                        CT_6: 0.02->0.01;                      |
//|                                        Vn.2b: vias' space < 0.15um will be    |
//|                                               regarded as via array.          |
//|                                        RDL_1: 1.5->3.0;                       |
//|                                        RDL_2a: 1.5->2.0;                      |
//|                                        PSUB_Note2/Mn_Note4/TTM2_10:           |
//|                                               No need check for inductor area;|
//|                                      Delete rules:                            |
//|                                        NW_NOTE.5;                             |
//|*******************************************************************************|
//| Old File Name :  SmicDR10R_cal65_log_sali_p1mt8_2tm_10182533.drc              |
//|   1.1     18-Mar-2010     Seek Rui   Add a opition for NW_NOTE.6,             |
//|                                          default to not check.                |
//|   1.0     12-Mar-2010     Seek Rui   Delete AADUM_24,PODUM_19,PODUM_21,       |
//|                                             PODUM_28,MnDUM_6,MnDUM_8,TM1DUM_6 |
//|                                             TM1DUM_8,TM2DUM_6,TM2DUM_8,       |
//|                                             TM2DUM_Note1.                     |
//|                                      Add TTM2_5,TTM2_10,TTM2_13.              |
//|                                      Modify PA_Note2, NW_3, NW_4:             |
//|                                             Waive corner error.               |
//|                                      Modify TV1b_9,TV2b_9:                    |
//|                                             Waive error in Lmark/Fuse_GR area.|
//|   0.3     05-Mar-2010    Carolyn Y   Modify AADUM_20_23/PODUM_20_23 : delete  |
//|					      DUMBA,DUMBP check.		  |
//|					 Delete GT_13.				  |
//|   0.2     03-Mar-2010     Seek Rui   Modify AA_8: 0.054->0.038.               |
//|                                      Delete rule check of AADUM_11,AADUM_13,  |
//|                                           AADUM_17,AADUM_18,PODUM_11,PODUM_13,|
//|                                           PODUM_17,PODUM_18,MnDUM_1_2,        |
//|                                           MnDUM_3_4,MnDUM_6,MnDUM_7.          |
//|                                      Delete AADUM to GTDUM space check in GT_4|
//|                                      Add AADUM_19,AADUM_21,AADUM_23,AADUM_24, |
//|                                          PODUM_19,PODUM_21,PODUM_23,PODUM_24, |
//|                                          PODUM_25,PODUM_28,MnDUM_6,MnDUM_8,   |
//|                                          TM1DUM_6,TM1DUM_8,TM2DUM_6,TM2DUM_8, |
//|                                          TM2DUM_Note1,TM2DUM_Note2.           |
//|                                      Add GT_13, GT area rule.                 |
//|                                      Add layer STSRAM(60:1),DNSRAM(60:2),     |
//|                                         UDSRAM(60:3),DPSRAM(60:4),RFSRAP(60:5)|
//|   0.1     25-Feb-2010     Seek Rui   Update DRC following 10R:                |
//|                                      Modify rules:                            |
//|                                       1.NLL_6_8/NLH_6_8/PLL_6_8/PLH_6_8/SN_5_8|
//|                                         /SP_6_8: value change on NLL_8/NLH_8/ |
//|                                         PLL_8/PLH_8/SN_8/SP_8, 0.20->0.17.    |
//|                                       2.AA_9: modify description, drc will not|
//|                                         report error when the N+AA inside DNW.|
//|                                       3.Update dummy check following dummy    |
//|                                         note.                                 |
//|                                     Add rules:                                |
//|                                       1.GT_Note2.                             |
//|                                     Delete the opition of dummy rules.        |
//|*******************************************************************************|
//| Old File Name :  SmicDR9R_cal65_log_sali_p1mt8_2tm_10182533.drc               |
//|   0.1     08-Feb-2010     Seek Rui   Update DRC following 9R:                 |
//|                                      Modify rules:                            |
//|                                       1.AA_10 density : [30%,75%]->[25%,75%]  |
//|                                       2.GT_7 density : [15%,1]->[10%,70%]     |
//|                                       3.DNW_2 value: 3->4; DNW_3 value: 2->1; |
//|                                         DNW_4 value: 2->1; DNW_5 value: 4->3. |
//|                                       4.DNW_Note1: Delete DNW not enclosure   |
//|                                                    NW hole check.             |
//|                                       5.PSUB.3c: Modify on description.       |
//|                                       6.GT_1c: This rule will check device    |
//|                                                that "NOT ITERACT UNDERPL".    |
//|                                       7.CT.2b,V1.2b,Vn.2b: Modify the space   |
//|                                           that CT/Vias should be regarded as  |
//|                                           in the same array, 0.16->0.15.      |
//|                                       8.TV2b_2->TV2b_2a.                      |
//|                                       9.PR_1: Modify in description.          |
//|                                      10.PR_2 value: 0.36->0.28.               |
//|                                      Add rules:                               |
//|                                       1.AA_10b, AA_Note.2.                    |
//|                                       2.NW_Note.3, NW_Note.6.                 |
//|                                       3.NW_Note.5: set opition for it,        |
//|                                                  default to not check.        |
//|                                       4.GT_1f, GT_Note.3.                     |
//|                                       5.M1_Note.4, Mn_Note.4.                 |
//|                                       6.TM2b.8a, TM2b.8b.                     |
//|                                       7.TV2b_2b.                              |
//|                                       8.Convention_BAD_INST.                  |
//|                                       9.Dummy check in normal rule refer to   |
//|                                           AA_Note.3, GT_Note.4, MnDUM_Note.2, |
//|                                           TM1DUM_Note.2, TM2DUM_Note.2.       |
//|                                      10.Recommand dummy rule check and set    |
//|                                           opition for it, default to check.   |
//|                                      Add layers:                              |
//|                                           UNDERPL(125:5),INST(60)             |
//|                                      Delete layers:                           |
//|                                           OPCBA(100),OPCBP(101),OPCBM(102).   |
//|                                                                               |
//|*******************************************************************************|
//| Old File Name :  SmicDR8R_cal65_log_sali_p1mt8_2tm_10182533.drc               |
//|   1.1     18-Nov-2009    Seek Rui    Modify the defination of PW_INNW,NW_DNW. |
//|                                          in order to correct DNW_NOTE.1       |
//|                                      Add Skew rule.                           |
//|   1.0     07-May-2009    Seek Rui    DR update to 8R:                         |
//|                                      Delete Rules:                            |
//|                                       1. VTNH.3,VTPH.3,LVN.3,LVP.3.           |
//|                                       2. M1.3a,Mn.3a,TM2.7b                   |
//|                                       3. DNW_NOTE.2                           |
//|                                      Modify Rules:                            |
//|                                       1. DRC will only check parallel edges on|
//|                                          width rules and space rules on space |
//|                                          rules of same layer.                 |
//|                                       2. Change rule No. M1.2->M1.2a;M1.3b->M1.2b|
//|                                            M1.3c->M1.2c; M1.8->M1.3; Mn.2->Mn.2a;|
//|                                            Mn.3b->Mn.2b; Mn.3c->Mn.2c; Mn.8->Mn.3|
//|                                            TM2a.8->TM2a.6; TM2b.7->TM2b.6;    |
//|                                            TM2b.8->TM2b.7.                    |
//|                                       3. Define AA_act & GT_act to indentify  |
//|                                          true AA/GT from AADUM/GTDUM.         |
//|                                       4. Define CT_slot,Vn_slot,TV1_slot,     |
//|                                          TV2_slot, to indentify sealring slots|
//|                                       5. DNW2: 6.0->3.0.                      |
//|                                       6. GT.3b: 0.14->0.4; GT.5: 0.15->0.12.  |
//|                                       7. CT.3: 0.07->0.065; CT.4a: 0.055->0.05|
//|                                       8. M1.2b: 0.18->0.16; M1.4 0.036->0.027;|
//|                                          Mn.4: 0.045->0.035; TM1a.4: 0.7->0.6;|
//|                                          TM2a.4: 0.7->0.6; V1.4: 0.03->0.025; |
//|                                          Vn.4: 0.03->0.025.                   |
//|                                       9. PA.1: 1.5->1.0; RDV.4: 1.5->1.0.     |
//|                                      10. PR.1: 0.11->0.09.                    |
//|                                      11. Add command "OUTSIDE ALSO" in PA.1.  |
//|                                      12. Convention_BAD_IMP: AA->AAi,SN->SNi, |
//|                                                              SP->SPi.         |
//|                                      13. RESAA.8/RESP1.7: Correct false error |
//|                                                        for saliside resistor. |
//|                                      Add Rules:                               |
//|                                       1. TV1b.9,TV2b.9.                       |
//|*******************************************************************************|
//| Old File Name :  SmicDR7R_cal65_log_sali_p1mt10_2tm_10182533.drc              |
//|   1.0     15-May-2009    Seek Rui     DR update to 7R                         |
//|                                       Modify Rules:                           |
//|                                        1. Origion layer M3i~M8i   to M3~M8    |
//|                                                         TM1i/TM2i to TM1/TM2  |
//|                                                         V3i~V7i   to V3~V7    |
//|                                                         TV1i/TV2i to TV1/TV2  |
//|                                        2. M1.2/M1.3a/M1.3b/M1.3c/M2.2/M2.3a/  |
//|                                           M2.3b/M2.3c/NW.3/NW.4 check way in  |
//|                                              order to check the space between |
//|                                              normal M1/M2/NW to the layers    |
//|                                              covered by EXCLU layer           |
//|                                        3. LVN.1/LVN.2/LVP.1/LVP.2 (use normal |
//|                                                   way to check width & space) |
//|                                        4. LVN.1/LVN.2/LVP.1/LVP.2/NC.1/NC.2/  |
//|                                           PC.1/PC.2/VTNH.1/VTNH.2/VTPH.1/VTPH.2/|
//|                                           do not check point touch error      |
//|                                        5. Convention_latchup.a(NW->NWi)       |
//|                                        6. Following DR update:                |
//|                                          AA_2b(0.3->0.21), AA_3b(0.13->0.11)  |
//|                                          RESAA_1(2.0->0.5),RESP1(2.0->0.5)    |
//|                                          NW_4(0.5->0.47), NW_6/NW_7(0.6->0.47)|
//|                                          PSUB_5/PSUB_6/(AA->MOS)&description  |
//|                                          NC_4/NC_5/PC_4/PC_5(0.18->0.12)&description|
//|                                          NC_6/NC_7/PC_6/PC_7(0.27->0.20)&description|
//|                                          VTNH_4/VTNH_5/VTPH_4/VTPH_5/LVN_4/LVN_5/|
//|                                          LVP_4/LVP_5: (0.16->0.12)&description|
//|                                          VTNH_6/VTNH_7/VTPH_6/VTPH_7/LVN_6/LVN_7/|
//|                                          LVP_6/LVP_7: (0.21->0.20)&description|
//|                                          DG_3/DG_5/TG_3/TG_5(AA->MOS)&description|
//|                                          DG_4/DG_6/TG_4/TG_6(0.33->0.24)      |
//|                                          GT_3b&description                    |
//|                                          NLL_7/NLH_7/NLHT_7(NACT->NMOS)&description|
//|                                          PLL_7/PLH_7/PLHT_7(PACT->PMOS)&description|
//|                                          SN_7/SP_7&its description            |
//|                                          SAB_9(0.28->0.20), CT_4b(0.11->0.09) |
//|                                          M1_3a(0.14->0.11)&description        |
//|                                          M1_3b(0.30->0.18)&description        |
//|                                          M1_3c&description                    |
//|                                          V1_3_4_7/Vn_3_4_7(0.04->0.03)        |
//|                                          Mn_3a(0.15->0.12)&description        |
//|                                          Mn_3b(0.30->0.16)&description        |
//|                                          Mn_3c&description                    |
//|                                          M1.6a(35%->20%) M1.6b(75%->80%)      |
//|                                          Mn.6a(35%->20%) Mn.6b(75%->80%)      |
//|                                          TV1a_5_6_8(0.03->0.02)               |
//|                                          TM1a_1/TM1a_2a/TM1a_3(0.42->0.40)    |
//|                                          TM1a_2b&description                  |
//|                                          TM1b_2b/TM1b_2c/TM1b_2d&description  |
//|                                          TV2a_5_6_8(0.03->0.02)               |
//|                                          TM2a_1/TM2a_2a/TM2a_3(0.42->0.40)    |
//|                                          TM2a_2b&description                  |
//|                                          TM2b_2b/TM2b_2c/TM2b_2d&description  |
//|                                          TM2b_5(20->30)                       |
//|                                          TTM2_2b&description                  |
//|                                          the rule name (PA1.n->PA.n)          |
//|                                                        (PA2.n->RDLPA2.n)      |
//|                                       Add Rules                               |
//|                                        1. PA_Note2, PA_Note3                  |
//|                                        2. layer GTFUSE(81;1)&E-FUSE rules     |
//|                                        3. layer MARKF(190)&Alfuse rules       |
//|                                        4. L-Mark Guideline rules              |
//|                                        5. PI Guideline rules                  |
//|                                       Delete TTM2_2c                          |
//|                                                                               |
//|*******************************************************************************|
//| Old File Name :  SmicDR6R_cal65_log_sali_p1mt10_2tm_10182533.drc              |
//|   1.0     19-Mar-2009     Seek Rui    1.Modify PSUB.3b(0.5->0.8).             |
//|                                       2.Modify PSUB.3c(0.5->1.0) and delete   |
//|                                                3.3V in it's description.      |
//|                                       3.Modify Wide metal check               |
//|                                                Use 'WITH WIDTH' to check it.  |
//|                                       4.Add PSUB.3d following DR.             |
//|                                       5.Add opition 'backup' in desity check. |
//|                                       6.Add Latch_up rule.                    |
//|                                       7.Add LVN.3,LVP.3,VTNH.3,VTPH.3         |
//|                                       8.Add overdrive discription in GT.1e    |
//|                                       9.Add opition 'opposite' in GT.5        |
//|*******************************************************************************|
//| Old File Name :  SmicDR5R_cal65_log_sali_p1mt10_2tm_10182533.drc              |
//|   1.0     03-Dec-2008     Seek Rui     DR update to 5R :                      |
//|                                        Add TM1b,TM2b,TV1b,TV2b,TTM2,RDL,PA1,  |
//|                                        PA2,RESAA,RESP1,GT.1e following DR.    |
//|                                        AddE ALPA_drawn NO   //; Customer can use "ALPA_drawn YES" instead of it if your origion layout includes ALPA(83:0)
//|                                        TM1a_6a/TM1a_6b,TM2a_6a/TM2a_6b    |
//|                                        Modify AA_3b(0.14->0.13),AA_10,        | 
//|                                        PSUB.NOTE2                             |
//|                                        VTNH_4/VTNH_5,VTPH_4/VTPH_5,LVP_4/LVP_5|
//|                                        LVN_4/LVN_5(0.18->0.16)                |
//|                                        VTNH_6/VTNH_7,VTPH_6/VTPH_7,LVP_6/LVP_7|
//|                                        LVN_6/LVN_7(0.27->0.21)                |
//|                                        NLL_6,PLL_6,NLH_6,PLH_6,NLHT_6,PLHT_6, |
//|                                        SN_5/SN_6,SP_5/SP_6(0.26->0.24)        |
//|                                        DG_4/DG_6,TG_4/TG_6(check channel along S/D direction)|   
//|                                        CT.3(0.1->0.07)                        |
//|                                        CT_2b,Vn_2b(overunder size 0.075->0.08)|
//|                                        GT_7(add DGTi check density)           |
//|                                        Mn.6(Max.0.82->0.75,Min.0.16->0.30),   |
//|                                        metal desity widow(50->200),step(25->100)|
//|                                        Mn.7 according to DR                   |
//|                                        TM1_4/TM2_4(1->0.7)                    |
//|                                        Add layer RDLVIA,RDLP2,LOGO,INST,OVERPL|
//|                                        Optimize NW.4,NC.4,PC.4 definition     |
//|*******************************************************************************|
//| Old File Name : SmicDR4T_cal65_log_sali_p1mt10_2tm_10182533.drc               |
//|   1.0.d   29-Aug-2008     Carolyn Y    Modify Mn.3a,Mn.3b,AA.3b(">=" -> ">")  |
//|                                        GT.3b(">" -> ">="),                    |
//|                                        Mn.7,CT.2b&Vn.2b(0.110->0.075)         |
//|                                        Add GT.5b(CT on STI is not allowed)    |
//|   1.0.c   07-Mar-2008     Karen Kang   Resolution:1->5			  |
//|   1.0.b   21-Dec-2007     Karen Kang   NLHT.5,PLHT.5,NW.2(1.8->1.6)           |
//|					   PSUB.3c(1.2->0.5),CT_7_8(0.04->0.025)  |
//|					   TMn.3(0.42->0.28)                      |
//|					   metal desity widow(100->50),step(50->25)|
//|					   modify AA.6,AA.7,NLL.7,NLH.7,PLL.7,PLH.7|
//|					   NLHT.7,PLHT.7,SN.4,SP.4,SP.7,SP.9,SP.10|
//|   1.0.a   22-Oct-2007     Lucy Li      DR update to 4T                        |
//|                                        update AA.2b, CT.4a,CT.4b,NC.1,NC.2    |
//|                                        PC.1,PC.2 according to DR              |
//|                                        Modify DG_5,TG_5,GT_8,LDDI_6_8,Mn_8    |
//|*******************************************************************************|
//| Old File Name : SmicDR3T_cal65_log_p1mtx_sail.drc                             |
//|   1.2     21-Dec-2006     Lucy Li      Add RDL rules                          |
//|                                                                               |
//|   1.1     17-Nov-2006     Lucy Li      DR update to 3T, update TG&DG definition|
//|                                                                               |
//|*******************************************************************************|
//| Old File Name : SmicDR2T_cal65_log_p1mtx_sail.drc                             |
//|                                                                               |
//|   1.2     13-Apr-2006     Shirleyc     Modify runset based on TD suggestion   |
//|   1.1     01-Dec-2005     Jenny Jiang  DR update to 2T.Text and description   |
//|                                        change for all sections.               |
//|                                                                               |
//|*******************************************************************************|
//| Old File Name :  SmicDR1T_cal65_log_p1mtx_sail.drc                            |
//|                                                                               |
//|   1.4     01-Apr-2005     Drifty Yang   Modify VT1_4_5_8 for different metals |
//|   1.3     18-Jan-2005     Rimbo Yan     modified CT.13                        |
//|   1.2     11-Jan-2005     Rimbo Yan     modified AA.2a ,AA.2b                 |
//|   1.1     05-Jan-2005     Rimbo Yan     DR update to 1T; add metals number    |
//|                                         select ; add IO1 ,IO2  select         |
//|                                                                               |
//|*******************************************************************************|
//|   1.1     06-Sep-2004     Rimbo Yan              Initial Version              |
//|                                                                               |
//|===============================================================================|




//*************************************
//     DIRECTIVE SECTION
//*************************************

LAYOUT PRIMARY "*"
LAYOUT PATH "*.gds"
LAYOUT SYSTEM GDSII
DRC RESULTS DATABASE "drc_CAL.OUT" ASCII
DRC SUMMARY REPORT "drc_CAL.SUM" HIER

PRECISION       1000
RESOLUTION      1

FLAG ACUTE YES
FLAG NONSIMPLE YES
FLAG SKEW YES
FLAG OFFGRID YES

DGR_3 {
@ Only shapes of geometry that are orthogonal or 45-degree(0.1d tolerance) angle are allowed, excluding Inductor region.
 X = DFM COPY (DRAWN SKEW) EDGE
(X NOT COIN EDGE (ANGLE X >= 44.9 <= 45.1)) NOT INSIDE EDGE INDMY
} 

skew_edge_check {
@ Only 0 degree (X), 90 degree (Y), and 45+/-0.1 degree (diagonal) is allowed in design layout.
  X = DRAWN SKEW 
  Y = DFM COPY X EDGE
  NOT ANGLE Y >= 44.9 <= 45.1
}
// does not check layers that do not appear in other rule
// checks used in the run

DRC EXCLUDE FALSE NOTCH YES


//************************************
//     INPUT LAYER STATEMENTS
//************************************

LAYER   MAP	10	DATATYPE  0 310
LAYER   AAi     310 

LAYER   MAP     10	DATATYPE  1 300
LAYER   AADUMi  300     //      Dummy AA layer

LAYER   MAP     14      DATATYPE 0 1101
LAYER   NWi     1101      //      N-Well / N-Tub

LAYER   MAP     16      DATATYPE 0 1102
LAYER   PCi     1102      //      SRAM PMOS

LAYER   MAP     21      DATATYPE 0 1103
LAYER   NCi     1103      //      SRAM Nmos

LAYER   MAP     218      DATATYPE 0 1104
LAYER   LVPi    1104     //      Core 1.0V low Vt PMOS

LAYER   MAP     219      DATATYPE 0 1105
LAYER   LVNi    1105     //      Core 1.0V low Vt NMOS

LAYER   MAP     47      DATATYPE 0 1106
LAYER   VTNHi   1106      //      Core 1.0V high Vt NMOS

LAYER   MAP     46      DATATYPE 0 1107
LAYER   VTPHi   1107      //      Core 1.0V high Vt PMOS

LAYER   MAP     19      DATATYPE 0 1108
LAYER   DNWi    1108      //      Deep Nwell

LAYER   MAP     29      DATATYPE 0 1109
LAYER   DGi     1109      //      Dual Gate

LAYER   MAP     30 DATATYPE 0 410
LAYER   GTi     410     //      Poly Gate, Poly-1, ONO Gate

LAYER   MAP     30 DATATYPE 1 400
LAYER   GTDUMi  400     //       Dummy GT layer

LAYER   MAP     34      DATATYPE 0 1110
LAYER	HRi	1110	//	Poly Resistor Implant/POLY N+ doping/N+ P1 Pre-doping

LAYER   MAP     35      DATATYPE 0 1111
LAYER   NLLi    1111      //      NMOS LDD Implant for 1.0V Device 

LAYER   MAP     36      DATATYPE 0 1112
LAYER   NLHi    1112      //      NMOS LDD Implant for 1.8/2.5V Device

LAYER   MAP     37      DATATYPE 0 1113 
LAYER   PLHi    1113      //      PMOS LDD Implant for 1.8/2.5V Device

LAYER   MAP     38      DATATYPE 0 1114
LAYER   PLLi    1114      //      PMOS LDD Implant for 1.0V Device

LAYER   MAP     39      DATATYPE 0 1115 
LAYER	HRPi	1115	//	High Resistance Poly Imp

LAYER   MAP     40      DATATYPE 0 1116
LAYER   SNi     1116      //      N+ S/D Implant

LAYER   MAP     43      DATATYPE 0 1117
LAYER   SPi     1117      //      P+ S/D Implant

LAYER   MAP     44      DATATYPE 0 1118
LAYER   MVPi    1118      //      Low Vt Pmos

LAYER   MAP     45      DATATYPE 0 1119
LAYER   MVNi    1119      //      Low Vt Nmos

LAYER   MAP     48      DATATYPE 0 1120
LAYER   SABi    1120      //      Resist Protect Oxide / Salicide block

LAYER   MAP     50      DATATYPE 0 1121
LAYER   CTi     1121      //      Contact Hole

LAYER   MAP     61 DATATYPE 0 610  
LAYER   M10     610     //      Metal-1

LAYER   MAP     61 DATATYPE 1 611  
LAYER   M1DUMi  611     //      Dummy Metal-1

LAYER   MAP     62 DATATYPE 0 620
LAYER   M20     620     //      Metal-2

LAYER   MAP     62 DATATYPE 1 621
LAYER   M2DUMi  621     //      Dummy Metal-2

LAYER   MAP     63 DATATYPE 0 630
LAYER   M30     630     //      Metal-3

LAYER   MAP     63 DATATYPE 1 631
LAYER   M3DUMi  631     //      Dummy Metal-3

LAYER   MAP     64 DATATYPE 0 640
LAYER   M40     640     //      Metal-4

LAYER   MAP	64 DATATYPE 1 641
LAYER   M4DUMi  641     //      Dummy Metal-4

LAYER   MAP     65 DATATYPE 0 650
LAYER   M50     650     //      Metal-5

LAYER   MAP     65 DATATYPE 1 651
LAYER   M5DUMi  651     //      Dummy Metal-5

LAYER   MAP     66 DATATYPE 0 660
LAYER   M60     660     //      Metal-6

LAYER   MAP     66 DATATYPE 1 661
LAYER   M6DUMi  661     //      Dummy Metal-6

LAYER   MAP     120 DATATYPE 0 1200
LAYER	TM10	1200	//	Top Metal 1

LAYER   MAP     120 DATATYPE 1 1201
LAYER   TM1DUMi 1201    //      Dummy Top Metal 1

LAYER   MAP     122 DATATYPE 0 1220
LAYER	TM20	1220	//	Top Metal 2

LAYER   MAP     122 DATATYPE 1 1221
LAYER   TM2DUMi 1221    //      Dummy Top Metal 2

LAYER   MAP     70      DATATYPE 0 1122
LAYER   V1i     1122      //      Via-1 Hole

LAYER   MAP     71      DATATYPE 0 1123
LAYER   V2i     1123      //      Via-2 Hole

LAYER   MAP     72      DATATYPE 0 1124
LAYER   V3i     1124      //      Via-3 Hole

LAYER   MAP     73      DATATYPE 0 1125
LAYER   V4i     1125      //      Via-4 Hole

LAYER   MAP     74      DATATYPE 0 1126
LAYER   V5i     1126      //      Via-5 Hole

LAYER   MAP     121      DATATYPE 0 1127
LAYER	TV1i	1127	//	Top Via 1

LAYER   MAP     123      DATATYPE 0 1128
LAYER	TV2i	1128	//	Top Via 2

LAYER   MAP     80      DATATYPE 0 1129
LAYER   PAi     1129      //      Passivation / Pad

LAYER   MAP     81 DATATYPE 0 810
LAYER   FUSEi   810      //      Fuse Window

LAYER   MAP     81 DATATYPE 1 811
LAYER   GTFUSE  811     //      Poly E-Fuse block layer to identify E-Fuse function area

LAYER   MAP     81 DATATYPE 2 812
LAYER   EFUSE   812     //

LAYER   MAP     81 DATATYPE 152 813
LAYER   FUSEMK1   813     //

LAYER   MAP     82      DATATYPE 0 1130
LAYER   PI      1130      //      Polymide passivation layer

LAYER   MAP     85      DATATYPE 0 1131
LAYER   PSUBi   1131      //      Native Mos area

LAYER   MAP     94      DATATYPE 0 1132
LAYER	VARJUN	1132	//	Block Layer to cover all Junction type varactor

LAYER   MAP     95      DATATYPE 0 1133
LAYER   RESNW   1133      //      Dummy Pattern for NWELL Resistor

LAYER   MAP     96      DATATYPE 0 1134
LAYER   RESP1   1134      //      Dummy Pattern for Poly-1 Resistor

LAYER   MAP     97      DATATYPE 0 1135
LAYER   RESAA   1135      //      Dummy Pattern for AA Resistor

LAYER   MAP     90      DATATYPE 0 1136
LAYER   DUMBM   1136      //      Define area to prevent METAL Dummy operation

LAYER   MAP     91      DATATYPE 0 1137 
LAYER   DUMBA   1137      //      Define area to prevent AA Dummy operation

LAYER   MAP     92      DATATYPE 0 1138
LAYER   DUMBP   1138      //      Define area to prevent Poly Dummy operation

LAYER	MAP	93 DATATYPE 0 930
LAYER   VARMOS  930	//	Block Layer to cover all MOS-type varactor

LAYER   MAP     104      DATATYPE 0 1139
LAYER	PDRFi	1139	//	HV PMOS DRIFT implant ( for LDMOS)/P+ P1 Pre-doping

LAYER   MAP     105      DATATYPE 0 1140
LAYER	PWHi	1140	//	P Well for 1.8V device

LAYER   MAP     106      DATATYPE 0 1141
LAYER   NWHi    1141     //      N Well for 1.8V device

LAYER   MAP     109      DATATYPE 0 1142
LAYER	PWHTi	1142	//	P Well for 2.5/3.3V device

LAYER   MAP     110      DATATYPE 0 1143
LAYER   NWHTi   1143     //      N Well for 2.5/3.3V device

LAYER   MAP     114      DATATYPE 0 1144
LAYER   NLHTi   1144     //      NMOS LDD Implant for 2.5/3.3V Device

LAYER   MAP     115      DATATYPE 0 1145
LAYER   PLHTi   1145     //      PMOS LDD Implant for 2.5/3.3V Device

LAYER   MAP     116      DATATYPE 0 1146
LAYER   LVi     1146     //      Block layer for core 1.0V low Vt

LAYER   MAP     125 DATATYPE 0 500
LAYER	TGi	500	//	Tripple Gate

LAYER   MAP     127      DATATYPE 0 1147
LAYER	BORDERi	1147	//	Border layer for chip level design

LAYER   MAP     134      DATATYPE 0 1150
LAYER	DMPNP	1150	//	Parasitic PNP and NPN

LAYER   MAP     137      DATATYPE 0 1151
LAYER   CAPBP   1151     //      Capacitor Dummy

LAYER   MAP     210      DATATYPE 0 1152
LAYER	HRPDMY	1152	//	HRP dummy

LAYER   MAP     138      DATATYPE 0 1153
LAYER	DSTR	1153	//	Diode Marker

LAYER   MAP     165      DATATYPE 0 1154
LAYER   RDLVIAi 1154     //      Via under RDL connecting TM and RDL

LAYER   MAP     166      DATATYPE 0 1155
LAYER   RDLi    1155     //      RDL

LAYER   MAP     167      DATATYPE 0 1156
LAYER   RDLPA2i 1156     //      Passivation 2 for RDL

LAYER   MAP     171      DATATYPE 0 1157
LAYER	M1R	1157	//	Metal-1 Resistor

LAYER   MAP     172      DATATYPE 0 1158
LAYER	M2R	1158	//	Metal-2 Resistor

LAYER   MAP     173      DATATYPE 0 1159
LAYER	M3R	1159	//	Metal-3 Resistor

LAYER   MAP     174      DATATYPE 0 1160
LAYER	M4R	1160	//	Metal-4 Resistor

LAYER   MAP     175      DATATYPE 0 1161
LAYER	M5R	1161	//	Metal-5 Resistor

LAYER   MAP     176      DATATYPE 0 1162
LAYER	M6R	1162	//	Metal-6 Resistor

LAYER   MAP     201      DATATYPE 0 1163
LAYER	TM1R	1163	//	Top metal 1 Resistor

LAYER   MAP     202      DATATYPE 0 1164
LAYER	TM2R	1164	//	Top metal 2 Resistor

LAYER   MAP     194	 DATATYPE 150 1165
LAYER   STM1R	1165	//	STM1 resistor layer

LAYER   MAP     194	 DATATYPE 151 1166
LAYER   STM2R   1166    //      STM2 resistor layer

LAYER   MAP     83       DATATYPE 1  1167
LAYER   ALPAR   1167     //     ALPA resistor layer

LAYER   MAP     26      DATATYPE 0 2168
LAYER   LOGO    2168      //      L Mark AREA

LAYER   MAP     125 	DATATYPE 4  515
LAYER   OVERPL  515     //      To block over drive poly

//--------------------------------------------------------------------------------
LAYER   MAP 189 DATATYPE 0 1890
LAYER	MARKGi	1890	//	Guard ring or seal ring area mark layer for DRC
MARKG = MARKGi OR MARKS
//------------------------------------------------------------------------------------

LAYER 	MAP 	189  	DATATYPE  151  1895
LAYER 	MARKS   1895

LAYER   MAP     190      DATATYPE 0 2169
LAYER   MARKF   2169     //      FUSE area mark

LAYER   MAP	60  DATATYPE 0 600
LAYER   INST    600     //      SRAM block layer

LAYER   MAP	60  DATATYPE 1 601
LAYER   STSRAM  601     //	525SPSRAM

LAYER   MAP	60  DATATYPE 2 602
LAYER   DNSRAM  602     //	620SPSRAM

LAYER	MAP	60  DATATYPE 4 604
LAYER   DPSRAM  604	//	974DPSRAM

LAYER   MAP	60  DATATYPE 9 609
LAYER   RFSRAM  609	//	1158DPSRAM

LAYER   MAP     125 DATATYPE 5  512
LAYER   UNDEPL  512	//	Marking block layer for under drive poly logic operation

LAYER   MAP     216 DATATYPE 150 516
LAYER   LDBK    516     //      Identify LDMOS function area and do related

LAYER	MAP	211 DATATYPE 1 2111
LAYER   MAP     211 TEXTTYPE 1 2111
LAYER	MOMDMY	2111	//	MOM Dummy layer

LAYER   MAP     215 DATATYPE 0 2150
LAYER   STIDMY  2150

LAYER   MAP     212      DATATYPE 0 1170
LAYER	INDMY	1170	//	Dummy layer for MTT in inductor applications

LAYER   MAP     239 DATATYPE 1 2391
LAYER   EXDFM   2391    //  unDFM check area

LAYER   MAP     151     DATATYPE == 1   781
LAYER   M1DUB   781     // Block layer for M1 dummy operations

LAYER   MAP     152     DATATYPE == 1   782
LAYER   M2DUB   782     // Block layer for M2 dummy operations

LAYER   MAP     153     DATATYPE == 1   783
LAYER   M3DUB   783     // Block layer for M3 dummy operations

LAYER   MAP     154     DATATYPE == 1   784
LAYER   M4DUB   784     // Block layer for M4 dummy operations

LAYER   MAP     155     DATATYPE == 1   785
LAYER   M5DUB   785     // Block layer for M5 dummy operations

LAYER   MAP     156     DATATYPE == 1   786
LAYER   M6DUB   786     // Block layer for M6 dummy operations

LAYER   MAP     193     DATATYPE == 1   789
LAYER   TM1DUB  789     // Block layer for TM1 dummy operations

LAYER   MAP     194     DATATYPE == 1   790
LAYER   TM2DUB  790     // Block layer for TM2 dummy operations

LAYER   MAP     180      DATATYPE 0 1168
LAYER   NODMF   1168      // Block layer for dummy operation on GT/AA/metal

LAYER	MAP	191 DATATYPE 3  1913
LAYER	DTDMY	1913	// Marking layer for different potential AA

//new layer definition
//---------------------------------------------------------------------------------------
LAYER   MAP     57      DATATYPE 0 1169
LAYER   NPR1    1169

LAYER   MAP     41      DATATYPE 0 2170
LAYER   ESD1    2170

LAYER 	MAP 	67  	DATATYPE  1    671 
LAYER 	M7DUMi  671
 
LAYER 	MAP 	68  	DATATYPE  1    681 
LAYER 	M8DUMi  681
 
LAYER 	MAP 	228  	DATATYPE  1   2281 
LAYER 	STM1DMi 2281

LAYER 	MAP 	229  	DATATYPE  1   2291 
LAYER 	STM2DMi 2291 


LAYER 	MAP 	67   	DATATYPE  0    670 
LAYER 	M70   	670
 
LAYER 	MAP 	68   	DATATYPE  0    680 
LAYER 	M80   	680

LAYER 	MAP 	228  	DATATYPE  0   2280 
LAYER 	STM10 	2280

LAYER 	MAP 	229  	DATATYPE  0   2290 
LAYER 	STM20 	2290 

LAYER   MAP     75      DATATYPE 0 1171
LAYER   V6i     1171

LAYER   MAP     76      DATATYPE 0 1172
LAYER   V7i     1172

LAYER   MAP     157     DATATYPE 1 1173
LAYER   M7DUB   1173

LAYER   MAP     158     DATATYPE 1 1174
LAYER   M8DUB   1174

LAYER 	MAP 	180 	DATATYPE 150   1175
LAYER 	NOSHR 	1175

LAYER	MAP	177	DATATYPE 0 1176
LAYER	M7R     1176

LAYER	MAP	178	DATATYPE 0 1177
LAYER	M8R     1177

LAYER   MAP	60      DATATYPE 3 1180
LAYER   UDSRAM  1180

LAYER   MAP	60      DATATYPE 5 1181
LAYER   LRSRAM  1181

LAYER   MAP	60      DATATYPE 12 1182
LAYER   2PSRAM  1182

LAYER   MAP     60 	DATATYPE 11  1189
LAYER 	D2SRAM	1189

LAYER   MAP     133     DATATYPE 1  1183
LAYER   ESD5V   1183

LAYER   MAP     133     DATATYPE 0  1299
LAYER   ESDIO1  1299

LAYER   MAP     133     DATATYPE 3  1290
LAYER   ESDIO2  1290

LAYER   MAP     194     DATATYPE 5 1185
LAYER   STM1DB  1185

LAYER   MAP     194     DATATYPE 4 1186
LAYER   STM2DB  1186

LAYER   MAP     243     DATATYPE 0 1187
LAYER   STV1i   1187

LAYER   MAP     244     DATATYPE 0 1188
LAYER   STV2i   1188

LAYER   MAP     61   	DATATYPE 2 1612
LAYER   M1SLOTi 1612

LAYER   MAP	62	DATATYPE 2 1622
LAYER   M2SLOTi 1622

LAYER 	MAP 	63	DATATYPE 2 1632
LAYER   M3SLOTi 1632

LAYER 	MAP	64	DATATYPE 2 1642
LAYER   M4SLOTi 1642

LAYER 	MAP 	65	DATATYPE 2 1652
LAYER   M5SLOTi 1652

LAYER	MAP	66	DATATYPE 2 1662
LAYER   M6SLOTi 1662

LAYER	MAP	67	DATATYPE 2 1672
LAYER   M7SLOTi 1672

LAYER   MAP     68	DATATYPE 2 1682
LAYER	M8SLOTi 1682

LAYER	MAP	120	DATATYPE 2 1782
LAYER   TM1SLOTi 1782

LAYER   MAP     122  	DATATYPE 2 1783
LAYER	TM2SLOTi 1783

LAYER	MAP     228	DATATYPE 2 1882
LAYER   STM1SLOTi 1882

LAYER   MAP 	229	DATATYPE 2 1883
LAYER   STM2SLOTi 1883

LAYER   MAP     83	DATATYPE 2 1886
LAYER   ALPATXT 1886

LAYER	MAP	131      DATATYPE 177 1887
LAYER   LUWMK1    1887

LAYER   MAP     89      DATATYPE 156 1884
LAYER   DUPMK1  1884

LAYER   MAP     131     DATATYPE 175  959 
LAYER   VDDMK1  959 

LAYER   MAP     131     DATATYPE 176  960
LAYER   VSSMK1 960

LAYER   MAP     211     DATATYPE 11  1511
LAYER   MOMMK1   1511

LAYER   MAP     211     DATATYPE 12  1512
LAYER   MOMMK2   1512

LAYER   MAP     211     DATATYPE 13  1513
LAYER   MOMMK3   1513

LAYER   MAP     211     DATATYPE 14  1514
LAYER   MOMMK4   1514

LAYER   MAP     211     DATATYPE 15  1515
LAYER   MOMMK5   1515

LAYER   MAP     211     DATATYPE 16  1516
LAYER   MOMMK6   1516

LAYER   MAP     211     DATATYPE 17  1517
LAYER   MOMMK7   1517

LAYER   MAP     211     DATATYPE 18  1518
LAYER   MOMMK8   1518

LAYER   MAP     239     DATATYPE 0 1190
LAYER   EXDRC   1190

LAYER   MAP     999     DATATYPE 1117 4327
LAYER   EMPTY5  4327

LAYER   MAP     999     DATATYPE 1118 4328
LAYER   EMPTY4  4328

LAYER   MAP     159     DATATYPE 151 4329
LAYER   UHVTi  4329


LAYER  M1_TEXT   1411 1412
LAYER  MAP  61  TEXTTYPE==0   1411
LAYER  MAP 141  TEXTTYPE==0   1412

LAYER  M2_TEXT   1421 1422
LAYER  MAP  62  TEXTTYPE==0   1421
LAYER  MAP 142  TEXTTYPE==0   1422

LAYER  M3_TEXT   1431 1432
LAYER  MAP  63  TEXTTYPE==0   1431
LAYER  MAP 143  TEXTTYPE==0   1432

LAYER  M4_TEXT   1441 1442
LAYER  MAP  64  TEXTTYPE==0   1441
LAYER  MAP 144  TEXTTYPE==0   1442

LAYER  M5_TEXT   1451 1452
LAYER  MAP  65  TEXTTYPE==0   1451
LAYER  MAP 145  TEXTTYPE==0   1452

LAYER  M6_TEXT   1461 1462
LAYER  MAP  66  TEXTTYPE==0   1461
LAYER  MAP 146  TEXTTYPE==0   1462

LAYER  M7_TEXT   1471 1472
LAYER  MAP  67  TEXTTYPE==0   1471
LAYER  MAP 147  TEXTTYPE==0   1472

LAYER  M8_TEXT   1481 1482
LAYER  MAP  68  TEXTTYPE==0   1481
LAYER  MAP 148  TEXTTYPE==0   1482

LAYER  TM1_TEXT  1491 1492
LAYER  MAP 120  TEXTTYPE==0   1491
LAYER  MAP 120  TEXTTYPE==3   1492

LAYER  TM2_TEXT  1501 1502
LAYER  MAP 122  TEXTTYPE==0   1501
LAYER  MAP 122  TEXTTYPE==3   1502

LAYER  STM1_TEXT 1521 1522
LAYER  MAP 228  TEXTTYPE==0   1521
LAYER  MAP 228  TEXTTYPE==3   1522

LAYER  STM2_TEXT 1531 1532
LAYER  MAP 229  TEXTTYPE==0   1531
LAYER  MAP 229  TEXTTYPE==3   1532

LAYER  PA_TEXT   1541 1542
LAYER  MAP 80   TEXTTYPE==0   1541    //pa
LAYER  MAP 80   TEXTTYPE==250 1542    //patxt

BORDER = BORDERi OR (HOLES BORDERi)
PWi = DRC:1 NOT (NWi OR PSUBi)
PW = COPY PWi

AA      = COPY AAi
//AA_dfm  = AA NOT EXDFM
AA_dfm  = COPY AAi
NW      = COPY NWi
//NW_dfm  = NWi NOT EXDFM
NW_dfm  = COPY NWi
DNW     = COPY DNWi
VTNH    = COPY VTNHi
VTPH    = COPY VTPHi
LVP     = COPY LVPi
LVN     = COPY LVNi
DG      = COPY DGi
GT      = COPY GTi
//GT_dfm  = GT NOT EXDFM
GT_dfm  = COPY GTi
NLL     = COPY NLLi
NLH     = COPY NLHi
PLH     = COPY PLHi
PLL     = COPY PLLi
HRP	= COPY HRPi
SN      = COPY SNi
SP      = COPY SPi
SAB     = COPY SABi
CT      = COPY CTi
CT_dfm  = CT NOT EXDFM
PSUB    = COPY PSUBi
NLHT    = COPY NLHTi
PLHT    = COPY PLHTi
TG	= COPY TGi
PWH	= COPY PWHi
NWH     = COPY NWHi
PWHT	= COPY PWHTi
NWHT    = COPY NWHTi
LV      = COPY LVi
MD	= COPY MDi
RDLVIA	= COPY RDLVIAi
RDL	= COPY RDLi
RDLPA2	= COPY RDLPA2i
HR	= COPY HRi
PDRF	= COPY PDRFi
FUSE	= COPY FUSEi
PA	= COPY PAi
ALPA    = COPY ALPAi

//FOR DRC CHECK
M1      = M10 NOT M1SLOTi
M1_dfm  = M1 NOT EXDFM
M2      = M20 NOT M2SLOTi
M2_dfm  = M2 NOT EXDFM
M3	= M30 NOT M3SLOTi
M4	= M40 NOT M4SLOTi
M5	= M50 NOT M5SLOTi
M6	= M60 NOT M6SLOTi
M7	= M70 NOT M7SLOTi
M8	= M80 NOT M8SLOTi
TM1	= TM10 NOT TM1SLOTi
TM2	= TM20 NOT TM2SLOTi
STM1    = STM10 NOT STM1SLOTi
STM2    = STM20 NOT STM2SLOTi

M1DUM   = COPY M1DUMi
M2DUM   = COPY M2DUMi
M3DUM   = COPY M3DUMi
M4DUM   = COPY M4DUMi
M5DUM   = COPY M5DUMi
M6DUM   = COPY M6DUMi
M7DUM   = COPY M7DUMi
M8DUM   = COPY M8DUMi
TM1DUM  = COPY TM1DUMi
TM2DUM  = COPY TM2DUMi
STM1DM  = COPY STM1DMi
STM2DM  = COPY STM2DMi
AADUM	= COPY AADUMi
GTDUM	= COPY GTDUMi

M1SLOT   = COPY M1SLOTi
M2SLOT   = COPY M2SLOTi
M3SLOT   = COPY M3SLOTi
M4SLOT   = COPY M4SLOTi
M5SLOT   = COPY M5SLOTi
M6SLOT   = COPY M6SLOTi 
M7SLOT   = COPY M7SLOTi
M8SLOT   = COPY M8SLOTi
TM1SLOT  = COPY TM1SLOTi
TM2SLOT  = COPY TM2SLOTi
STM1SLOT  = COPY STM1SLOTi
STM2SLOT  = COPY STM2SLOTi
UHVT = COPY UHVTi


TV1     = COPY TV1i
TV2     = COPY TV2i
STV1    = COPY STV1i
STV2    = COPY STV2i

//FOR DRC CHECK
M1ALL = (M1 NOT M1SLOT) OR M1DUM
M2ALL = (M2 NOT M2SLOT) OR M2DUM
M3ALL = (M3 NOT M3SLOT) OR M3DUM
M4ALL = (M4 NOT M4SLOT) OR M4DUM
M5ALL = (M5 NOT M5SLOT) OR M5DUM
M6ALL = (M6 NOT M6SLOT) OR M6DUM
M7ALL = (M7 NOT M7SLOT) OR M7DUM
M8ALL = (M8 NOT M8SLOT) OR M8DUM
TM1ALL = (TM1 NOT TM1SLOT) OR TM1DUM
TM2ALL = (TM2 NOT TM2SLOT) OR TM2DUM
STM1ALL = (STM1 NOT STM1SLOT) OR STM1DM
STM2ALL = (STM2 NOT STM2SLOT) OR STM2DM

//FOR DENSITY CHECK
M1ALLi = (M10 NOT M1SLOTi) OR M1DUMi
M2ALLi = (M20 NOT M2SLOTi)OR M2DUMi
M3ALLi = (M30 NOT M3SLOTi)OR M3DUMi
M4ALLi = (M40 NOT M4SLOTi)OR M4DUMi
M5ALLi = (M50 NOT M5SLOTi)OR M5DUMi
M6ALLi = (M60 NOT M6SLOTi)OR M6DUMi
M7ALLi = (M70 NOT M7SLOTi)OR M7DUMi
M8ALLi = (M80 NOT M8SLOTi)OR M8DUMi
TM1ALLi = (TM10 NOT TM1SLOTi)OR TM1DUMi
TM2ALLi = (TM20 NOT TM2SLOTi)OR TM2DUMi
STM1ALLi = (STM10 NOT STM1SLOTi)OR STM1DMi
STM2ALLi = (STM20 NOT STM2SLOTi)OR STM2DMi

//FOR CONNECTIVITY
MDi = PAi OR RDLPA2i
ALPA_PAi = SIZE PAi BY PA_su
ALPAi	= ALPA_PAi OR RDLi
M1i   = M10 NOT M1SLOTi
M2i   = M20 NOT M2SLOTi
M3i   = M30 NOT M3SLOTi
M4i   = M40 NOT M4SLOTi
M5i   = M50 NOT M5SLOTi
M6i   = M60 NOT M6SLOTi
M7i   = M70 NOT M7SLOTi
M8i   = M80 NOT M8SLOTi
TM1i  = TM10 NOT TM1SLOTi
TM2i  = TM20 NOT TM2SLOTi
STM1i = STM10 NOT STM1SLOTi
STM2i = STM20 NOT STM2SLOTi

M1M2 = M1 AND M2
SV1_metal = M1M2 INTERACT V1 == 1
M2M3 = M2 AND M3
SV2_metal = M2M3 INTERACT V2 == 1
M3M4 = M3 AND M4
SV3_metal = M3M4 INTERACT V3 == 1
M4M5 = M4 AND M5
SV4_metal = M4M5 INTERACT V4 == 1
M5M6 = M5 AND M6
SV5_metal = M5M6 INTERACT V5 == 1
M6M7 = M6 AND M7
SV6_metal = M6M7 INTERACT V6 == 1
M7M8 = M7 AND M8
SV7_metal = M7M8 INTERACT V7 == 1


//------------------------------------------------------------------------------------------

V1_slot = ((ENCLOSE RECTANGLE V1i 0.1 0.3) AND MARKG) INTERACT (WITH WIDTH V1i == 0.1)
V2_slot = ((ENCLOSE RECTANGLE V2i 0.1 0.3) AND MARKG) INTERACT (WITH WIDTH V2i == 0.1)
V3_slot = ((ENCLOSE RECTANGLE V3i 0.1 0.3) AND MARKG) INTERACT (WITH WIDTH V3i == 0.1)
V4_slot = ((ENCLOSE RECTANGLE V4i 0.1 0.3) AND MARKG) INTERACT (WITH WIDTH V4i == 0.1)
V5_slot = ((ENCLOSE RECTANGLE V5i 0.1 0.3) AND MARKG) INTERACT (WITH WIDTH V5i == 0.1)
V6_slot = ((ENCLOSE RECTANGLE V6i 0.1 0.3) AND MARKG) INTERACT (WITH WIDTH V6i == 0.1)
V7_slot = ((ENCLOSE RECTANGLE V7i 0.1 0.3) AND MARKG) INTERACT (WITH WIDTH V7i == 0.1)

V1_slot_SG = (((ENCLOSE RECTANGLE V1i 0.09 0.27) AND MARKG) INTERACT (WITH WIDTH V1i == 0.09)) OR V1_slot
V2_slot_SG = (((ENCLOSE RECTANGLE V2i 0.09 0.27) AND MARKG) INTERACT (WITH WIDTH V2i == 0.09)) OR V2_slot
V3_slot_SG = (((ENCLOSE RECTANGLE V3i 0.09 0.27) AND MARKG) INTERACT (WITH WIDTH V3i == 0.09)) OR V3_slot
V4_slot_SG = (((ENCLOSE RECTANGLE V4i 0.09 0.27) AND MARKG) INTERACT (WITH WIDTH V4i == 0.09)) OR V4_slot
V5_slot_SG = (((ENCLOSE RECTANGLE V5i 0.09 0.27) AND MARKG) INTERACT (WITH WIDTH V5i == 0.09)) OR V5_slot
V6_slot_SG = (((ENCLOSE RECTANGLE V6i 0.09 0.27) AND MARKG) INTERACT (WITH WIDTH V6i == 0.09)) OR V6_slot
V7_slot_SG = (((ENCLOSE RECTANGLE V7i 0.09 0.27) AND MARKG) INTERACT (WITH WIDTH V7i == 0.09)) OR V7_slot

}

if { [string equal $ALLOW_V01 YES] == 1 } {
SETLAYER V1ia = (RECTANGLE V1i == 0.1 BY == 0.1) OR V1_slot
SETLAYER V2ia = (RECTANGLE V2i == 0.1 BY == 0.1) OR V2_slot
SETLAYER V3ia = (RECTANGLE V3i == 0.1 BY == 0.1) OR V3_slot
SETLAYER V4ia = (RECTANGLE V4i == 0.1 BY == 0.1) OR V4_slot
SETLAYER V5ia = (RECTANGLE V5i == 0.1 BY == 0.1) OR V5_slot
SETLAYER V6ia = (RECTANGLE V6i == 0.1 BY == 0.1) OR V6_slot
SETLAYER V7ia = (RECTANGLE V7i == 0.1 BY == 0.1) OR V7_slot

SETLAYER V1_sd = SIZE V1ia BY -0.005
SETLAYER V2_sd = SIZE V2ia BY -0.005
SETLAYER V3_sd = SIZE V3ia BY -0.005
SETLAYER V4_sd = SIZE V4ia BY -0.005
SETLAYER V5_sd = SIZE V5ia BY -0.005
SETLAYER V6_sd = SIZE V6ia BY -0.005
SETLAYER V7_sd = SIZE V7ia BY -0.005

SETLAYER V1r = V1i NOT V1ia
SETLAYER V2r = V2i NOT V2ia
SETLAYER V3r = V3i NOT V3ia
SETLAYER V4r = V4i NOT V4ia
SETLAYER V5r = V5i NOT V5ia
SETLAYER V6r = V6i NOT V6ia
SETLAYER V7r = V7i NOT V7ia

SETLAYER V1O	= V1r OR V1_sd
SETLAYER V2O	= V2r OR V2_sd
SETLAYER V1      = COPY V1O
SETLAYER V1_dfm  = V1 NOT EXDFM
SETLAYER V2      = COPY V2O
SETLAYER V2_dfm  = V2 NOT EXDFM
SETLAYER V3      = V3r OR V3_sd
SETLAYER V4      = V4r OR V4_sd
SETLAYER V5      = V5r OR V5_sd
SETLAYER V6      = V6r OR V6_sd
SETLAYER V7      = V7r OR V7_sd
}

if { [string equal $ALLOW_V01 NO] == 1 } {
SETLAYER V1	= COPY V1i
SETLAYER V1_dfm	= V1 NOT INSIDE EXDFM
SETLAYER V2	= COPY V2i
SETLAYER V2_dfm	= V2 NOT INSIDE EXDFM
SETLAYER V3	= COPY V3i
SETLAYER V4	= COPY V4i
SETLAYER V5	= COPY V5i
SETLAYER V6	= COPY V6i
SETLAYER V7	= COPY V7i
}




set MT_CHOICE 0
set CHECK_M1 1
set CHECK_V1 1
set CHECK_M2 1
set CHECK_V2 1
set CHECK_M3 1

set CHECK_V3 0
set CHECK_M4 0
set CHECK_V4 0
set CHECK_M5 0
set CHECK_V5 0
set CHECK_M6 0
set CHECK_V6 0
set CHECK_M7 0
set CHECK_V7 0
set CHECK_M8 0
set CHECK_TV1 0
set CHECK_TM1 0
set CHECK_TV2 0
set CHECK_TM2 0
set CHECK_STV1 0
set CHECK_STM1 0
set CHECK_STV2 0
set CHECK_STM2 0

if { $total_metal == 10 } {
           set CHECK_V3 1
           set CHECK_M4 1
           set CHECK_V4 1
           set CHECK_M5 1
           set CHECK_V5 1
           set CHECK_M6 1
           set CHECK_V6 1
           set CHECK_M7 1
           set CHECK_V7 1
           set CHECK_M8 1
  if { $top_metal == 2 } {

    if { $STM1_STV1 == 0 } {
      if { $STM2_STV2 == 0 } {
           set CHECK_TV1 1
           set CHECK_TM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
        }
     } elseif { $STM1_STV1 == 1 } {
             if { $STM2_STV2 == 0 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
  } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_STV2 1
           set CHECK_STM2 1
      }
    }
  }

} elseif { $total_metal == 9 } {
           set CHECK_V3 1
           set CHECK_M4 1
           set CHECK_V4 1
           set CHECK_M5 1
           set CHECK_V5 1
           set CHECK_M6 1
           set CHECK_V6 1
           set CHECK_M7 1
  if { $top_metal == 2 } {

    if { $STM1_STV1 == 0 } {
      if { $STM2_STV2 == 0 } {
           set CHECK_TV1 1
           set CHECK_TM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
        }
     } elseif { $STM1_STV1 == 1 } {
             if { $STM2_STV2 == 0 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
  } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_STV2 1
           set CHECK_STM2 1
      }
    }
  } elseif { $top_metal == 1 } {

           set CHECK_V7 1
           set CHECK_M8 1
    if { $STM2_STV2 == 0 } {
           set CHECK_TV2 1
           set CHECK_TM2 1
    } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV2 1
           set CHECK_STM2 1
    }
  }

} elseif { $total_metal == 8 } {
           set CHECK_V3 1
           set CHECK_M4 1
           set CHECK_V4 1
           set CHECK_M5 1
           set CHECK_V5 1
           set CHECK_M6 1
  if { $top_metal == 2 } {

    if { $STM1_STV1 == 0 } {
      if { $STM2_STV2 == 0 } {
           set CHECK_TV1 1
           set CHECK_TM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
        }
     } elseif { $STM1_STV1 == 1 } {
             if { $STM2_STV2 == 0 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
  } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_STV2 1
           set CHECK_STM2 1
      }
    }
  } elseif { $top_metal == 1 } {

           set CHECK_V6 1
           set CHECK_M7 1
    if { $STM2_STV2 == 0 } {
           set CHECK_TV2 1
           set CHECK_TM2 1
    } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV2 1
           set CHECK_STM2 1
    }
  }

} elseif { $total_metal == 7 } {
           set CHECK_V3 1
           set CHECK_M4 1
           set CHECK_V4 1
           set CHECK_M5 1
  if { $top_metal == 2 } {

    if { $STM1_STV1 == 0 } {
      if { $STM2_STV2 == 0 } {
           set CHECK_TV1 1
           set CHECK_TM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
        }
     } elseif { $STM1_STV1 == 1 } {
             if { $STM2_STV2 == 0 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
  } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_STV2 1
           set CHECK_STM2 1
      }
    }
  } elseif { $top_metal == 1 } {

           set CHECK_V5 1
           set CHECK_M6 1
    if { $STM2_STV2 == 0 } {
           set CHECK_TV2 1
           set CHECK_TM2 1
    } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV2 1
           set CHECK_STM2 1
    }
  }

} elseif { $total_metal == 6 } {
           set CHECK_V3 1
           set CHECK_M4 1
  if { $top_metal == 2 } {

    if { $STM1_STV1 == 0 } {
      if { $STM2_STV2 == 0 } {
           set CHECK_TV1 1
           set CHECK_TM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
        }
     } elseif { $STM1_STV1 == 1 } {
             if { $STM2_STV2 == 0 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
  } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_STV2 1
           set CHECK_STM2 1
      }
    }
  } elseif { $top_metal == 1 } {

           set CHECK_V4 1
           set CHECK_M5 1
    if { $STM2_STV2 == 0 } {
           set CHECK_TV2 1
           set CHECK_TM2 1
    } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV2 1
           set CHECK_STM2 1
    }
  }

} elseif { $total_metal == 5 } {
  if { $top_metal == 2 } {

    if { $STM1_STV1 == 0 } {
      if { $STM2_STV2 == 0 } {
           set CHECK_TV1 1
           set CHECK_TM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
        }
     } elseif { $STM1_STV1 == 1 } {
             if { $STM2_STV2 == 0 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_TV2 1
           set CHECK_TM2 1
  } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV1 1
           set CHECK_STM1 1
           set CHECK_STV2 1
           set CHECK_STM2 1
      }
    }
  } elseif { $top_metal == 1 } {

           set CHECK_V3 1
           set CHECK_M4 1
    if { $STM2_STV2 == 0 } {
           set CHECK_TV2 1
           set CHECK_TM2 1
    } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV2 1
           set CHECK_STM2 1
    }
  }

} elseif { $total_metal == 4 } {
    if { $top_metal == 1 } {

    if { $STM2_STV2 == 0 } {
           set CHECK_TV2 1
           set CHECK_TM2 1
    } elseif { $STM2_STV2 == 1 } {
           set CHECK_STV2 1
           set CHECK_STM2 1
    }
  }
} else {
  set MT_CHOICE 1
}




#define the list for all inner metals and vias,temporarily
#define the list for all inner metals and inner vias,respectively
set v_m_list " "
set v_m_list_for_connect " "
set v_j " "
set v_j_layer " "
set m_j " "
set m_j_layer " "
set m_j_dummy " "
set SRCK20_layer_tmp " "
set SRCK20_tmp " "

for { set j 1 } { $j <= [expr $total_metal -$top_metal] } { incr j } {
  if { [set CHECK_M$j] == 1 } { 
    lappend v_m_list M$j
    lappend v_m_list_for_connect M${j}i
    lappend m_j $j
    lappend m_j_layer M$j
    lappend m_j_dummy M${j}DUMi
    lappend SRCK20_layer_tmp M${j}S_RING
    lappend SRCK20_tmp !!(AREA(M${j}S_RING))
  }
  if { [set CHECK_M$j] == 0 } break
  if { $j < 8 } {
    if { [set CHECK_V$j] == 1 } {
    lappend v_m_list V$j
    lappend v_m_list_for_connect V${j}
    lappend v_j $j
    lappend v_j_layer V$j
    lappend SRCK20_layer_tmp V${j}S
    lappend SRCK20_tmp !!(AREA(V${j}S))
    }
  }
}
#define the list for all metals and vias
#define the list for top metals and top vias
set top_v_m_list " "
set top_v_m_list_all { TV1 TM1 STV1 STM1 STV2 STM2 TV2 TM2 }
foreach top_v_m_layer $top_v_m_list_all {
  set tmp CHECK_$top_v_m_layer
  set tmp_v [set $tmp]
  if { $tmp_v == 1 } {
    lappend v_m_list $top_v_m_layer
    lappend v_m_list_for_connect ${top_v_m_layer}i
    lappend top_v_m_list $top_v_m_layer
  }
}

#define the list for rule SRCK_20
lappend SRCK20_layer_tmp [lindex $top_v_m_list 0]S [lindex $top_v_m_list 1]S_RING
lappend SRCK20_tmp !!(AREA([lindex $top_v_m_list 0]S)) !!(AREA([lindex $top_v_m_list 1]S_RING))
if { [llength $top_v_m_list] == 4 } {
  lappend SRCK20_layer_tmp [lindex $top_v_m_list 2]S [lindex $top_v_m_list 3]S_RING
  lappend SRCK20_tmp !!(AREA([lindex $top_v_m_list 2]S)) !!(AREA([lindex $top_v_m_list 3]S_RING))
}
set SRCK20_layer " "
set SRCK20 " "
for { set i 0 } { $i < [llength $SRCK20_tmp] } { incr i } {
  lappend SRCK20_layer [lindex $SRCK20_layer_tmp end-$i]
  lappend SRCK20 [lindex $SRCK20_tmp end-$i]*
}


#define the lists for top metals and top vias,respectively
set t_v_j " "
set t_m_j " "
set t_v_list_all { TV1 STV1 STV2 TV2 }
set t_m_list_all { TM1 STM1 STM2 TM2 }

foreach t_v_list_layer $t_v_list_all {
  if { [set CHECK_$t_v_list_layer] == 1 } {
    lappend t_v_j $t_v_list_layer
  }
}
foreach t_m_list_layer $t_m_list_all {
  if { [set CHECK_$t_m_list_layer] == 1 } {
    lappend t_m_j $t_m_list_layer
  }
}


#define the lists for all metal layers and all via layers,respectively
set metal_all [concat $m_j_layer $t_m_j]
set via_all [concat $v_j_layer $t_v_j]


#define the list for STM1 and STM2,TM1 and TM2,respectively
#define the list for STM1DM and STM2DM,TM1DUM and TM2DUM,respectively
set t_m_j_STM " "
set t_m_j_STDM " "
set t_m_j_TM " "
foreach t_m_j_STM_layer { STM1 STM2 } {
  if { [set CHECK_$t_m_j_STM_layer] == 1 } {
    lappend t_m_j_STM $t_m_j_STM_layer
    lappend t_m_j_STDM ${t_m_j_STM_layer}DMi
  }
}
foreach t_m_j_TM_layer { TM1 TM2 } {
  if { [set CHECK_$t_m_j_TM_layer] == 1 } {
    lappend t_m_j_TM $t_m_j_TM_layer
    lappend t_m_j_TMDUM ${t_m_j_TM_layer}DUMi
  }
}


#define a list for all metal dummy layers
if { [lsearch $metal_all STM*] < 0 } {
  set metal_dummy_list [concat $m_j_dummy $t_m_j_TMDUM]
} elseif { [lsearch $metal_all TM*] < 0 } {
    set metal_dummy_list [concat $m_j_dummy $t_m_j_STDM]
} else {
    set metal_dummy_list [concat $m_j_dummy $t_m_j_STDM $t_m_j_TMDUM]
}



for { set i 0 } { $i < [expr [llength $v_m_list_for_connect] -2] } { incr i 2 } {
  CONNECT [lindex $v_m_list_for_connect $i] [lindex $v_m_list_for_connect [expr $i +2]] BY [lindex $v_m_list_for_connect [expr $i +1]]
}
if { [string equal $STM2_STV2 0] == 1 } {
CONNECT TM2i PAi
CONNECT TM2i RDLi BY RDLVIAi
}
if { [string equal $STM2_STV2 1] == 1 } {
CONNECT STM2i PAi
CONNECT STM2i RDLi BY RDLVIAi
}
CONNECT RDLi RDLPA2i
CONNECT PAi ALPAi
CONNECT RDLi ALPAi
CONNECT ALPAi MDi
CONNECT M1i GT0 NTAP0 PTAP0 PSDi NSDi BY CTi
CONNECT NTAP0 NW0 BY CTi
CONNECT NWi DNWi                                //NW interact with DNW
CONNECT NTAP0 NWi                               //N+pickup interact with NW
CONNECT PTAP0 PWi				//P+pickup interact with (NOT NW)
CONNECT NTAP0 PSDi				//N+pickup butted P+ silicided S/D
CONNECT PTAP0 NSDi				//P+pickup butted N+ silicided S/D
CONNECT PSDi PSD
CONNECT NSDi NSD
CONNECT NWi NW
CONNECT DNWi DNW
CONNECT PWi PW
CONNECT CTi CT
set metal_all_reverse " "
for { set i 0 } { $i < [llength $metal_all] } { incr i } {
  lappend metal_all_reverse [lindex $metal_all end-$i]i
}

TEXT DEPTH PRIMARY
#LAYOUT TOP LAYER $metal_all_reverse
LVS POWER NAME "?VDD?" "?VCC?"

LABEL ORDER $metal_all_reverse NTAP0 PTAP0 NSDi PSDi GT0 NWi



#// VIRTUAL CONNECT NOTICE!
#// Power name below should be adjusted following the power naming convention to detect NW spacing rule violations correctly.
VIRTUAL CONNECT NAME "?VDD?" "?VCC?" "?VSS?" "?GND?"
VIRTUAL CONNECT COLON YES


VERBATIM {
//******************************************
//    LAYER DERIVATIONS AND OPERATIONS
//******************************************


//==================
// For Connectivity
//==================

PACTi   = SPi AND AAi
NACTi   = SNi AND AAi

PTAPi   = PACTi NOT NWi
NTAPi   = NACTi AND NWi

PGATEi  = PACTi AND GTi
NGATEi  = NACTi AND GTi

PSDi    = PACTi NOT PGATEi
NSDi    = NACTi NOT NGATEi

PMOSi   = (PGATEi OR PSDi) INTERACT GATE
NMOSi   = (NGATEi OR NSDi) INTERACT GATE

AA_resistor = ((AA AND RESAA) AND SAB) OR ((AA AND RESAA) NOT INTERACT SAB)
GT_resistor = (((GT AND RESP1) AND SAB) OR ((GT AND RESP1) NOT INTERACT SAB)) OR HRPDMY
NW_resistor = (RESNW AND AA) AND NW

GT_all = GTi OR GTDUMi
AA_all = AAi OR AADUMi

//AA0 = (AAi NOT (AA_resistor OR RESNW)) NOT GTi
GT0 = GTi NOT (SAB AND (RESP1 OR HRPDMY))
NW0 = NWi NOT RESNW
NW00 = NW NOT RESNW

PTAP0   = PACTi NOT NWi
NTAP0   = NACTi AND NWi

HVNW0    = NW00 AND HVNW
MVNW0    = NW00 AND MVNW
LVNW0    = NW00 AND LVNW

//GT_raw = GT NOT SAB
GT_raw   = COPY GT

//==================
//  Resistor Def
//==================

NWR     = NW INTERACT RESNW
AAR     = AA INTERACT RESAA
GTR     = GT INTERACT RESP1


NR      = NWR INSIDE AA
AANR    = AA INTERACT NWR
SNNR    = SN INTERACT NWR
SPNR    = SP INTERACT NWR

NWDEV   = NW NOT (NWR OR NR)
AADEV   = AA NOT (AAR OR AANR)
GTDEV   = GT NOT GTR
SNDEV   = SN NOT SNNR
SPDEV   = SP NOT SPNR

//=============
//   HRP Def
//=============

GT_HRP   =  ((HRPDMY AND GT) AND HRP) AND SAB
//GT_HRP   = GT INTERACT HRP
//HR_GT    = GT_HRP AND HRPDMY

//==================
//   Well Def
//==================

DRC:1   = EXTENT drawn original
BULK    = SIZE DRC:1 BY 1.0

PW_INNW = DNW NOT NW
DNW_EDGE = EXPAND EDGE (DNW INSIDE EDGE NW) OUTSIDE BY 0.001
NW_DNW = NW INTERACT DNW_EDGE

DGTG    = TG OR DG

HVNW    = (NW NOT OUTSIDE TG) OR NWHT
MVNW    = (NW NOT OUTSIDE DG) OR NWH
LVNW    = (NW NOT HVNW) NOT MVNW

HVNWi	= (NWi NOT OUTSIDE TGi) OR NWHTi
MVNWi	= (NWi NOT OUTSIDE DGi) OR NWHi
LVNWi	= (NWi NOT HVNWi) NOT MVNWi


//==================
// Transistor Def
//==================

PACT    = SP AND AA
NACT    = SN AND AA
ACT     = PACT OR NACT


PGT     = SP AND GT
NGT     = SN AND GT

PTAP    = PACT NOT NW
NTAP    = NACT AND NW
TAP     = PTAP OR NTAP

PICKAA = TAP NOT ((TAP INTERACT GATE) AND VARMOS)
NON_PICKAA = AA NOT PICKAA


PGATE   = PACT AND GT
NGATE   = NACT AND GT

GATE0 = (GT INTERACT CT) AND AA 
AA1 = (AA INTERACT GATE0) NOT GATE0
AA2 = AA1 TOUCH GATE0 == 2
AA3 = AA1 INTERACT CT 
AA4 = AA2 OR AA3
GATE1 = GATE0 TOUCH AA4 == 2
GATE2 = GATE0 AND LDBK
GATE  = GATE1 OR GATE2
/*
GATEi = GTi AND AAi
GATE = GT AND AA
*/
GATE_L = (GATE COIN EDGE AA) NOT COIN EDGE GT
GATE_W = GATE COIN EDGE GT
GATE_60nm = (EXPAND EDGE GATE_W INSIDE BY 0.06) INSIDE EDGE GATE       //for SAB_5

GATE_M = GATE NOT (DG OR TG)                        //1.0/1.2V MOS GATE
GATE_M_L  = (GATE_M COIN EDGE AA) NOT COIN EDGE GT  //1.0/1.2V MOS GATE LENGTH
GATE_M_W  = GATE_M COIN EDGE GT			    //1.0/1.2V MOS GATE WIDTH

GATE_D = (GATE AND DG) NOT TG     //1.8V MOS GATE
GATE_D_L = (GATE_D COIN EDGE AA) NOT COIN EDGE GT
GATE_D_W = GATE_D COIN EDGE GT

GATE_T = (GATE AND TG) NOT DG
GATE_T_L = (GATE_T COIN EDGE AA) NOT COIN EDGE GT
GATE_T_W = GATE_T COIN EDGE GT


PSD     = (PACT NOT PGATE) TOUCH PGATE
NSD     = (NACT NOT NGATE) TOUCH NGATE

PMOS    = PGATE OR PSD
NMOS    = NGATE OR NSD
MOS     = PMOS OR NMOS

NMOS_CAP = NMOS AND NW

PBAA   	= AA AND PSUB
PBMOS   = NMOS AND PSUB
PBGT   	= GT INTERACT PSUB
NOMI_AA = AA NOT PBAA

NLLAA   = AA AND NLL
NLHAA   = AA AND NLH
PLLAA   = AA AND PLL
PLHAA   = AA AND PLH
NLHTAA  = AA AND NLHT
PLHTAA  = AA AND PLHT

AAEIGT  = AA INSIDE EDGE GT
GTEIAA  = GT INSIDE EDGE AA

INTERGT = GT NOT GATE


//=====================
//   Poly E-Fuse Def
//=====================

EFU    = GT INTERACT EFUSE
EFU_BO = EFU AND GTFUSE
RCT    = CT INTERACT EFU
RCT_RT = RECTANGLE RCT == 0.09 BY == 0.30


//=====================
//     CT Def
//=====================

ACT_CT   = CT AND AA
INTERCT  = CT AND INTERGT

}

#//=====================
#//   AL Fuse Def
#//=====================

SETLAYER ALFUSE = (RDL AND FUSE) AND MARKF
SETLAYER Al_fuse_1 = LENGTH ALFUSE >= 4.44
SETLAYER Al_fuse   = ALFUSE WITH EDGE Al_fuse_1 >= 2
SETLAYER Alfuse_edge = LENGTH Al_fuse >= 4.44
SETLAYER Alfuse_edge_1 = CONVEX EDGE ALFUSE ANGLE1 == 270 ANGLE2 == 270

for { set i 0 } { $i <= [llength $v_m_list] } { incr i 2 } {
  SETLAYER H[lindex $v_m_list $i] = (HOLES [lindex $v_m_list $i] INNER) INTERACT FUSE
  SETLAYER G[lindex $v_m_list $i] = ([lindex $v_m_list $i] TOUCH H[lindex $v_m_list $i]) AND MARKG
   
  set j [expr $i +1]
  if { $j < [llength $v_m_list] } {
    SETLAYER G[lindex $v_m_list $j] = [lindex $v_m_list $j] INTERACT G[lindex $v_m_list $i]
    SETLAYER [lindex $v_m_list $j]FUSE = [lindex $v_m_list $j] INSIDE H[lindex $v_m_list $i]
  }

  VERBATIM { }
}

SETLAYER GCT = CT INTERACT GM1
SETLAYER CTFUSE = CT INSIDE HM1

SETLAYER HRDL = (HOLES RDL inner ) INTERACT FUSE
SETLAYER GRDL = (RDL TOUCH HRDL) AND MARKG
SETLAYER GRDLV = RDLVIA INTERACT GRDL
SETLAYER RDLVF = RDLVIA INSIDE HRDL

set Stack_Vn "[lindex $via_all end]FUSE INTERACT RDLVF"
for { set i 1 } { $i < [llength $via_all] } { incr i } {
  set Stack_Vn "[lindex $via_all end-$i]FUSE INTERACT (${Stack_Vn})"
}
SETLAYER Stack_Vn  = $Stack_Vn

set Stack_MR "G[lindex $metal_all end] OR GRDL"
for { set i 1 } { $i < [llength $metal_all] } { incr i } {
  set Stack_MR "G[lindex $metal_all end-$i] OR (${Stack_MR})"
}
SETLAYER Stack_MR  = $Stack_MR


SETLAYER LMARK = (RDL AND FUSE) AND LOGO


#--------------------------------------------------------------------------------------------------------------------------------

#****************************************************
# MACRO for wide metal space rule
#****************************************************

proc Mn_2b { MTLAY MTLEN MTWID MTSPA } {
  SETLAYER span_edge_0 = DFM COPY (DFM SPACE $MTLAY < $MTWID BY INT) EDGE
  SETLAYER span_edge_1 = $MTLAY NOT COIN EDGE span_edge_0
  SETLAYER span_edge = EXT \[span_edge_1\] $MTLAY < $MTSPA ABUT < 90 OPPOSITE
  OUTLAYER (LENGTH span_edge >= $MTLEN) NOT INSIDE EDGE EXDRC
}
proc Mn_2b_SPECIAL { MTLAY MTLEN MTWID MTSPA } {
  SETLAYER span_edge_0 = DFM COPY (DFM SPACE $MTLAY < $MTWID BY INT) EDGE
  SETLAYER span_edge_1 = $MTLAY NOT COIN EDGE span_edge_0
  SETLAYER span_edge = EXT \[span_edge_1\] $MTLAY < $MTSPA ABUT < 89.9 OPPOSITE
  OUTLAYER (LENGTH span_edge >= $MTLEN) NOT INSIDE EDGE EXDRC
}

#proc Mn_2b { MTLAY MTLEN MTWID MTSPA } {
#  SETLAYER span_edge = INT($MTLAY) < $MTWID OPPOSITE
#  SETLAYER span_region = EXT span_edge $MTLAY < $MTSPA ABUT<90 OPPOSITE REGION
#  SETLAYER X = LENGTH span_region >= $MTLEN
#  OUTLAYER INT X < $MTSPA ABUT<90 OPPOSITE REGION
#}

#proc Mn_2c { MTLAY MTLEN MTWID MTSPA } {
#  SETLAYER span_edge = INT($MTLAY) < $MTWID OPPOSITE
#  SETLAYER span_region = EXT span_edge $MTLAY < $MTSPA ABUT<90 OPPOSITE REGION
#  SETLAYER X = LENGTH span_region >= $MTLEN
#  OUTLAYER INT X < $MTSPA ABUT<90 OPPOSITE REGION
#}

proc Mn_2b_DUM { MTLAY DUMMY2 MTLEN MTWID MTSPA } {
  SETLAYER X0_a = $MTLAY WITH WIDTH >= $MTWID
  SETLAYER X0 = ENCLOSE RECTANGLE X0_a $MTLEN $MTWID
  SETLAYER X1 = EXT $MTLAY < $MTSPA OPPOSITE REGION PARA ONLY
  SETLAYER X2 = LENGTH X1 >= $MTLEN
  SETLAYER X3 = X2 TOUCH EDGE X0
  SETLAYER X4_near = EXPAND EDGE X3 OUTSIDE BY $MTWID
  SETLAYER X4_far  = (EXPAND EDGE X3 OUTSIDE BY ($MTWID + 0.01)) NOT X4_near
  SETLAYER X5 = X4_near NOT $MTLAY
  SETLAYER X6_near = EXT X1 X5 < $MTWID OPPOSITE REGION
  SETLAYER X6_far  = EXT X4_far X5 < $MTWID OPPOSITE REGION
  SETLAYER X7 = (X4_near NOT X5) NOT (X6_near OR X6_far)
  SETLAYER X7_edge = LENGTH (X7 COIN EDGE X1) >= $MTLEN
  SETLAYER X7_expand = EXPAND EDGE X7_edge OUTSIDE BY $MTSPA
  SETLAYER X8 = (X7_expand AND X1) NOT X5
  OUTLAYER (X8 INTERACT $DUMMY2) NOT INSIDE EXDRC 
}

proc Mn_2c_DUM { MTLAY DUMMY2 MTLEN MTWID MTSPA } {
  SETLAYER X0_a = $MTLAY WITH WIDTH >= $MTLEN
  SETLAYER X0 = ENCLOSE RECTANGLE X0_a $MTLEN $MTWID
  SETLAYER X1 = EXT $MTLAY < $MTSPA OPPOSITE REGION PARA ONLY
  SETLAYER X2 = LENGTH X1 >= $MTLEN
  SETLAYER X3 = X2 TOUCH EDGE X0
  SETLAYER X4_near = EXPAND EDGE X3 OUTSIDE BY $MTWID
  SETLAYER X4_far  = (EXPAND EDGE X3 OUTSIDE BY ($MTWID + 0.01)) NOT X4_near
  SETLAYER X5 = X4_near NOT $MTLAY
  SETLAYER X6_near = EXT X1 X5 < $MTWID OPPOSITE REGION
  SETLAYER X6_far  = EXT X4_far X5 < $MTWID OPPOSITE REGION
  SETLAYER X7 = (X4_near NOT X5) NOT (X6_near OR X6_far)
  SETLAYER X7_edge = LENGTH (X7 COIN EDGE X1) >= $MTLEN
  SETLAYER X7_expand = EXPAND EDGE X7_edge OUTSIDE BY $MTSPA
  SETLAYER X8 = (X7_expand AND X1) NOT X5
  OUTLAYER (X8 INTERACT $DUMMY2) NOT INSIDE EXDRC 
}

#--------For AA GT shape -------------------------------------------------------------------------------------------------------------------------------
proc SHAPE { LAYER } {
SETLAYER  ${LAYER}_VEX_0 = CONVEX EDGE $LAYER == 0
SETLAYER  ${LAYER}_VEX_1 = CONVEX EDGE $LAYER == 1
SETLAYER  ${LAYER}_VEX_2 = CONVEX EDGE $LAYER == 2


SETLAYER  ${LAYER}_LS = (($LAYER NOT WITH EDGE ${LAYER}_VEX_0) WITH EDGE ${LAYER}_VEX_1 == 2) WITH EDGE ${LAYER}_VEX_2 == 4

SETLAYER  ${LAYER}_TS1 = (($LAYER NOT WITH EDGE ${LAYER}_VEX_0) WITH EDGE ${LAYER}_VEX_1 == 4) WITH EDGE ${LAYER}_VEX_2 == 4
SETLAYER  ${LAYER}_TS2 = EXPAND EDGE (${LAYER}_VEX_2 COIN EDGE ${LAYER}_TS1) OUTSIDE BY 0.005 CORNER FILL
SETLAYER  ${LAYER}_TS3 = ${LAYER}_TS2 WITH EDGE ${LAYER}_VEX_2 == 3
SETLAYER  ${LAYER}_TS = ${LAYER}_TS1 INTERACT ${LAYER}_TS3 == 1

SETLAYER  ${LAYER}_US = (($LAYER WITH EDGE ${LAYER}_VEX_0 == 1) WITH EDGE ${LAYER}_VEX_1 == 2) WITH EDGE ${LAYER}_VEX_2 == 5

SETLAYER  ${LAYER}_OS = (($LAYER WITH EDGE ${LAYER}_VEX_0 == 4) NOT WITH EDGE ${LAYER}_VEX_1) WITH EDGE ${LAYER}_VEX_2 == 4

SETLAYER ${LAYER}_HS = (($LAYER WITH EDGE ${LAYER}_VEX_0 ==2) WITH EDGE ${LAYER}_VEX_1 == 4) WITH EDGE ${LAYER}_VEX_2 == 6
}

SHAPE GT
SHAPE AA

#------------------FOR H SHAPE--------------------------
proc via_in_H_bar { via metal hole_length hole_area bar_l bar_w } {

SETLAYER X0 = AREA (RECTANGLE (HOLES $metal INNER)) <= $hole_area
SETLAYER X1 = X0 NOT WITH EDGE (LENGTH X0 > 5)
SETLAYER Y = $metal COIN EDGE X1
SETLAYER Z0 = (INT Y <= $bar_w OPPOSITE REGION) INTERACT X1 == 2
SETLAYER Z1 = LENGTH ($metal COIN EDGE Z0) <= 1 
SETLAYER Z = Z0 WITH EDGE Z1
}
#------------------FOR TV1.10--------------------------
proc two_via_within_space_in_wide_metal { via metal_bottom metal_up metal_width } {

SETLAYER  X1a = WITH WIDTH $metal_bottom > $metal_width
SETLAYER  X1b = WITH WIDTH $metal_up > $metal_width
SETLAYER  WIDE = X1a OR X1b
SETLAYER  X2 = ($metal_bottom AND $metal_up) ENCLOSE ($via NOT OUTSIDE WIDE)
SETLAYER  X3 =  $via INSIDE X2
SETLAYER  X5c = WITH NEIGHBOR X3 >= 1 INSIDE OF LAYER X2 
SETLAYER  X6c = X2 ENCLOSE X5c
OUTLAYER  ((X2 NOT X6c) NOT MARKS) NOT INSIDE EXDRC
}


#//==================================
#//  DNW -  Deep N-Well  DRC
#//==================================

GROUP GDNW DNW_?

RULECHECK DNW_1 {
@ Min DNW width is 3
OUTLAYER (INT DNW < 3.0 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK DNW_2 {
@ Min Space between two DNWs is 3.5
OUTLAYER (EXT DNW < 3.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK DNW_3 {
@ Min Enclosure of DNW by NW is 1
#SETLAYER X = NW NOT COIN EDGE (HOLES NW)
#OUTLAYER (ENC DNW X < 1 ABUT<90 REGION) NOT INSIDE EXDRC
OUTLAYER (ENC DNW NW < 1.0 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (DNW COINCIDENT EDGE NW) NOT INSIDE EDGE EXDRC
OUTLAYER (DNW OUTSIDE EDGE NW) NOT INSIDE EDGE EXDRC
}
RULECHECK DNW_4 {
@ Min Overlap of NW and DNW is 0.4. 
# OUTLAYER (INT (DNW AND (NW NOT INSIDE DNW)) < 0.4 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  SETLAYER X = SIZE DNW BY -0.4
  OUTLAYER ((DNW NOT X) NOT NW) NOT INSIDE EXDRC 
}
RULECHECK DNW_5 {
@ Min Space between DNW and NW is 2.5
SETLAYER X = NW NOT COIN EDGE DNW
OUTLAYER (EXT X DNW < 2.5 ABUT<90 REGION) NOT INSIDE EXDRC
}

if { [string equal $Recommended_rules_CHECK YES] == 1 } {
RULECHECK DNW_5a_R {
@ Min Space between DNW and NW at different net is 3.0
OUTLAYER (EXT DNW NW < 3.0 SINGULAR REGION NOT CONNECTED) NOT INSIDE EXDRC
}
RULECHECK DNW_6_R {
@ DNW is enclosed by NW
@ NOTICE: It is a recommended rule.
OUTLAYER ((DNW NOT INSIDE EDGE NW_DNW) NOT COIN EDGE NW_DNW) NOT INSIDE EDGE EXDRC
}
}

RULECHECK DNW_7 {
@ DNW is not allowed in native device region.
@ NOTICE: It is a recommended rule.
OUTLAYER (DNW AND PSUB) NOT INSIDE EXDRC
}


RULECHECK DNW_8 {
@ Min Space between ((PW INSIDE DNW) NOT INTERACT (DG OR TG)) and (PW NOT INTERACT (DG OR TG)) at different nets, except LDMOS region is 1.0um
SETLAYER X = (PW INSIDE DNW) NOT INTERACT (DG OR TG)
SETLAYER Y = PW NOT INTERACT (DG OR TG)
OUTLAYER ((EXT X Y < 1.0 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE LDBK) NOT INSIDE EXDRC
}

RULECHECK DNW_9 {
@ Min Space between ((PW INSIDE DNW) INTERACT (DG OR TG)) and (PW INTERACT (DG OR TG)) at different nets, except LDMOS region is 1.20um
SETLAYER X = (PW INSIDE DNW) INTERACT (DG OR TG)
SETLAYER Y = PW INTERACT (DG OR TG)
OUTLAYER ((EXT X Y < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE LDBK) NOT INSIDE EXDRC
}

RULECHECK DNW_10 {
@ Min Enclosure of N+ active AA(exclude pick-up AA) is 0.55
OUTLAYER (ENC (NACT NOT (NTAP OR PTAP)) DNW < 0.55 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}


#//===========================
#//  AA - Active Area DRC
#//===========================

GROUP GAA AA_?

RULECHECK AA_1 {
@ Min Width of interconnect AA is 0.08
OUTLAYER (INT AA < 0.08 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK AA_2a {
@ Min Channel width for 1.0/1.2V NMOS/PMOS transistors is 0.11
SETLAYER Y = LENGTH GATE_M_W < 0.11
OUTLAYER ((EXPAND EDGE Y INSIDE BY 0.001) NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK AA_2b {
@ Min Channel width for 1.8/2.5/3.3V NMOS/PMOS transistors is 0.21
SETLAYER Y1 = LENGTH GATE_D_W < 0.21
SETLAYER Y2 = LENGTH GATE_T_W < 0.21
OUTLAYER ((EXPAND EDGE Y1 INSIDE BY 0.001) NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER ((EXPAND EDGE Y2 INSIDE BY 0.001) NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK AA_3a {
@ Min Space between two AAs in the same well is 0.10,DRC waive check 45-degree spaces in the INDMY region
OUTLAYER ((EXT AA < 0.10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT AA < 0.10 ABUT<44 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT AA < 0.10 ABUT>46<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC 
}
RULECHECK AA_3b {
@ Min Space between AAs with one or both AA width greater than 0.15um in the same well is 0.11,DRC waive check the INDMY covered region.
SETLAYER X = AA WITH WIDTH > 0.15
OUTLAYER ((EXT X AA < 0.11 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
}
RULECHECK AA_4 {
@ Min N+AA enclosed by NW (excluding NW interacting with RESNW) is 0.12
SETLAYER X = ENC NACT (NW NOT INTERACT RESNW) < 0.12 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK AA_5 {
@ Min Space between NW and N+AA inside PW except NW resistor region is 0.15
SETLAYER X = EXT (NW NOT INTERACT RESNW) (NACT INSIDE PW) < 0.15 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK AA_6 {
@ Min P+AA enclosed by NW is 0.15
SETLAYER X = ENC PACT NW < 0.15 ABUT<90 SINGULAR REGION 
OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK AA_7 {
@ Space between NW and P+AA inside PW  except LDBK region is 0.12
SETLAYER X = EXT NW (((PACT NOT NW) NOT PSUB) NOT INSIDE LDBK) < 0.12 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK AA_8 {
@ Min AA area is 0.038
SETLAYER X = AREA AA < 0.038
OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK AA_8a {
@ Min Enclosed area is 0.07
OUTLAYER (AREA ((HOLES AA INNER) NOT AA) < 0.07) NOT INSIDE EXDRC
}
RULECHECK AA_9 {
@ Min Space between N+AA, which is not enclosed by DNW, and NW which encloses a DNW is 0.32
SETLAYER X = EXT NACT NW_DNW < 0.32 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT DNW) NOT INSIDE EXDRC

}
RULECHECK AA_10a_Min {
@ Min Local AA density (including dummy AA) in 200umX200um window with step size 100um is 19%.
OUTLAYER (DENSITY AA_all < 0.19 WINDOW 200 STEP 100 BACKUP PRINT density_report_AA10a_min.log) NOT INSIDE EXDRC
}
RULECHECK AA_10a_Max {
@ Max Local AA density (including dummy AA) in 200umX200um window with step size 100um is 90%.
OUTLAYER (DENSITY AA_all > 0.90 WINDOW 200 STEP 100 BACKUP PRINT density_report_AA10a_max.log) NOT INSIDE EXDRC
}

RULECHECK AA_10b_Min {
@ Min Global AA density for fully chip (including dummy AA) is 23%
OUTLAYER (DENSITY AA_all < 0.23 PRINT density_report_AA10b_min.log) NOT INSIDE EXDRC
}
RULECHECK AA_10b_Max {
@ Max Global AA density for fully chip (including dummy AA) is 75%
OUTLAYER (DENSITY AA_all > 0.75 PRINT density_report_AA10b_max.log) NOT INSIDE EXDRC
} 
if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK AA_10c_R {
@ Min AA density inside of dummy block area is 23%,while the area of dummy block layer is larger than 2500um2 (50umX50um)
@ NOTICE: It is a recommended rule.
SETLAYER X = AREA (DUMBA OR NODMF) > 2500
OUTLAYER (DENSITY AA_all < 0.23 INSIDE OF LAYER X PRINT density_report_AA10c.log) NOT INSIDE EXDRC
}
}

RULECHECK AA_11 {
@ N+ active AA(exclude pick-up AA) is not allowed to be straddle on the boundary of DNW except LDBK, RESNW areas.
SETLAYER X = NACT NOT (NTAP OR PTAP)
OUTLAYER ((X CUT DNW) NOT INSIDE (LDBK OR RESNW)) NOT INSIDE EXDRC
}

if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK AA_12_R {
@ N+ AA is not allowed to be straddle on the boundary of NW except LDBK, RESNW areas.
SETLAYER X = COPY NACT
OUTLAYER (X CUT (NW NOT INTERACT (LDBK OR RESNW))) NOT INSIDE EXDRC
}

RULECHECK AA_16_R {
@ Maximum AA length between two contacts, or between one contact and AA line end when AA width < 0.15 µm is 25.00um
SETLAYER AA_CHECK = WITH WIDTH AA < 0.15
SETLAYER Z0 = SIZE CT BY 12.5 INSIDE OF AA_CHECK STEP 0.02
SETLAYER Z1 = Z0 INTERACT CT < 2
SETLAYER Z2 = (AA_CHECK INTERACT Z1) NOT (AA_CHECK INTERACT CT == 1)
OUTLAYER Z2 NOT INSIDE EXDRC

SETLAYER X = CONVEX EDGE AA ANGLE1>=89.9<=90.1 ANGLE2>=89.9<=90.1 WITH LENGTH<0.15 
SETLAYER Y = (AA WITH WIDTH <0.15) INTERACT CT
SETLAYER Z = Y TOUCH EDGE X    
SETLAYER Z3 = SIZE CT BY 25 INSIDE OF Y STEP 0.02
OUTLAYER ((Z NOT INSIDE EDGE Z3) NOT TOUCH EDGE Z3) NOT INSIDE EDGE EXDRC
}
}

if { [string equal $Recommended_rules_CHECK YES] == 1 } {
RULECHECK AA_13_R {
@ Min Width of 45 degree bent AA is 0.18
SETLAYER X = ANGLE AA == 45
OUTLAYER (INT X < 0.18 ABUT<90 REGION) NOT INSIDE EXDRC
}
RULECHECK AA_14_R {
@ Min Space to 45 degree bent AA is 0.18, except the INDMY covered region.
SETLAYER X = ANGLE AA == 45
OUTLAYER ((EXT X AA < 0.18 ABUT<90 REGION) NOT INDMY) NOT INSIDE EXDRC
}
}

RULECHECK AA_15 {
@ Min Space between U-shape (or O-shape) AA inner edges is 0.15
OUTLAYER (CONVEX EDGE AA_OS == 0 WITH LENGTH < 0.15) NOT INSIDE EDGE EXDRC
OUTLAYER (CONVEX EDGE AA_US == 0 WITH LENGTH < 0.15) NOT INSIDE EDGE EXDRC
}



#//==================================
#//  NW -  N-Well  DRC
#//==================================

GROUP GNW NW_?

SETLAYER NW_RE = NW NOT OUTSIDE EDGE RESNW
SETLAYER LVNW_RE = NW_RE COIN EDGE LVNW
SETLAYER MVNW_RE = NW_RE COIN EDGE MVNW
SETLAYER HVNW_RE = NW_RE COIN EDGE HVNW

SETLAYER NW_RES = NW AND RESNW

RULECHECK NW_1 {
@ Min NW width is 0.36
OUTLAYER (INT NW < 0.36 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK NW_2 {
@ Min NW width for NW resistor is 1.6
OUTLAYER (INT NWR < 1.60 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK NW_3 {
@ Min Space between 1.0/1.2V NWs at the same nets is 0.36
OUTLAYER ((EXT LVNW0 < 0.36 ABUT<90 SINGULAR REGION CONNECTED) NOT NW_RES) NOT INSIDE EXDRC
}

RULECHECK NW_4 {
@ Min Space between 1.0/1.2V NWs at different nets is 0.47
OUTLAYER ((EXT LVNW0 < 0.47 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE EXDRC
OUTLAYER (EXT LVNW_RE LVNW < 0.47 REGION) NOT INSIDE EXDRC
}

RULECHECK NW_5 {
@ Min Space between 1.0/1.2V and 1.8/2.5/3.3V NWs at the same nets is 0.47
OUTLAYER (EXT LVNW0 HVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE EXDRC
OUTLAYER (EXT LVNW0 MVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE EXDRC
}

RULECHECK NW_6 {
@ Min Space between 1.0/1.2V NW and 1.8/2.5/3.3V NW at different nets is 0.72
OUTLAYER (EXT LVNW0 HVNW0 < 0.72  ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE EXDRC
OUTLAYER (EXT LVNW0 MVNW0 < 0.72  ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE EXDRC

OUTLAYER (EXT LVNW_RE MVNW < 0.72 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT LVNW_RE HVNW < 0.72 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT MVNW_RE LVNW < 0.72 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT HVNW_RE LVNW < 0.72 REGION) NOT INSIDE EXDRC
}

RULECHECK NW_7a {
@ Min Space between 1.8/2.5/3.3V NWs at same nets is 0.47
OUTLAYER ((EXT MVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE NW_RES) NOT INSIDE EXDRC
OUTLAYER ((EXT HVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE NW_RES) NOT INSIDE EXDRC
OUTLAYER (EXT MVNW0 HVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE EXDRC
}

RULECHECK NW_7b {
@ Min Space between 1.8/2.5/3.3V NW is 0.72 at different nets is 0.72.
OUTLAYER ((EXT MVNW0 < 0.72 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE EXDRC
OUTLAYER ((EXT HVNW0 < 0.72 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE EXDRC
OUTLAYER (EXT MVNW0 HVNW0 < 0.72 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE EXDRC

OUTLAYER (EXT MVNW_RE MVNW < 0.72 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT HVNW_RE HVNW < 0.72 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT MVNW_RE HVNW < 0.72 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT HVNW_RE MVNW < 0.72 REGION) NOT INSIDE EXDRC
}

RULECHECK NW_8 {
@ Min NW area is 0.3
OUTLAYER (AREA NW < 0.3) NOT INSIDE EXDRC
}

RULECHECK NW_9 {
@ Min NW enclosed area is 0.30
OUTLAYER (AREA ((HOLES NW INNER) NOT NW) < 0.30) NOT INSIDE EXDRC
}

#if { [string equal $Recommended_rules_CHECK YES] == 1 } {
#RULECHECK NW_10_R {
#@ Min NW area when one of the edge length <0.8um is 0.30
#SETLAYER X = LENGTH NW < 0.8
#SETLAYER Y = NW WITH EDGE X
#OUTLAYER (AREA Y < 0.3) NOT INSIDE EXDRC
#}
#RULECHECK NW_11_R {
#@ Min NW enclosed area when one of the edge length <0.8um is 0.3
#SETLAYER X = (HOLES NW INNER) NOT NW
#SETLAYER Y = LENGTH (X TOUCH EDGE NW) < 0.8
#OUTLAYER (AREA (X WITH EDGE Y )< 0.3 ) NOT INSIDE EXDRC
#}
#}

#//==========================================
#//  PSUB - Native NMOS blocked implant DRC
#//==========================================

GROUP GPSUB PSUB_?

RULECHECK PSUB_1 {
@ Min PSUB width is 0.36
OUTLAYER (INT PSUB < 0.36 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK PSUB_2 {
@ Min 1.0/1.2/1.8/2.5/3.3V native NMOS channel width is 0.5
SETLAYER X = LENGTH GATE_W < 0.5
OUTLAYER ((EXPAND EDGE X INSIDE BY 0.005) AND PSUB) NOT INSIDE EXDRC
}
RULECHECK PSUB_3a {
@ 1.0/1.2V native NMOS channel length is 0.2
SETLAYER X = PBGT INSIDE EDGE PBAA
OUTLAYER (INT X < 0.20 ABUT<90 REGION) NOT INSIDE EXDRC
}
RULECHECK PSUB_3b {
@ 1.8V native NMOS channel length is 0.8
SETLAYER X = PBGT INSIDE EDGE (PBAA INTERACT DG)
OUTLAYER (INT X < 0.80 ABUT<90 REGION) NOT INSIDE EXDRC
}

if { $IO == 1825 } {
RULECHECK PSUB_3c {
@ Min 2.5V (or overdrive to 3.3V) native NMOS channel length is 1.0
SETLAYER X = PBGT INSIDE EDGE (PBAA INTERACT TG) 
OUTLAYER (INT X < 1.0 ABUT<90 REGION) NOT INSIDE EXDRC
}
}

if { $IO == 1833 } {
RULECHECK PSUB_3d {
@ Min 3.3V native NMOS channel length is 1.2
SETLAYER X = PBGT INSIDE EDGE (PBAA INTERACT TG)
OUTLAYER (INT X < 1.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
}

RULECHECK PSUB_4 {
@ Min Space between two PSUBs is 0.36
OUTLAYER (EXT PSUB < 0.36 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK PSUB_5 {
@ Fixed Native NMOS AA enclosure by PSUBs is 0.285
SETLAYER X = SIZE (PBMOS NOT INTERACT CAPBP) BY 0.285
SETLAYER Y = PSUB INTERACT PBMOS
SETLAYER Z = NMOS INTERACT CAPBP
OUTLAYER ((XOR X Y) NOT INTERACT Z) NOT INSIDE EXDRC
}
RULECHECK PSUB_6 {
@ Min Space between PSUB and MOS AA is 0.37
OUTLAYER (EXT PSUB MOS < 0.37 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT PSUB AA_LDMOS < 0.37 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK PSUB_7 {
@ Min Space between PSUB and NW is 1.2
OUTLAYER (EXT PSUB NW < 1.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK PSUB_8 {
@ Min Extension of native NMOS poly gate outside of AA is 0.31
@ DRC don't flag the INDMY covered inductor region
#SETLAYER X = PBAA INSIDE EDGE PBGT
OUTLAYER ((ENC PBAA PBGT < 0.31 ABUT<90 REGION OPPOSITE) NOT INSIDE INDMY) NOT INSIDE EXDRC
}

RULECHECK PSUB_9 {
@ PSUB inside, overlapping with, or crossing over a DNW area is not allowed
OUTLAYER (PSUB AND DNW) NOT INSIDE EXDRC
OUTLAYER (PSUB COINCIDENT OUTSIDE EDGE DNW) NOT INSIDE EDGE EXDRC
}
RULECHECK PSUB_10 {
@ PSUB must not overlap NW
OUTLAYER (PSUB AND NW) NOT INSIDE EXDRC
}
RULECHECK PSUB_11 {
@ Only one AA pattern is allowed in one PSUB region, except for NMOS capacitors and AAs interact INDMY.
OUTLAYER (PSUB INTERACT (AA NOT INTERACT (CAPBP OR INDMY)) > 1) NOT INSIDE EXDRC
}
RULECHECK PSUB_12 {
@ SP is not allowed to exist in a PSUB region,DRC waive check INDMY covered region, and P+ pickup can be waived.
SETLAYER X = (SP AND PSUB) NOT INSIDE INDMY
SETLAYER Y = ((AA OR GT) INTERACT GATE) AND PSUB
OUTLAYER (X INTERACT Y) NOT INSIDE EXDRC
}
RULECHECK PSUB_13 {
@ Min PSUB area is 0.30
OUTLAYER (AREA PSUB < 0.3) NOT INSIDE EXDRC
}
RULECHECK PSUB_14 {
@ Min PSUB enclosed area is 0.30
OUTLAYER (AREA ((HOLES PSUB INNER) NOT PSUB) < 0.30) NOT INSIDE EXDRC
}
if { [string equal $Recommended_rules_CHECK YES] == 1 } {
RULECHECK PSUB_15_R {
@ Min PSUB area when one of the edge length <0.8um is 0.30
SETLAYER X = LENGTH PSUB < 0.8
SETLAYER Y = PSUB WITH EDGE X
OUTLAYER (AREA Y < 0.3) NOT INSIDE EXDRC

}
RULECHECK PSUB_16_R {
@ Min PSUB enclosed area when one of the edge length <0.8um is 0.30
SETLAYER X = (HOLES PSUB INNER) NOT PSUB
SETLAYER Y = LENGTH (X TOUCH EDGE PSUB) < 0.8
OUTLAYER (AREA (X WITH EDGE Y) < 0.30) NOT INSIDE EXDRC
}
}

VERBATIM {

//===============================
//   VTNH: High Vt NMOS Implant
//===============================

GROUP GVTNH VTNH_?

VTNH_1 {
@ Min VTNH width is 0.18. Single-point-interaction is allowed.
  (INT VTNH < 0.18 ABUT<90 REGION) NOT INSIDE EXDRC
}
VTNH_2 {
@ Min Space between two VTNH is 0.18
  (EXT VTNH < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE EXDRC
}
VTNH_3 {
@ VTNH overlap with PSUB, P+ active AA(exclude pick-up AA), VTPH, DG or TG are not allowed
  (AND VTNH PSUB) NOT INSIDE EXDRC
  (AND VTNH (PACT NOT (NTAP OR PTAP))) NOT INSIDE EXDRC
  (AND VTNH VTPH) NOT INSIDE EXDRC
  (AND VTNH DG) NOT INSIDE EXDRC
  (AND VTNH TG) NOT INSIDE EXDRC
}
VTNH_4 {
@ Min VTNH extension outside of MOS AA along gate poly length direction is 0.12
  X = (NACT AND VTNH) TOUCH EDGE GATE 
  Y = ENC X VTNH < 0.12 ABUT<90 REGION OPPOSITE
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
 }
VTNH_5 {
@ Min Space between VTNH and MOS AA of other device along other device's gate poly length direction excluding SRAM region is 0.12
  X1 = NACT TOUCH EDGE (AA INSIDE EDGE GT)
  X2 = PACT TOUCH EDGE (AA INSIDE EDGE GT)
  X = X1 OR EDGE X2
  ((EXT X VTNH < 0.12 ABUT<90 REGION OPPOSITE) NOT INSIDE INST) NOT INSIDE EXDRC
}
VTNH_6 {
@ Min VTNH extension outside of gate along S/D direction is 0.185
  X = (GT INSIDE EDGE (NACT AND VTNH)) COIN EDGE GATE
  Y = EXPAND EDGE X OUTSIDE BY 0.185
  (Y NOT VTNH) NOT INSIDE EXDRC
}
VTNH_7 {
@ Min Space between VTNH and gate of other device along other device's S/D direction is 0.185
  X = (GT INSIDE EDGE (AA NOT VTNH)) COIN EDGE GATE
  (EXT X VTNH < 0.185 ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
}
VTNH_8 {
@ Min VTNH area is 0.18
  ((AREA VTNH < 0.18) NOT INSIDE INST) NOT INSIDE EXDRC
}
VTNH_9 {
@ Min enclosed area is 0.1
  (AREA ((HOLES VTNH INNER) NOT VTNH) < 0.1) NOT INSIDE EXDRC
}
//===============================
//   VTPH: High Vt PMOS Implant
//===============================

GROUP GVTPH VTPH_?

VTPH_1 {
@ Min VTPH width is 0.18.Single-point-interaction is allowed.
  (INT VTPH < 0.18 ABUT<90 REGION) NOT INSIDE EXDRC
}
VTPH_2 {
@ Min Space between two VTPHs is 0.18
  (EXT VTPH < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE EXDRC
}
VTPH_3 {
@ VTPH overlap with PSUB, N+ active AA(exclude pick-up AA), VTNH, DG or TG are not allowed
  (AND VTPH PSUB) NOT INSIDE EXDRC
  (AND VTPH (NACT NOT (NTAP OR PTAP))) NOT INSIDE EXDRC
  (AND VTPH VTNH) NOT INSIDE EXDRC
  (AND VTPH DG) NOT INSIDE EXDRC
  (AND VTPH TG) NOT INSIDE EXDRC
}
VTPH_4 {
@ Min VTPH extension outside of MOS AA along gate poly length direction is 0.12
  X = (PACT AND VTPH) TOUCH EDGE GATE
  Y = ENC X VTPH < 0.12 ABUT<90 REGION OPPOSITE
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
VTPH_5 {
@ Min Space between VTPH and MOS AA of other device along other device's gate poly length direction excluding SRAM region is 0.12
  X1 = PACT TOUCH EDGE (AA INSIDE EDGE GT)
  X2 = NACT TOUCH EDGE (AA INSIDE EDGE GT)
  X = X1 OR EDGE X2
  ((EXT X VTPH < 0.12 ABUT<90 REGION OPPOSITE) NOT INSIDE INST)NOT INSIDE EXDRC
  }
VTPH_6 {
@ Min VTPH extension outside of gate along S/D direction is 0.185
  X = (GT INSIDE EDGE (PACT AND VTPH)) COIN EDGE GATE
  Y = EXPAND EDGE X OUTSIDE BY 0.185
  (Y NOT VTPH) NOT INSIDE EXDRC
}
VTPH_7 {
@ Min Space between VTPH and gate of other device along other device's S/D direction is 0.185
  X = (GT INSIDE EDGE AA) COIN EDGE GATE
  (EXT X VTPH < 0.185 ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
}
VTPH_8 {
@ Min VTPH area is 0.18
  ((AREA VTPH < 0.18) NOT INSIDE INST) NOT INSIDE EXDRC
}
VTPH_9 {
@ Min enclosed area is 0.1
  (AREA ((HOLES VTPH INNER) NOT VTPH)< 0.1) NOT INSIDE EXDRC
}


//===========================================
//  LVN: low Vt NMOS design minima (optional)
//===========================================

GROUP GLVN LVN_?

LVN_1 {
@ Min LVN width is 0.18.. Single-point-interaction is allowed.
  (INT LVN < 0.18 ABUT<90 REGION) NOT INSIDE EXDRC
}
LVN_2 {
@ Min Space between LVNs is 0.18
  (EXT LVN < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE EXDRC
}
LVN_3 {
@ LVN overlap with PSUB, P+ active AA(exclude pick-up AA), LVP, DG or TG are not allowed
  (AND LVN PSUB) NOT INSIDE EXDRC
  (AND LVN (PACT NOT (NTAP OR PTAP))) NOT INSIDE EXDRC
  (AND LVN LVP) NOT INSIDE EXDRC
  (AND LVN DG) NOT INSIDE EXDRC
  (AND LVN TG) NOT INSIDE EXDRC
}
LVN_4 {
@ Min LVN extension outside of MOS AA along gate poly length direction is 0.12
  X = (NACT AND LVN) TOUCH EDGE GATE
  (ENC X LVN < 0.12 ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
}
LVN_5 {
@ Min Space between LVN and MOS AA of other device along other device's gate poly length direction is 0.12
  X1 = NACT TOUCH EDGE (AA INSIDE EDGE GT)
  X2 = PACT TOUCH EDGE (AA INSIDE EDGE GT)
  X = X1 OR EDGE X2
  (EXT X LVN < 0.12 ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
}
LVN_6 {
@ MIN LVN extension outside of gate along S/D direction is 0.185
  X = GT INSIDE EDGE (NACT AND LVN)
  Y = EXPAND EDGE X OUTSIDE BY 0.185
  (Y NOT LVN) NOT INSIDE EXDRC
 // (ENC GATE_W LVN < 0.185 ABUT<90 REGION) NOT INSIDE EXDRC
}
LVN_7 {
@ Min Space between LVN and gate poly of other device along other device's S/D direction is 0.185
  X1 = GT INSIDE EDGE (NACT NOT LVN)
  X2 = GT INSIDE EDGE (PACT NOT LVN)
  X = X1 OR EDGE X2
  (EXT LVN X < 0.185 ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
//(EXT GATE_W LVN < 0.185 ABUT<90 REGION) NOT INSIDE EXDRC
}
LVN_8 {
@ Min LVN area is 0.18
  (AREA LVN < 0.18) NOT INSIDE EXDRC
}
LVN_9 {
@ Min enclosed area is 0.1
  (AREA ((HOLES LVN INNER) NOT LVN)< 0.1) NOT INSIDE EXDRC
}


//============================================
//  LVP:  low Vt PMOS design minima (optional)
//============================================

GROUP GLVP LVP_?

LVP_1 {
@ Min LVP width is 0.18. Single-point-interaction is allowed.
  (INT LVP < 0.18 ABUT<90 REGION) NOT INSIDE EXDRC
}
LVP_2 {
@ Min Space between two LVPs is 0.18
  (EXT LVP < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE EXDRC
}
LVP_3 {
@ LVP overlap with PSUB, N+ active AA(exclude pick-up AA), LVN, DG or TG are not allowed
  (AND LVP PSUB) NOT INSIDE EXDRC
  (AND LVP (NACT NOT (NTAP OR PTAP))) NOT INSIDE EXDRC
  (AND LVP DG) NOT INSIDE EXDRC
  (AND LVP TG) NOT INSIDE EXDRC
  (AND LVP LVN) NOT INSIDE EXDRC
}
LVP_4 {
@ Min LVP extension outside of MOS AA along gate poly length direction is 0.12
  X = (PACT AND LVP) TOUCH EDGE GATE
  (ENC X LVP < 0.12 ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
}
LVP_5 {
@ Min Space between LVP and MOS AA of other device along other device's gate poly length direction is 0.12
  X1 = PACT TOUCH EDGE (AA INSIDE EDGE GT)
  X2 = NACT TOUCH EDGE (AA INSIDE EDGE GT)
  X = X1 OR EDGE X2
  (EXT X LVP < 0.12 ABUT<90  REGION OPPOSITE) NOT INSIDE EXDRC
}

LVP_6 {
@ Min LVP extension outside of gate along S/D direction is 0.185
  X = GT INSIDE EDGE (PACT AND LVP)
  Y = EXPAND EDGE X OUTSIDE BY 0.185
  (Y NOT LVP) NOT INSIDE EXDRC
  //(ENC GATE_W LVP < 0.185 ABUT<90 REGION) NOT INSIDE EXDRC
}
LVP_7 {
@ Min Space between LVP and gate of other device along other device's S/D direction is 0.185
  X1 = GT INSIDE EDGE (PACT NOT LVP)
  X2 = GT INSIDE EDGE (NACT NOT LVP)
  X = X1 OR EDGE X2
  (EXT LVP X < 0.185 ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
  //(EXT GATE_W LVP < 0.185 ABUT<90 REGION) NOT INSIDE EXDRC
}
LVP_8 {
@ Min LVP area is 0.18
  (AREA LVP < 0.18) NOT INSIDE EXDRC
}
LVP_9 {
@ Min enclosed area is 0.1
  (AREA ((HOLES LVP INNER) NOT LVP)< 0.1) NOT INSIDE EXDRC
}


//===============================
// UHVT-- Ultra Low Leakage(ULL)  
//===============================

GROUP GUHVT UHVT_?

UHVT_1 {
@ UHVT width is >= 0.18um,single-point-interaction is allowed.
  (INT UHVT <0.18 ABUT<90 REGION) NOT INSIDE EXDRC 
}

UHVT_2 {
@ Space between two UHVTs >= 0.18um,single-point-interaction is allowed.
  (EXT UHVT <0.18 ABUT<90 REGION) NOT INSIDE EXDRC
}

UHVT_3a {
@ UHVT enclosure of MOS AA along GATE poly length direction >= 0.16um.
@ if the distance to the related poly is less than or qual to 0.20um.
@ DRC waive AA jog, only check the AA edge which aligned with GATE edge.
  LAY_POLY = COPY GTi
  ACT = PACT OR NACT
  X1 = ACT INSIDE EDGE LAY_POLY
  X2 = AA TOUCH EDGE X1
  X3 = EXPAND EDGE X1 OUTSIDE BY 0.001 EXTEND BY 0.20
  X4 = X2 COIN EDGE X3
 (ENC X4 UHVT < 0.16 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXDRC
}

UHVT_3b {
@ UHVT enclosure of MOS AA along GATE poly length direction >= 0.12um.
@ if the distance to the related poly is larger than 0.20um.
@ DRC waive AA jog, only check the AA edge which aligned with GATE edge.
  LAY_POLY = COPY GTi
  ACT = PACT OR NACT
  X1 = ACT INSIDE EDGE LAY_POLY
  X2 = AA TOUCH EDGE X1
  X3 = EXPAND EDGE X1 OUTSIDE BY 0.001 EXTEND BY 0.20
  X4 = X2 NOT COIN EDGE X3
  (ENC X4 UHVT < 0.12 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXDRC
}


UHVT_3c {
@ UHVT enclosure of AA is >= 0.02um
  (ENC AA UHVT < 0.02 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

UHVT_4 {
@ GATE enclosure by UHVT along source/drain direction >= 0.185um.
  LAY_POLY = COPY GTi
  ACT = PACT OR NACT
  X1 = LAY_POLY INSIDE EDGE ACT
  (ENC X1 UHVT < 0.185 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXDRC
}

UHVT_5 {
@UHVT area >= 0.1um2
(AREA UHVT < 0.1) NOT INSIDE EXDRC 
}

UHVT_6a {
@ Space between UHVT and MOS AA along GATE poly length direction is >= 0.16um.
@ DRC waive AA jog, only check the AA edge which aligned with GATE edge.
  LAY_POLY = COPY GTi
  ACT = PACT OR NACT
  X1 = ACT INSIDE EDGE LAY_POLY
  X2 = AA TOUCH EDGE X1
  (EXT X2 UHVT < 0.16 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXDRC
}

UHVT_6b {
@ Space between UHVT and MOS AA >=0.055um.
  X = AA INTERACT GT
  (EXT UHVT X < 0.055 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

UHVT_6c {
@ Space between UHVT and AA >= 0.02um
  (EXT UHVT AA < 0.02 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

UHVT_7 {
@ Space between UHVT and GATE of other device along other device's source/drain direction >= 0.185um.
  LAY_POLY = COPY GTi
  ACT = PACT OR NACT
  X1 = LAY_POLY INSIDE EDGE ACT
  (EXT X1 UHVT < 0.185 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXDRC
}


//============================
//   DG - Dual Gate DRC
//============================

GROUP GDG DG_?

DG_1 {
@ Min DG width is 0.46
  (INT DG < 0.46 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_2 {
@ Min Space between two DGs is 0.46, merge if the space is less than 0.46um
  (EXT DG < 0.46 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_3 {
@ Min Enclosure of AA by DG(Except pick-up AA) is 0.25
  //ENC MOS DG < 0.25 ABUT<90 SINGULAR REGION
  (ENC (AA NOT (NTAP OR PTAP)) DG < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_4 {
@ Min Enclosure of MOS AA by DG along gate poly direction is 0.27
  /*GATE_DG4_E = GATE COIN EDGE GT

  GATE_DG4_E_V = ANGLE GATE_DG4_E == 90
  GATE_DG4_B_V = EXPAND EDGE GATE_DG4_E_V INSIDE BY 0.001
  MOS_AA_H = AA ENCLOSE GATE_DG4_B_V
  MOS_AA_H_E = ANGLE MOS_AA_H == 0
  (ENC MOS_AA_H_E DG < 0.27 ABUT < 90 REGION) NOT INSIDE EXDRC
  
  GATE_DG4_E_H = ANGLE GATE_DG4_E == 0
  GATE_DG4_B_H = EXPAND EDGE GATE_DG4_E_H INSIDE BY 0.001
  MOS_AA_V = AA ENCLOSE GATE_DG4_B_H
  MOS_AA_V_E = ANGLE MOS_AA_V == 90
  (ENC MOS_AA_V_E DG < 0.27 ABUT < 90 REGION) NOT INSIDE EXDRC*/
  X = MOS TOUCH EDGE (GATE INSIDE DG)
  ENC X DG < 0.27 ABUT<90 REGION
}
DG_5 {
@ Min Space between DG and MOS AA is 0.25
  (EXT DG MOS < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  (EXT DG AA_LDMOS < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
/*
DG_6 {
@ Min Space between DG and 1.2/2.5/3.3 gate along source/drain direction is 0.24
  X = GATE_M_W OR EDGE GATE_T_W
  (EXT DG X < 0.24 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
}
*/
DG_8 {
@ Min Enclosure of NW beyond DG is 0.46um, set the value to 0 if the enclosure is less than 0.46um
  (ENC DG NW > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_9 {
@ Min Space or extension of DG to NW is 0.46um, set the value to 0 if the value is smaller than 0.46um
  (ENC NW DG > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
  (EXT NW DG > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_10 {
@ Min Overlap of DG and NW is 0.46um, set the value to 0 if the value is smaller than 0.46um
  (INT DG NW > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_11_a {
@ Min Enclosure of DG beyond PSUB is 0.32um. Set the value to 0 if the value is smaller than 0.32um
  (ENC PSUB DG > 0 < 0.32 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_11_b {
@ Min Space of PSUB to DG is 0.32um. Set the value to 0 if the value is smaller than 0.32um
  (EXT PSUB DG > 0 < 0.32 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_11_c {
@ Min Extension of PSUB to DG is 0.32um. Set the value to 0 if the value is smaller than 0.32um
  (ENC DG PSUB > 0 < 0.32 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_11_d {
@ Min Overlap of PSUB and DG is 0.32um. Set the value to 0 if the value is smaller than 0.32um
  (INT DG PSUB > 0 < 0.32 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
DG_12 {
@ Min Enclosure of gate by DG along source/drain direction is 0.33
  (ENC GATE_W DG < 0.33 ABUT<90  REGION OPPOSITE) NOT INSIDE EXDRC
}
DG_13 {
@ Min Space between DG and 1.0/1.2V/2.5V/3.3V gate along source/drain direction is 0.33
  X = GATE_M_W OR EDGE GATE_T_W
  (EXT DG X < 0.33 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
  //EXT GATE_M_W DG < 0.33 ABUT<90  REGION OPPOSITE
}

//==========================
//   TG - Triple Gate DRC
//==========================

GROUP GTG TG_? 

TG_1 {
@ Min TG width is 0.46
  (INT TG < 0.46 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
TG_2 { 
@ Min Space between two TGs, merge if the space is less than 0.46 
  (EXT TG < 0.46 ABUT<90 SINGULAR REGION ) NOT INSIDE EXDRC
} 
TG_3 { 
@ Min Enclosure of AA by TG(except pickup AA) is 0.25 
  ENC MOS TG < 0.25 ABUT<90 SINGULAR REGION

  X = (STIDMY AND LDBK) INTERACT GT
  Y = AA TOUCH X
  (ENC Y TG < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  //(ENC (AA NOT (NTAP OR PTAP)) TG < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
} 
TG_4 { 
@ Min Enclosure of MOS AA by TG along gate poly direction is 0.27
  X = MOS TOUCH EDGE (GATE INSIDE TG)
  (ENC X TG < 0.27 ABUT<90 REGION) NOT INSIDE EXDRC
}
TG_5 { 
@ Min Space between TG and MOS AA is 0.25 
  (EXT TG MOS < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  (EXT TG AA_LDMOS < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
/*
TG_6 { 
@ Min Space between TG and 1.2/1.8V gate along S/D direction is 0.24
  X = GATE_M_W OR EDGE GATE_D_W 
  (EXT TG X < 0.24 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
}
*/
TG_7 {
@ Min Space between TG and DG is 0.46
  (EXT TG DG < 0.46 ABUT<90 SINGULAR REGION INSIDE ALSO ) NOT INSIDE EXDRC
}
TG_9 {
@ Min Enclosure of NW beyond TG is 0.46um, set the value to 0 if the enclosure is less than 0.46um
  (ENC TG NW > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
TG_10 {
@ Min Space or extension of TG to NW is 0.46um, set the value to 0 if the value is smaller than 0.46um
  (ENC NW TG > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
  (EXT NW TG > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
TG_11 {
@ Min Overlap of TG and NW is 0.46um, set the value to 0 if the value is smaller than 0.46um
  (INT TG NW > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
TG_12_a {
@ Min Enclosure of TG beyond PSUB is 0.32um, set the value to 0 if the value is smaller than 0.32um
  (ENC PSUB TG > 0 < 0.32 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
TG_12_b {
@ Min Space of PSUB to TG is 0.32um, set the value to 0 if the value is smaller than 0.32um
  (EXT PSUB TG > 0 < 0.32 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
TG_12_c {
@ Min Extension of PSUB to TG is 0.32um, set the value to 0 if the value is smaller than 0.32um
  (ENC TG PSUB > 0 < 0.32 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
TG_12_d {
@ Min overlap of PSUB and TG is 0.32um, set the value to 0 if the value is smaller than 0.32um
  (INT TG PSUB > 0 < 0.32 ABUT>0<90 SINGULAR REGION) NOT INSIDE EXDRC
}
TG_13 {
@ Min Enclosure of gate by TG along source/drain direction is 0.33um
  (ENC GATE_W TG < 0.33 ABUT<90  REGION OPPOSITE ) NOT INSIDE EXDRC 
}
TG_14 {
@ Min Space between TG and 1.0/1.2/1.8V gate along source/drain direction is 0.33
//  X1 = (GT IN EDGE AA) NOT INSIDE EDGE TG
//  EXT X1 TG < 0.33 ABUT<90  REGION OPPOSITE
  X = GATE_M_W OR EDGE GATE_D_W 
  (EXT TG X < 0.33 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
}

}


#//==========================
#//    GT - Poly Rule DRC
#//==========================

GROUP GGT GT_?

RULECHECK GT_1a {
@ Min Channel length for 1.0/1.2V NMOS /PMOS transistors is 0.06
SETLAYER X = GT INSIDE EDGE (AA NOT INTERACT (DG OR TG))
OUTLAYER (INT X < 0.06 ABUT<90 REGION) NOT INSIDE EXDRC
#OUTLAYER (LENGTH GATE_M_L < 0.06) NOT INSIDE EDGE EXDRC
}
RULECHECK GT_1b {
@ Min Channel length for 1.8V NMOS/PMOS transistors is 0.20
SETLAYER X = GT INSIDE EDGE (AA AND DG )
SETLAYER Y = INT X < 0.20  ABUT<90 REGION
OUTLAYER (Y NOT INSIDE INST) NOT INSIDE EXDRC
#OUTLAYER ((LENGTH GATE_D_L < 0.20) NOT INSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
if { $IO == 1825 } {
RULECHECK GT_1c  {
@ Min Channel length for 2.5V NMOS/PMOS transistors is 0.28
SETLAYER X = GT INSIDE EDGE ((AA AND TG) NOT INTERACT UNDEPL)
SETLAYER Y = INT X < 0.28  ABUT<90 REGION
OUTLAYER (Y NOT INSIDE INST) NOT INSIDE EXDRC
#OUTLAYER ((LENGTH GATE_T_L < 0.28) NOT INSIDE EDGE (UNDEPL OR INST)) NOT INSIDE EDGE EXDRC
}
}

if { $IO == 1833 } {
RULECHECK GT_1d {
@ Min Channel length for 3.3V NMOS/PMOS transistors is 0.38
SETLAYER X = GT INSIDE EDGE (AA AND TG)  
SETLAYER Y = INT X < 0.38 ABUT<90 REGION
OUTLAYER (Y NOT INSIDE INST) NOT INSIDE EXDRC
#OUTLAYER ((LENGTH GATE_T_L < 0.38) NOT INSIDE EDGE INST ) NOT INSIDE EDGE EXDRC
}
}

if { $IO == 1825 } {
RULECHECK GT_1e {
@ Min Channel length for 2.5V NMOS/PMOS transistors (over drive to 3.3V and 4.1V) is 0.50(NMOS) and 0.40(PMOS).
SETLAYER X = GT INSIDE EDGE ((NACT AND TG) AND OVERPL)
SETLAYER Y = GT INSIDE EDGE ((PACT AND TG) AND OVERPL)
SETLAYER Z1 = INT X < 0.50  ABUT<90 REGION
SETLAYER Z2 = INT Y < 0.40  ABUT<90 REGION
OUTLAYER (Z1 NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER (Z2 NOT INSIDE INST) NOT INSIDE EXDRC
#OUTLAYER ((LENGTH ((GATE_T AND SN) AND OVERPL) < 0.5) NOT INSIDE EDGE INST ) NOT INSIDE EDGE EXDRC
#OUTLAYER ((LENGTH ((GATE_T AND SP) AND OVERPL) < 0.4) NOT INSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
RULECHECK GT_1f {
@ Min Channel length for 2.5V NMOS/PMOS transistors (under drive to 1.8V) is 0.22
SETLAYER X = GT INSIDE EDGE ((AA AND TG) AND UNDEPL)
SETLAYER Y = INT X < 0.22 ABUT<90 REGION
OUTLAYER (Y NOT INSIDE INST) NOT INSIDE EXDRC
#OUTLAYER ((LENGTH (GATE_T_L INSIDE EDGE UNDEPL) < 0.22) NOT INSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
}

RULECHECK GT_2 {
@ Min Width of interconnect poly is 0.06
#OUTLAYER INT GTDUM < 0.06 REGION
OUTLAYER (INT (INTERGT NOT COIN EDGE GATE) < 0.06 ABUT<90 REGION) NOT INSIDE EXDRC
#OUTLAYER (INT GT00 < 0.06 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK GT_3a {
@ Min Space between two GTs is 0.12.
@ DRC waive check the INDMY covered region.
SETLAYER X = EXT GT < 0.12 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDRC
#OUTLAYER EXT GTDUM < 0.12 REGION
#SETLAYER Y = EXT GTDUM GTi < 0.12 REGION INSIDE ALSO
#OUTLAYER (Y NOT INSIDE INST) NOT INSIDE INDMY
}
RULECHECK GT_3b {
@ Min Space between two GTs is 0.16 when one or both GT width is >= 0.4um,and the run length of two GTs is >=0.5um.
SETLAYER GT_W = WITH WIDTH GT >= 0.4
SETLAYER GT_S = EXT GT_W GT < 0.16 OPPOSITE REGION PARA ONLY
SETLAYER GT_LS = LENGTH GT_S >= 0.5
OUTLAYER (GT_S WITH EDGE GT_LS) NOT INSIDE EDGE EXDRC

#SETLAYER GTDUM_W = WITH WIDTH GTDUM >= 0.4
#SETLAYER GTDUM_S = EXT GTDUM_W (GTi OR GTDUM) < 0.16 OPPOSITE REGION PARA ONLY
#SETLAYER GTDUM_LS = LENGTH GTDUM_S >= 0.5
#OUTLAYER GTDUM_S WITH EDGE GTDUM_LS
}

RULECHECK GT_3e {
@ Min Space between GTs on AA is 0.13,DRC waive check the INDMY covered region.
SETLAYER X = (AA AND GT) COIN EDGE GT
SETLAYER Y = EXT X < 0.13 ABUT < 90 REGION
OUTLAYER (Y NOT INSIDE INDMY) NOT INSIDE EXDRC
}

LAYER MAP 999 DATATYPE 1111 4321
LAYER EMPTY 4321
SETLAYER GT_EMPTY = EMPTY OR (GT AND AA)
SETLAYER AA_EMPTY = EMPTY OR AA
CONNECT GT_EMPTY AA_EMPTY

if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK GT_3c_R {
@ Min Recommended space between GTs on the same AA is 0.19
@ NOTICE: It is a recommended rule.
@ DRC waive check if no contacts between two GTs, and waive check the INDMY covered region.
SETLAYER X = EXT GT_EMPTY < 0.19 ABUT<90 SINGULAR REGION CONNECTED
#OUTLAYER (X NOT INSIDE INST) NOT INSIDE INDMY
SETLAYER Y = X INTERACT CT
OUTLAYER (Y NOT INSIDE (INDMY OR INST) ) NOT INSIDE EXDRC
}

RULECHECK GT_3d_R {
@ Min Recommended space between GTs on the same AA inside TG is 0.24
@ NOTICE: It is a recommended rule.
@ DRC waive check if no contacts between two GTs, and waive check the INDMY covered region.
SETLAYER X = EXT (GT_EMPTY AND TG) < 0.24 ABUT<90 SINGULAR REGION CONNECTED
SETLAYER Y = X INTERACT CT
OUTLAYER (Y NOT INSIDE (INDMY OR INST)) NOT INSIDE EXDRC
}
}

RULECHECK GT_4 {
@ Space between AA and GT on field oxide is 0.05
@ DRC waive check the INDMY covered region.
#SETLAYER X = AA INSIDE EDGE GT
#SETLAYER Y = AA NOT COIN EDGE X
#SETLAYER A = EXT Y INTERGT < 0.05 ABUT<90 REGION
#OUTLAYER (A NOT INSIDE INST) NOT INSIDE INDMY
#SETLAYER B = EXT AAi GTDUM < 0.05 REGION INSIDE ALSO
#OUTLAYER (B NOT INSIDE INST) NOT INSIDE INDMY
#SETLAYER C = EXT GTi AADUM < 0.05 REGION INSIDE ALSO
#OUTLAYER (C NOT INSIDE INST) NOT INSIDE INDMY
SETLAYER X = EXT AA GT < 0.05 ABUT<90 SINGULAR REGION
OUTLAYER ((X NOT INSIDE (AA OR AADUM)) NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDRC
}

SETLAYER AAconer = EXT AA <0.01 ABUT == 90 INTERSECTING ONLY REGION
SETLAYER GTconer = EXT GT < 0.01 ABUT == 90 INTERSECTING ONLY REGION

#RULECHECK GT_4a {
#@ Min space between L-shape AA to GT in the same MOS when channel width >= 0.16um is 0.07.
#SETLAYER GT_CHECK = EXPAND EDGE (LENGTH GATE_W >= 0.16) INSIDE BY 0.001 
#SETLAYER GTmergeAA = (GT OR AA) INTERACT GT_CHECK
#SETLAYER U_edge = CONVEX EDGE GTmergeAA ANGLE1 == 270 ANGLE2 == 270
#SETLAYER U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001
#
#SETLAYER LAA_ = U_edge_ TOUCH AAconer == 1
#SETLAYER LAA = U_edge COIN EDGE LAA_
#SETLAYER X = LENGTH LAA  <  0.07
#OUTLAYER (X COIN EDGE (AA TOUCH EDGE GATE)) NOT INSIDE EDGE EXDRC
#}
#RULECHECK GT_4b {
#@ Min space between L-shape AA to GT in the same MOS when channel width <0.16um is 0.1.
#SETLAYER GT_CHECK = EXPAND EDGE (LENGTH GATE_W < 0.16) INSIDE BY 0.001 
#SETLAYER GTmergeAA = (GT OR AA) INTERACT GT_CHECK
#SETLAYER U_edge = CONVEX EDGE GTmergeAA ANGLE1 == 270 ANGLE2 == 270
#SETLAYER U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001
#
#SETLAYER LAA_ = U_edge_ TOUCH AAconer == 1
#SETLAYER LAA = U_edge COIN EDGE LAA_
#SETLAYER X = LENGTH LAA  <  0.1
#OUTLAYER (X COIN EDGE (AA TOUCH EDGE GATE)) NOT INSIDE EDGE EXDRC
#}
#RULECHECK GT_4c {
#@ Min space between L-shape GT to AA in the same MOSwhen channel width >= 0.16um is 0.07.
#SETLAYER GT_CHECK = EXPAND EDGE (LENGTH GATE_W >= 0.16) INSIDE BY 0.001
#SETLAYER GTmergeAA = (GT OR AA) INTERACT GT_CHECK
#SETLAYER U_edge = CONVEX EDGE GTmergeAA ANGLE1 == 270 ANGLE2 == 270
#SETLAYER U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001
#
#SETLAYER LGT_ = U_edge_ TOUCH GTconer == 1
#SETLAYER LGT = U_edge COIN EDGE LGT_
#OUTLAYER ((LENGTH LGT < 0.07) TOUCH EDGE (EXPAND EDGE GT_CHECK OUTSIDE BY 0.001)) NOT INSIDE EDGE EXDRC
#}
#RULECHECK GT_4d {
#@ Min space between L-shape GT to AA in the same MOS when channel width < 0.16um is 0.1.
#SETLAYER GT_CHECK = EXPAND EDGE (LENGTH GATE_W < 0.16) INSIDE BY 0.001
#SETLAYER GTmergeAA = (GT OR AA) INTERACT GT_CHECK
#SETLAYER U_edge = CONVEX EDGE GTmergeAA ANGLE1 == 270 ANGLE2 == 270
#SETLAYER U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001
#
#SETLAYER LGT_ = U_edge_ TOUCH GTconer == 1
#SETLAYER LGT = U_edge COIN EDGE LGT_
#OUTLAYER ((LENGTH LGT < 0.1) TOUCH EDGE (EXPAND EDGE GT_CHECK OUTSIDE BY 0.001)) NOT INSIDE EDGE EXDRC
#}

RULECHECK GT_5 {
@ Min Extension of AA outside of GT(not include dummy AA and dummy Poly) is 0.115
SETLAYER X = ENC GT (AA NOT COIN EDGE STIDMY) < 0.115 ABUT<90 REGION OPPOSITE
OUTLAYER ((X NOT INSIDE INST) NOT INSIDE INDMY) NOT INSIDE EXDRC
}

RULECHECK GT_6 {
@ Min Extension of poly outside of AA (not including dummy AA and dummy poly) is 0.14,DRC waive if extension GT with jog
@ DRC don't flag the INDMY and LDBK covered region
#SETLAYER X = AA INSIDE EDGE GT
SETLAYER Y = ENC AA GT < 0.14 ABUT<90 opposite REGION
SETLAYER Z = EXT GT < 0.002 ABUT==90 REGION INTERSECTING ONLY
OUTLAYER ((((Y NOT TOUCH Z) NOT INSIDE INST) NOT INSIDE INDMY) NOT INSIDE LDBK) NOT INSIDE EXDRC
}

if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK GT_6_R {
@ Min Extension of poly outside of AA (not including dummy AA and dummy poly) is 0.14
@ DRC don't flag the INDMY and LDBK covered region
#SETLAYER X = AA INSIDE EDGE GT
#SETLAYER Y = ENC X GT < 0.14 ABUT<90 opposite REGION
#SETLAYER Z = EXT GT < 0.002 ABUT==90 REGION INTERSECTING ONLY
#OUTLAYER ((Y NOT TOUCH Z) NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER ((((ENC AA GT < 0.14 ABUT<90 opposite REGION) NOT INSIDE INST) NOT INSIDE INDMY) NOT INSIDE LDBK) NOT INSIDE EXDRC
}

#RULECHECK GT_6a_R {
#@ Min GT end-cap extension of AA is 0.16um when:
#@ 1. GT space to L-shape AA in the same MOS is < 0.1um
#@ 2. GATE channel width (W) is >= 0.15um
#@ DRC only check the L-shape opposite side GT end-cap.
#SETLAYER GT_CHECK = EXPAND EDGE (LENGTH GATE_W >= 0.15) INSIDE BY 0.001 
#SETLAYER GTmergeAA = (GT OR AA) INTERACT GT_CHECK
#SETLAYER U_edge = CONVEX EDGE GTmergeAA ANGLE1 == 270 ANGLE2 == 270
#SETLAYER U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001

#SETLAYER LAA_ = U_edge_ TOUCH AAconer == 1
#SETLAYER LAA_edge = LAA_ COIN EDGE AA
#SETLAYER LAA = U_edge COIN EDGE LAA_edge
#SETLAYER X = LENGTH LAA  <  0.1
#SETLAYER Y = LENGTH (X COIN EDGE (AA TOUCH EDGE GATE)) < 0.1
#SETLAYER AA_CHECK = (AA INTERACT GT_CHECK) TOUCH EDGE Y
#SETLAYER GT_END = (GT INTERACT (GTmergeAA WITH EDGE Y)) NOT COIN EDGE GATE
##SETLAYER Z = (EXPAND EDGE (GATE_L COIN EDGE AA_CHECK) INSIDE BY 0.001) TOUCH EDGE (EXPAND EDGE X INSIDE BY 0.001)
#SETLAYER AA_CHECK_region = EXPAND EDGE AA_CHECK INSIDE BY 0.001 
#SETLAYER Z = (EXPAND EDGE X INSIDE BY 0.001) TOUCH EDGE (GATE_W INSIDE EDGE AA_CHECK_region)
##SETLAYER Z1 = (GATE_L COIN EDGE AA_CHECK) TOUCH EDGE (EXPAND EDGE Z INSIDE BY 0.001)
#SETLAYER Z11 = (EXPAND EDGE Z OUTSIDE BY 0.001) TOUCH EDGE (GATE_L COIN EDGE AA_CHECK)
#SETLAYER Z1 = (GATE_L COIN EDGE AA_CHECK) TOUCH EDGE Z11
#OUTLAYER ((ENC Z1 GT_END < 0.16 ABUT<90 REGION) TOUCH GT_CHECK)NOT INSIDE EXDRC
#}


RULECHECK GT_6a_R {
@ Min GT end-cap extension of AA is 0.16um when:
@ 1. GT space to L-shape AA in the same MOS is < 0.1um
@ 2. GATE channel width (W) is >= 0.15um
@ DRC only check the L-shape opposite side GT end-cap.
 SETLAYER A = ENC AA GT < 0.16 OPPOSITE REGION
 SETLAYER X = LENGTH GATE_W >= 0.15
 SETLAYER Y = GATE WITH EDGE X
 SETLAYER B = EXT \[Y\] AA < 0.1 ABUT==90 PERP ONLY   
 OUTLAYER (A WITH EDGE (A TOUCH EDGE B)) NOT INSIDE EXDRC
}
}

RULECHECK GT_7a_Min {
@ Min Local GT density (including dummy) in 200um*200um  window with step size: 100um is 7%
OUTLAYER (DENSITY GT_all < 0.07 WINDOW 200 STEP 100 BACKUP PRINT density_report_GT7a_min.log) NOT INSIDE EXDRC
}
RULECHECK GT_7a_Max {
@ Max Local GT density (including dummy) in 200um*200um  window with step size: 100um is 70%
OUTLAYER (DENSITY GT_all > 0.70 WINDOW 200 STEP 100 BACKUP PRINT density_report_GT7a_max.log) NOT INSIDE EXDRC
}

RULECHECK GT_7b_Min {
@ Min Global GT density for fully chip (including dummy) is 10%
OUTLAYER (DENSITY GT_all < 0.10 PRINT density_report_GT7b_min.log) NOT INSIDE EXDRC
}
RULECHECK GT_7b_Max {
@ Max Global GT density for fully chip (including dummy) is 45%
OUTLAYER (DENSITY GT_all > 0.45 PRINT density_report_GT7b_max.log) NOT INSIDE EXDRC
}

RULECHECK GT_7c {
@ Min GT density inside of dummy block area is 10%, while the area of dummy block layer is larger than 2500um2 (50X50um).
SETLAYER X = AREA (DUMBP OR NODMF) > 2500
OUTLAYER (DENSITY GT_all < 0.10 INSIDE OF LAYER X PRINT density_report_GT7c.log) NOT INSIDE EXDRC
}


RULECHECK GT_8 {
@ No bent GT on AA is allowed.All GT patterns on AA have to be orthogonal to AA edage.
@ DRC waive check the INDMY and INST covered region, and waive check (AA AND GT) width <= 0.01um pattern.
#SETLAYER GTEIAA1 = GTEIAA COIN EDGE (GATE WITH WIDTH > 0.01)
SETLAYER GTEIAA1 = GTEIAA COIN EDGE ((GT AND AA) WITH WIDTH > 0.01)
SETLAYER GTEIAA = GT IN EDGE AA
OUTLAYER ((INT GTEIAA1 < 0.01 ABUT == 90 REGION) NOT INSIDE (INDMY OR INST)) NOT INSIDE EXDRC
OUTLAYER ((EXT GTEIAA1 < 0.01 ABUT == 90 REGION) NOT INSIDE (INDMY OR INST)) NOT INSIDE EXDRC
OUTLAYER ((INT GTEIAA1 < 0.01 ABUT == 45 REGION) NOT INSIDE (INDMY OR INST)) NOT INSIDE EXDRC
OUTLAYER ((EXT GTEIAA1 < 0.01 ABUT == 45 REGION) NOT INSIDE (INDMY OR INST)) NOT INSIDE EXDRC
OUTLAYER ((INT GTEIAA1 < 0.01 ABUT == 135 REGION) NOT INSIDE (INDMY OR INST)) NOT INSIDE EXDRC
OUTLAYER ((EXT GTEIAA1 < 0.01 ABUT == 135 REGION) NOT INSIDE (INDMY OR INST)) NOT INSIDE EXDRC
#SETLAYER AAEIGT1 = (IN EDGE AA GT) COIN EDGE (GATE WITH WIDTH > 0.01)
SETLAYER AAEIGT1 = (IN EDGE AA GT) COIN EDGE ((GT AND AA) WITH WIDTH > 0.01)
OUTLAYER ((INT GTEIAA1 AAEIGT1 < 0.01 ABUT!=90 REGION) NOT INSIDE (INDMY OR INST)) NOT INSIDE EXDRC
}
RULECHECK GT_9a {
@ SN extension outside of poly resistor is 0.16um
SETLAYER X = ENC ((GT AND RESP1) AND SAB) SN < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
SETLAYER Y = ENC ((GT AND RESP1) NOT INTERACT SAB) SN < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK GT_9b {
@ SP extension outside of poly resistor is 0.16um
SETLAYER X = ENC ((GT AND RESP1) AND SAB) SP < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
SETLAYER Y = ENC ((GT AND RESP1) NOT INTERACT SAB) SP < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (Y NOT INSIDE INST) NOT INSIDE EXDRC
}

RULECHECK GT_10a {
@ Space between NLL/NLH/SN and a P- type poly resistor is 0.16um
SETLAYER X = (GTR AND SP) AND RESP1
SETLAYER Y1 = EXT NLL X < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (Y1 NOT INSIDE INST) NOT INSIDE EXDRC
SETLAYER Y2 = EXT NLH X < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (Y2 NOT INSIDE INST) NOT INSIDE EXDRC
SETLAYER Y3 = EXT SN X < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (Y3 NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK GT_10b {
@ Space between PLL/PLH/SP and a N- type poly resistor is 0.16um
SETLAYER X = (GTR AND SN) AND RESP1
SETLAYER Y1 = EXT PLL X < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (Y1 NOT INSIDE INST) NOT INSIDE EXDRC
SETLAYER Y2 = EXT PLH X < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (Y2 NOT INSIDE INST) NOT INSIDE EXDRC
SETLAYER Y3 = EXT SP X < 0.16 ABUT<90 SINGULAR REGION
OUTLAYER (Y3 NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK GT_11 {
@ GT is enclosed by SN and/or SP, except MOM and HRPDMY area (when checking the rule, size down the HRPDMY by 0.3um along the current direction).
SETLAYER HRPR = GT INTERACT HRPDMY
SETLAYER HRP_END = SIZE (HRPR NOT HRPDMY) BY 0.3
SETLAYER GT_MID = ( GT INTERACT (HRPDMY OR HRP)) NOT HRP_END
SETLAYER Y = ((((GT INTERACT CT) NOT GT_MID) NOT SP) NOT SN) NOT INTERACT MOMDMY
OUTLAYER (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK GT_12 {
@ SN and SP overlap on GT is not allowed
OUTLAYER ((GT AND SN) AND SP) NOT INSIDE EXDRC
}
RULECHECK GT_13 {
@ Min GT area is 0.038um, except INST region.
OUTLAYER ((AREA GT < 0.038) NOT INSIDE INST) NOT INSIDE EXDRC
}
RULECHECK GT_13a {
@ Min GT enclosed area is 0.05um
OUTLAYER (AREA ((HOLES GT INNER) NOT GT) < 0.05) NOT INSIDE EXDRC
}
RULECHECK GT_14 {
@ Min Width of 45 degree GT on STI is 0.19um
SETLAYER GT_CHECK = GT NOT INSIDE (AA OR AADUM)
SETLAYER X = ANGLE GT_CHECK == 45
OUTLAYER (INT X < 0.19 ABUT<90 REGION) NOT INSIDE EXDRC
}
RULECHECK GT_15 {
@ Min Space to 45-degree GT on STI is 0.19, except EFUSE region GT.
SETLAYER GT_CHECK = GT NOT INSIDE (OR EFUSE AA AADUM)
SETLAYER X = (ANGLE GT_CHECK == 45) NOT INSIDE EDGE EFUSE
OUTLAYER ((EXT X (GT NOT INSIDE EFUSE) < 0.19 ABUT<90 REGION) NOT INSIDE EFUSE) NOT INSIDE EXDRC
}

RULECHECK GT_16 {
@ Min GATE space when L-shape AA and L-shape GT enclosed area < 0.012 um2 is 0.15um.
SETLAYER X = AA_LS OR GT_LS
SETLAYER Y = AREA (HOLES X INNER) < 0.012
SETLAYER Z = GATE INTERACT Y SINGULAR ONLY
OUTLAYER ((EXT Z < 0.15 ABUT<90 REGION) INTERACT Y) NOT INSIDE EXDRC
}



RULECHECK GT_17 {
@ Space between large GT and GATE with narrow channel length <= 0.08 m is 1.0um.
@ The large GT definition:GT area >= 630um2 and within regions of density > 70% in window 30um x 30um, 
@ stepping 15um. Dummy poly doesn't  be included the density check.
SETLAYER  Density_region = DENSITY GTi > 0.7 WINDOW 30 STEP 15
SETLAYER  Large_GT = (AREA GTi >= 630) INSIDE Density_region
SETLAYER  GATE_check = GATE WITH EDGE (LENGTH GATE_LE <= 0.08)
SETLAYER  GATE_LE = (GATE TOUCH EDGE (INT GATE_W \[GATE\] < 0.005 ABUT INTERSECTING ONLY)) NOT COIN EDGE GATE_W
#SETLAYER  GATE_LE = GATE NOT COIN EDGE GATE_W
OUTLAYER  EXT Large_GT GATE_check < 1 ABUT<90 SINGULAR REGION 
}

if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK GT_18_R {
@ Min Space between GT dense line end to line (Dh) or GT line to line (Ds) is 0.14um when: 
@ 1. GT line end definition: GT width < 0.14µm
@ 2. Run length of GT line to line or GT line to end: E1 >= -0.03µm
@ 3. Any one edge distance from the corner of the two edges: K1 < 0.14µm
@ Any one of Dh or Ds meet this rule value is ok.
@ DRC waive check GT small extrusion F < 0.04µm and exclude SRAM region.
SETLAYER LINE_END = CONVEX EDGE GT ANGLE1 ==90 LENGTH1 >=0.04 ANGLE2  ==90 LENGTH2  >=0.04 WITH LENGTH  < 0.14
SETLAYER LINE_END_SHAPE1 = EXPAND EDGE LINE_END INSIDE BY 0.11
SETLAYER LINE_SIDE1 = (GT COIN EDGE LINE_END_SHAPE1 ) NOT COIN EDGE LINE_END
SETLAYER LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.14
SETLAYER LINE_SIDE = (GT COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
SETLAYER LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.03
SETLAYER LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE1 INSIDE BY 0.001 EXTEND BY 0.03
SETLAYER LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
SETLAYER LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
SETLAYER E1 = EXT \[LINE_END_1\] GT < 0.14 OPPOSITE PERP ALSO OBTUSE ALSO
SETLAYER E2 = EXT \[LINE_SIDE\] < 0.14 OPPOSITE 
SETLAYER LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
SETLAYER LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
SETLAYER GT_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
OUTLAYER ((LINE_END_SHAPE INTERACT GT_CORNER) OUTSIDE INST) NOT INSIDE EXDRC
}
}
if { [string equal $CT_GT_G_CHECK YES] == 1 } {
RULECHECK GT_19_G {
@ Maximum GT length between two CTs without GATE, and the length from any point inside GATE to nearest CT, when the GT width < 0.13um is 25.00um.
@ DRC waive check ESDIO1 or ESDIO2 covered region.
@ This rule is for voltage drop concern.
SETLAYER GT_CHECK = ((WITH WIDTH GT < 0.13) NOT GATE) INTERACT CT
SETLAYER Z0 = SIZE CT BY 12.5 INSIDE OF GT_CHECK STEP 0.02
OUTLAYER ((GT_CHECK INTERACT Z0 > 1) NOT INSIDE (ESDIO1 OR ESDIO2)) NOT INSIDE EXDRC

SETLAYER X = GATE WITH EDGE (LENGTH GATE_L < 0.13)
SETLAYER Y = (GT INTERACT X) INTERACT CT
SETLAYER Z = SIZE CT BY 25 INSIDE OF Y STEP 0.02
OUTLAYER (((GATE INTERACT Y) NOT INSIDE Z) NOT INSIDE (ESDIO1 OR ESDIO2)) NOT INSIDE EXDRC
}
}
RULECHECK GT_20 {
@ GT overlap AA must produce two or more AAs, except the INDMY, LDBK and INST covered region.
OUTLAYER (((GT AND AA) NOT WITH EDGE (GT INSIDE EDGE AA) == 2) NOT INSIDE (OR INDMY LDBK INST)) NOT INSIDE EXDRC
#OUTLAYER (GATE NOT WITH EDGE (GT INSIDE EDGE AA) == 2) NOT INSIDE EXDRC
}

RULECHECK GT_21 {
@ H-shape GATE is forbidden when:
@ 1. GATE channel length is < 0.11um
@ 2. GT center bar length < 0.425um
@ 3. All four H-legs Length (X) >0.065um, and all four H-legs width (Y) <0.265um
SETLAYER GT_CHECK = GT_HS INTERACT AA
SETLAYER X1 = CONVEX EDGE GT_CHECK == 0
SETLAYER Y1 = INT X1 < 0.11 REGION OPPOSITE

SETLAYER Y11 = INT (Y1 INSIDE EDGE AA) < 0.11 REGION OPPOSITE
SETLAYER X2 = LENGTH (Y1 TOUCH EDGE Y11) < 0.425
SETLAYER Y2 = EXPAND EDGE X2 INSIDE BY 0.001

SETLAYER X3 = CONVEX EDGE GT_CHECK == 1

SETLAYER Y3 = GT_CHECK WITH EDGE (LENGTH X3 > 0.065) == 4

SETLAYER X4 = CONVEX EDGE GT_CHECK == 2
SETLAYER Y4 = INT X3 X4 < 0.265 REGION OPPOSITE

OUTLAYER ((((GT_CHECK INTERACT Y1) INTERACT Y2) INTERACT Y3) INTERACT Y4) NOT INSIDE EXDRC

}

RULECHECK GT_22 {
@ UNDEPL/OVERPL layers must be inside TG(125:0) layer.
@ UNDEPL(125:5) layer should be defined for 2.5V under-drive to 1.8V device, and OVERPL(125:4) layer should be defined for 2.5V over-drive to 3.3V or 4.1V IO device.
OUTLAYER (UNDEPL NOT TG) NOT INSIDE EXDRC
OUTLAYER (OVERPL NOT TG) NOT INSIDE EXDRC
}




VERBATIM {

DMACRO NPLH_68 LAY_IMP LAY_ACT ENC_SD ENC_GT ENC_EXTENSION {
 X = GT INSIDE EDGE LAY_ACT
 A = EXPAND EDGE X INSIDE BY ENC_EXTENSION OUTSIDE BY ENC_EXTENSION CORNER FILL
 Y = (GT AND LAY_ACT) COIN EDGE LAY_ACT
 B = EXPAND EDGE Y OUTSIDE BY ENC_GT EXTEND BY ENC_EXTENSION
 C = A OR B
 (ENC LAY_ACT (LAY_IMP INSIDE EDGE C) < ENC_GT ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
 (ENC X LAY_IMP < ENC_SD ABUT<90 REGION OPPOSITE) NOT INSIDE EXDRC
}
DMACRO SNP_68 LAY_IMP LAY_ACT ENC_SD ENC_GT ENC_EXTENSION {
 X = GT INSIDE EDGE LAY_ACT
 A = EXPAND EDGE X INSIDE BY ENC_EXTENSION OUTSIDE BY ENC_EXTENSION CORNER FILL
 Y = (GT AND LAY_ACT) COIN EDGE LAY_ACT
 B = EXPAND EDGE Y OUTSIDE BY ENC_GT EXTEND BY ENC_EXTENSION
 C = A OR B
 D = ENC LAY_ACT (LAY_IMP INSIDE EDGE C) < ENC_GT ABUT<90 REGION OPPOSITE
 (D NOT INSIDE INST) NOT INSIDE EXDRC
 E = ENC X LAY_IMP < ENC_SD ABUT<90 REGION OPPOSITE
 (E NOT INSIDE INST) NOT INSIDE EXDRC
}

//================================================
//  NLL - 1.0/1.2V NLDD implantation design rules
//================================================

GROUP GNLL NLL_?

NLL_1 {
@ Min NLL width is 0.18
  ((INT NLL < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLL_2 {
@ Min Space between two NLL is 0.18
  ((EXT NLL < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLL_3 {
@ Min Space between NLL and P+ AA inside NW is 0.10
  X = (PACT NOT PTAP) NOT TOUCH EDGE NLL
  ((EXT NLL X < 0.10 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLL_4 {
@ Min Space between NLL and P+ AA inside PW is 0.02
  X = PTAP NOT TOUCH EDGE NACT
  ((EXT NLL X < 0.02 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLL_6_8 {
@ Min NLL extension outside of NMOS GATE along source/drain direction is 0.24
@ Min NLL extension outside of NMOS AA along gate poly length direction is 0.16, if distance to the related poly is less than or equal to 0.20um
  CMACRO SNP_68 NLL NACT 0.24 0.16 0.2
}
NLL_7 {
@ Min NLL extension outside of NMOS AA along gate poly length direction is 0.12, if distance to the related poly is larger than 0.20um
  X = (NMOS AND NLL) TOUCH EDGE AAEIGT
  Y1 = ENC X NLL < 0.12 ABUT<90 REGION
  Y2 = NLL NOT INTERACT SN
  ((Y1 OR Y2) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLL_10 {
@ Min Overlap of NLL and AA is 0.09
  ((INT NLL AA < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLL_11 {
@ Min NLL area is 0.10
  ((AREA NLL < 0.10) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLL_12 {
@ Min Space between NLL and butted P+AA (except SRAM area) is 0
  X = AND NLL PACT
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}


//===========================================================
//  NLH-NLHT: 1.8V-2.5/3.3V NLDD implantation design rules
//===========================================================

GROUP GNLH NLH_?

NLH_1_NLH {
@ Min NLH width is 0.18
  ((INT NLH < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLH_1_NLHT {
@ Min NLHT width is 0.18
  ((INT NLHT < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

NLH_2_NLH {
@ Min Space between two NLH is 0.18
  ((EXT NLH < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLH_2_NLHT {
@ Min Space between two NLHT is 0.18
  ((EXT NLHT < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

NLH_3_NLH {
@ Min Space between NLH/NLHT and P+ AA inside NW is 0.10
  X = (PACT NOT PTAP) NOT TOUCH EDGE NLH
  ((EXT NLH X < 0.10 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLH_3_NLHT {
@ Min Space between NLHT and P+AA inside NW is 0.10
  X = (PACT NOT PTAP) NOT TOUCH EDGE NLHT
  ((EXT X NLHT < 0.10 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

NLH_4_NLH {
@ Min Space between NLH/NLHT and P+ AA inside PW is 0.02
  X = PTAP NOT TOUCH EDGE NACT
  ((EXT NLH X < 0.02 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLH_4_NLHT {
@ Min Space between NLH/NLHT and P+ AA inside PW is 0.02
  X = PTAP NOT TOUCH EDGE NACT
  ((EXT NLHT X < 0.02 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

NLH_6_8_NLH {
@ Min NLH/NLHT extension outside of NMOS gate along source/drain direction is 0.24
@ Min NLH/NLHT extension outside of NMOS AA along gate poly length direction is 0.16, if distance to the related poly is less than or equal to 0.20um
 CMACRO SNP_68 NLH NACT 0.24 0.16 0.2
}
NACT_NOT_LDBK = NACT NOT LDBK
NLH_6_8_NLHT {
@ Min NLH/NLHT extension outside of NMOS gate along source/drain direction is 0.24
@ Min NLH/NLHT extension outside of NMOS AA along gate poly length direction is 0.16, if distance to the related poly is less than or equal to 0.20um
  CMACRO SNP_68 NLHT NACT_NOT_LDBK 0.24 0.16 0.2
}

NLH_7_NLH {
@ Min NLH extension outside of NMOS AA along gate poly length direction is 0.12,
@ if distance to the related poly is larger than 0.20um
  X = (NMOS AND NLH) TOUCH EDGE AAEIGT
  Y1 = ENC X NLH < 0.12 ABUT<90 REGION
  Y2 = NLH NOT INTERACT SN
  ((Y1 OR Y2) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLH_7_NLHT {
@ Min NLHT extension outside of NMOS AA along gate poly length direction is 0.12,
@ if distance to the related poly is larger than 0.20um
  X = (NMOS AND NLHT) TOUCH EDGE AAEIGT
  Y1 = ENC X NLHT < 0.12 ABUT<90 REGION
  Y2 = NLHT NOT INTERACT SN
  ((Y1 OR Y2) NOT INSIDE INST) NOT INSIDE EXDRC
}

NLH_10_NLH {
@ Min Overlap of NLH/NLHT and AA is 0.09
  ((INT NLH AA < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLH_10_NLHT {
@ Min Overlap of NLH/NLHT and AA is 0.09
  ((INT NLHT AA < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

NLH_11_NLH {
@ Min NLH area is 0.100
  ((AREA NLH < 0.100) NOT INSIDE INST) NOT INSIDE EXDRC
}
NLH_11_NLHT {
@ Min NLHT area is 0.100
  ((AREA NLHT < 0.100) NOT INSIDE INST) NOT INSIDE EXDRC
}

NLH_12_NLH {
@ Min Space between NLH/NLHT and butted P+AA(except SRAM area) is 0
  X = NLH AND PACT
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}
NLH_12_NLHT {
@ @ Min Space between NLH/NLHT and butted P+AA(except SRAM area) is 0
  X = NLHT AND PACT
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}




//=====================================================
//  PLL - 1.0/1.2V PLDD implantation design rules
//=====================================================

GROUP GPLL PLL_?

PLL_1 {
@ Min PLL width is 0.18
  ((INT PLL < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLL_2 {
@ Min Space between two PLL is 0.18
  ((EXT PLL < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLL_3 {
@ Min Space between PLL and N+ AA inside PW is 0.10
  X = (NACT NOT NTAP) NOT TOUCH EDGE PLL
  ((EXT PLL X < 0.10 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLL_4 {
@ Min Space between PLL and N+ AA inside NW is 0.02
  X = NTAP NOT TOUCH EDGE PACT
  ((EXT PLL X < 0.02 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLL_6_8 {
@ Min PLL extension outside of PMOS gate along source/drain direction is 0.24.
@ Min PLL extension outside of PMOS AA along gate poly length direction is 0.16, if distance to the related poly is less than or equal to 0.20um
  CMACRO SNP_68 PLL PACT 0.24 0.16 0.2
}
PLL_7 {
@ Min PLL extension outside of PMOS AA along gate poly length direction is 0.12, 
@ if distance to the related poly is larger than 0.20um
  X = (PMOS AND PLL) TOUCH EDGE AAEIGT
  Y1 = ENC X PLL < 0.12 ABUT<90 REGION
  Y2 = PLL NOT INTERACT SP
  ((Y1 OR Y2) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLL_10 {
@ Min Overlap of PLL and AA is 0.09
  ((INT PLL AA < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLL_11 {
@ Min PLL area is 0.100
  ((AREA PLL < 0.100) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLL_12 {
@ Min Space between PLL and butted N+AA (except SRAM area) is 0.
  X = PLL AND NACT
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}



//==========================================================
//  PLH-PLHT: 1.8V-2.5/3.3V PLDD implantation design rules
//==========================================================

GROUP GPLH PLH_?

PLH_1_PLH {
@ Min PLH width is 0.18
  ((INT PLH < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLH_1_PLHT {
@ Min PLHT width is 0.18
  ((INT PLHT < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

PLH_2_PLH {
@ Min Space between two PLL is 0.18
  ((EXT PLH < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLH_2_PLHT {
@ Min Space between two PLHT is 0.18
  ((EXT PLHT < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

PLH_3_PLH {
@ Min Space between PLH and N+AA inside PW is 0.10
  X = (NACT NOT NTAP) NOT TOUCH EDGE PLH
  ((EXT PLH X < 0.10 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLH_3_PLHT {
@ Min Space between PLHT and N+AA inside PW is 0.10          
  X = (NACT NOT NTAP) NOT TOUCH EDGE PLHT
  ((EXT PLHT X < 0.10 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

PLH_4_PLH {
@ Min Space between PLH/PLHT and N+ AA inside N well is 0.02
  X = NTAP NOT TOUCH EDGE PACT
  ((EXT PLH X < 0.02 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLH_4_PLHT {
@ Min Space between PLH/PLHT and N+ AA inside N well is 0.02
  X = NTAP NOT TOUCH EDGE PACT
  ((EXT PLHT X < 0.02 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

PLH_6_8_PLH {
@ Min PLH/PLHT extension outside of PMOS gate along source/drain direction is 0.24
@ Min PLH/PLHT extension outside of PMOS AA along gate poly length direction, if distance to the related poly is less than or equal to 0.20um is 0.16
  CMACRO SNP_68 PLH PACT 0.24 0.16 0.2
}
PACT_NOT_LDBK = PACT NOT LDBK
PLH_6_8_PLHT {
@ Min PLH/PLHT extension outside of PMOS gate along source/drain direction is 0.24
@ Min PLH/PLHT extension outside of PMOS AA along gate poly length direction, if distance to the related poly is less than or equal to 0.20um is 0.16
  CMACRO SNP_68 PLHT PACT_NOT_LDBK 0.24 0.16 0.2
}

PLH_7_PLH {
@ Min PLH extension outside of PMOS AA along gate poly length direction is 0.12,
@ if distance to the related poly is larger than 0.20um
  X = (PMOS AND PLH) TOUCH EDGE AAEIGT
  Y1 = ENC X PLH < 0.12 ABUT<90 REGION
  Y2 = PLH NOT INTERACT SP
  ((Y1 OR Y2) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLH_7_PLHT {
@ Min PLHT extension outside of PMOS AA along gate poly length direction is 0.12,
@ if distance to the related poly is larger than 0.20um
  X = (PMOS AND PLHT) TOUCH EDGE AAEIGT
  Y1 = ENC X PLHT < 0.12 ABUT<90 REGION
  Y2 = PLHT NOT INTERACT SP
  ((Y1 OR Y2) NOT INSIDE INST) NOT INSIDE EXDRC
}

PLH_10_PLH {
@ Min Overlap of PLH/PLHT and AA is 0.09
  ((INT PLH AA < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLH_10_PLHT {
@ Min Overlap of PLH/PLHT and AA is 0.09
  ((INT PLHT AA < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}

PLH_11_PLH {
@ Min PLH area is 0.100
  ((AREA PLH < 0.100) NOT INSIDE INST) NOT INSIDE EXDRC
}
PLH_11_PLHT {
@ Min PLHT area is 0.100
  ((AREA PLHT < 0.100) NOT INSIDE INST) NOT INSIDE EXDRC
}

PLH_12_PLH {
@ Min Space between PLH/PLHT and butted N+AA (except SRAM area) is 0
  X = PLH AND NACT
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}
PLH_12_PLHT {
@ Min Space between PLH/PLHT and butted N+AA (except SRAM area) is 0
  X = PLHT AND NACT
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}



//=================================
//  SN - N+ S/D Implantation DRC
//=================================

GROUP GSN SN_?

SN_1 {
@ Min SN width is 0.18. Single-point-interaction is allowed.
  (INT SN < 0.18 ABUT<90 REGION) NOT INSIDE EXDRC
}
SN_2 {
@ Min Space between two SN is 0.18
  (EXT SN < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE EXDRC
}
SN_3 {
@ Min Space between SN and P+AA inside NW is 0.10
  X = (PACT NOT PTAP) NOT TOUCH EDGE SN
  Y = EXT SN X < 0.10 ABUT<90 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
SN_4 {
@ Min Space between SN and P+ pickup AA inside PW is 0.02
  X = PTAP NOT TOUCH EDGE NACT
  Y = X NOT TOUCH EDGE SN
  (EXT SN Y < 0.02 ABUT<90 REGION) NOT INSIDE EXDRC
}
SN_5 {
@ Min Space between SN and PMOS gate along source/drain direction is 0.24
  X = GATE_W INSIDE EDGE SP
  Y = EXT X SN < 0.24 ABUT<90 OPPOSITE  REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
SN_6_8 {
@ Min SN extension outside of NMOS gate along source/drain direction is 0.24
@ Min SN extension outside of NMOS AA along gate poly length direction is 0.16, if the distance to the related poly is less than or equal to 0.20um
  SN_S = SN NOT INSIDE INST
  NACT_S = NACT NOT INSIDE INST
  CMACRO SNP_68 SN_S NACT_S 0.24 0.16 0.2
}
SN_7 {
@ Min SN extension outside of NMOS AA along gate poly length direction 0.12, if the distance to the related poly is larger than 0.20um
  X = NMOS TOUCH EDGE AAEIGT
  Y = ENC X SN < 0.12 ABUT<90 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
SN_9 {
@ Min N+AA enclosured by by SN in NW is 0.02
  X = ((NTAP NOT SNNR) NOT COIN EDGE PACT) NOT COIN EDGE SP
  (ENC X SN < 0.02 ABUT<90 REGION) NOT INSIDE EXDRC
}
SN_9a {
@ Min N+AA enclosure by SN in PW is 0.02, except the INST region.
  X = (((NACT NOT INTERACT NWR) NOT COIN EDGE PACT) NOT COIN EDGE SP) INSIDE EDGE PW
  ((ENC X (SN AND PW) < 0.02 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
}

if { [string equal $Recommended_rules_OTHER YES] == 1 } {
VERBATIM {
SN_9a_R {
@ Min N+AA enclosure by SN in PW is 0.12, except the INST region.
  X = (((NACT NOT INTERACT NWR) NOT COIN EDGE PACT) NOT COIN EDGE SP) INSIDE EDGE PW
  ((ENC X (SN AND PW) < 0.12 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
SP_9a_R {
@ Min P+ AA enclosure by SP in NW is 0.12, except the INST region.
  X = (((PACT NOT INTERACT NWR) NOT COIN EDGE NACT) NOT COIN EDGE SN) INSIDE EDGE NW
  ((ENC X (SP AND NW) < 0.12 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
}
}


VERBATIM {
SN_10 {
@ Min Overlap of SN and AA is 0.09
  (INT SN AA < 0.09 ABUT >0 <90 SINGULAR REGION) NOT INSIDE EXDRC
}
SN_11 {
@ Min SN area is 0.10
  (AREA SN < 0.10) NOT INSIDE EXDRC
}
SN_11a {
@ Min SN enclosed area is 0.10
  (AREA ((HOLES SN INNER) NOT SN) < 0.10 ) NOT INSIDE EXDRC
}
SN_12 {
@ Space between SN and butted P+AA (except SRAM area) is 0
  X = SN AND PACT
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}
SN_13 {
@ Min Butted P+ pick-up AA space to GT in the same AA (the butted N+ACTIVE extending <0.18um) is 0.24
  NAAL = NACT TOUCH INSIDE EDGE NGATE
  NAAL_EP = EXPAND EDGE NAAL OUTSIDE BY 0.18 EXTEND BY 0.01
  BUTNA_ED = PACT COIN EDGE (NACT NOT NTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE NAAL_EP
  BUTSN_1 = (PACT INTERACT PW) WITH EDGE BUTNA_ED_1

  GTSN_1 = (GT INSIDE EDGE ((NACT NOT NTAP) TOUCH PACT)) COIN EDGE NGATE
  GTSN   = (GT WITH EDGE GTSN_1) TOUCH EDGE NGATE  
  (EXT BUTSN_1 GTSN < 0.24 ABUT<90 REGION) NOT INSIDE EXDRC
}

//=======================================
//  SP - P+ S/D implantation DRC
//=======================================

GROUP GSP SP_?

SP_1 {
@ Min SP width is 0.18. Single-point-interaction is allowed.
  (INT SP < 0.18 ABUT<90 REGION) NOT INSIDE EXDRC
}
SP_2 {
@ Min Space between two SP is 0.18
  (EXT SP < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE EXDRC
}
SP_3 {
@ Min Space between SP and N+AA inside PW is 0.10
  X = (NACT NOT NTAP) NOT TOUCH EDGE SP
  Y = EXT SP X < 0.10 ABUT<90 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
SP_4 {
@ Min Space between SP and N+ AA inside NW is 0.02
  X = NTAP NOT TOUCH EDGE PACT
  Y = X NOT TOUCH EDGE SP
  (EXT SP Y < 0.02 ABUT<90 REGION) NOT INSIDE EXDRC
}
SP_5 {
@ Min Space between SP and NMOS gate along source/drain direction is 0.24
  X = GT INSIDE EDGE NACT
  Y = EXT SP X < 0.24 ABUT<90 REGION OPPOSITE
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
SP_6_8 {
@ Min SP extension outside of PMOS gate along source/drain direction is 0.24
@ Min SP extension outside of PMOS AA along gate poly length direction is 0.16, if the distance to the related poly is less than or equal to 0.20um
 SP_S = SP NOT INSIDE INST
 PACT_S = PACT NOT INSIDE INST
 CMACRO SNP_68 SP_S PACT_S 0.24 0.16 0.2
}
SP_7 {
@ Min SP extension outside of PMOS AA along gate poly length direction is 0.12, if the distance to the related poly is larger than 0.2um
  X = PMOS TOUCH EDGE AAEIGT
  Y = ENC X SP < 0.12 ABUT<90 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
SP_9 {
@ Min P+AA enclosure by SP in PW is 0.02
  X = ((PTAP NOT INTERACT NWR) NOT COIN EDGE NACT) NOT COIN EDGE SN
  (ENC X SP < 0.02 ABUT<90 REGION) NOT INSIDE EXDRC
}
SP_9a {
@ Min P+ AA enclosure by SP in NW is 0.02, except the INST region.
  X = (((PACT NOT INTERACT NWR) NOT COIN EDGE NACT) NOT COIN EDGE SN) INSIDE EDGE NW
  ((ENC X (SP AND NW) < 0.02 ABUT<90 REGION) NOT INSIDE INST) NOT INSIDE EXDRC
}
SP_10 {
@ Min Overlap of SP and AA is 0.09
  (INT SP (AA NOT TOUCH EDGE SP) < 0.09 ABUT<90 REGION) NOT INSIDE EXDRC
}
SP_11 {
@ Min SP area is 0.100
  (AREA SP < 0.100) NOT INSIDE EXDRC
}
SP_11a {
@ Min SP enclosed area is 0.10
  (AREA ((HOLES SP INNER) NOT SP) < 0.10) NOT INSIDE EXDRC
}
SP_12 {
@ Space between SP and butted N+AA (except SRAM area) is 0
  X = SP AND NACT
  (X NOT INSIDE INST) NOT INSIDE EXDRC
} 
SP_13 {
@ No SN and SP overlap is allowed
  (AND SN SP) NOT INSIDE EXDRC
}
/*
SP_14 {
@ SP can not be generated by the reverse tone of SN
  DRC:1 NOT INTERACT (DRC:1 XOR (SN OR SP))
}*/
SP_15 {
@ Min Butted N+ pick-up AA space to GT in the same AA (the butted P+ACTIVE extending <0.18um) is 0.24
  PAAL = PACT TOUCH INSIDE EDGE PGATE
  PAAL_EP = EXPAND EDGE PAAL OUTSIDE BY 0.18 EXTEND BY 0.01
  BUTNA_ED = NACT COIN EDGE (PACT NOT PTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE PAAL_EP
  BUTSN_1 = (NACT INTERACT NW) WITH EDGE BUTNA_ED_1
  GTSP_1 = (GT INSIDE EDGE (PACT  TOUCH NACT)) COIN EDGE PGATE
  GTSP   = (GT WITH EDGE GTSP_1) TOUCH EDGE PGATE  
  (EXT BUTSN_1 GTSP < 0.24 ABUT<90 REGION) NOT INSIDE EXDRC
}


//=================================
//  SAB - Salicide Block DRC
//=================================

GROUP GSAB SAB_?

SAB_1 {
@ Min SAB width is 0.40um
  (INT SAB < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SAB_2 {
@ Min Space between two SABs is 0.40um
  (EXT SAB < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SAB_2a {
@ Space between two SABs when one or both SAB interacts with poly is 0.45um, DRC waive if no (GT OR AA) exists in the space region.
  ((EXT (SAB INTERACT GT) SAB < 0.45 ABUT<90 SINGULAR REGION) INTERACT (GT OR AA)) NOT INSIDE EXDRC
}
SAB_3 {
@ Min Extension of AA outside of SAB is 0.2um
  (ENC SAB AA < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SAB_4 {
@ Min Space between SAB and AA is 0.2um
  (EXT SAB AA < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SAB_5 {
@ Min Space between SAB and GATE is 0.36
@ SAB overlap with GATE is forbidden, DRC waive ESDIO1/ESDIO2 regions and waive total SAB overlap GATE 60nm.
  (EXT SAB GATE < 0.36 ABUT<90 REGION) NOT INSIDE EXDRC
  ESD_REGION = INT GATE_W SAB == 0.06 OPPOSITE REGION 
  (((SAB NOT INTERACT ESD_REGION) AND GATE) NOT INSIDE (ESDIO1 OR ESDIO2) ) NOT INSIDE EXDRC 
}
SAB_6 {
@ Min Extension of SAB outside of poly on field oxide is 0.2
  (ENC (GT NOT (AA OR AADUM)) SAB < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
SAB_7 {
@ Min Space between SAB and CT is 0.2
  (EXT SAB CT < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SAB_8 {
@ Min Extension of SAB outside of AA is 0.2
  (ENC AA SAB < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SAB_9 {
@ Min SAB overlap with SN/SP is 0.20
  (INT SN SAB < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  (INT SP SAB < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SAB_10 {
@ Min SAB area is 1.0
  (AREA SAB < 1.0) NOT INSIDE EXDRC
}
SAB_10a {
@ Min SAB enclosed area is 1.0
  (AREA ((HOLES SAB INNER) NOT SAB)< 1.0) NOT INSIDE EXDRC
}
SAB_11 {
@ Min Space between a SAB and poly on field oxide is 0.28
  GT_CHECK = GT NOT (AA OR AADUM)
  (EXT SAB GT_CHECK < 0.28 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}
if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK SAB_12_R {
@ Min Extension on unsilicided AA/GT when SAB width >10um is 0.3um, DRC waive if >= 5 poly fingers exist in (GT AND SAB) region.
SETLAYER  SAB_CHECK = (SAB WITH WIDTH > 10) NOT INTERACT (GT AND SAB) > 4
OUTLAYER  (ENC ((AA OR GT) INTERACT SAB) SAB_CHECK < 0.3 ABUT < 90 REGION) NOT INSIDE EXDRC
}
}
VERBATIM {
SAB_13 {
@ Butted NP/PP on unsillcided AA/GT is not allowed.
  SAB_CHECK = (AA AND SAB) OR (GT AND SAB)
  ((SN COIN EDGE SP) INSIDE EDGE SAB_CHECK ) NOT INSIDE EDGE EXDRC
}


//========================
//  CT - Contact DRC
//========================

GROUP GCT CT_?

CTN = CT AND (RECTANGLE CT ASPECT == 1)

CT_1 {
@ Fixed contact size (square shape) exclude MARKS area
@ DRC waive rectangular CT in SRAM and EFUSE area, and waive protection ring purpose non-rectangular CT in MARKG area.	=	0.09	um
  X = NOT RECTANGLE ((CT NOT RCT) NOT GCT) == 0.09 BY == 0.09
  (X NOT INSIDE ((MARKG OR INST) OR EFUSE)) NOT INSIDE (MARKS OR EXDRC)
  (NOT RECTANGLE (RECTANGLE (CT AND MARKG)) == 0.09 BY == 0.09) NOT INSIDE (MARKS OR EXDRC)
  (NOT RECTANGLE (RECTANGLE (CT AND EFUSE) ASPECT == 1) == 0.09 BY == 0.09) NOT INSIDE (MARKS OR EXDRC)
  (NOT RECTANGLE (RECTANGLE (CT AND INST) ASPECT == 1) == 0.09 BY == 0.09) NOT INSIDE (MARKS OR EXDRC)
 
}
CT_2a {
@ Min Space between two contacts is 0.11
  X = EXT CT < 0.11 ABUT<90 SINGULAR REGION
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}
CT_2b {
@ Min Space between two contacts  is 0.13 in case contact array is larger or equal to 4x4
@ Two contact regions whose space is within 0.15 are considered to be in the same array
  X = SIZE CT BY 0.075 OVERUNDER
  Y = SIZE X BY 0.340 UNDEROVER
  Z = CT INSIDE Y
  (EXT Z < 0.13 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}  

if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK CT_2c_R {
@ Min CT space at different nets is 0.12um, except INST region
OUTLAYER (EXT CT < 0.12 SINGULAR REGION NOT CONNECTED) NOT INSIDE (INST OR EXDRC)

}
RULECHECK CT_2d_R {
@ Min CT space at different nets when parallel run length > 0um is 0.14um,except INST region
 SETLAYER CT_S = EXT CT < 0.14 OPPOSITE REGION PARA ONLY NOT CONNECTED
 SETLAYER CT_LS = LENGTH CT_S > 0 
 OUTLAYER (CT_S WITH EDGE CT_LS ) NOT INSIDE (INST OR EXDRC)
}

RULECHECK CT_5a_R {
@ Min CT enclosure by AA when one or both perpendicular directions <0.03um is 0.03um
SETLAYER X = RECTANGLE ENC (CT INTERACT AA) AA ABUT<90 OUTSIDE ALSO\
  GOOD 0.015 OPPOSITE 0.03 OPPOSITE 0.015 OPPOSITE 0.03 OPPOSITE

SETLAYER  A = ENC \[X\] AA < 0.03 OPPOSITE
SETLAYER  D2 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION      
OUTLAYER  D2 NOT INSIDE INST

OUTLAYER  ((CT INTERACT AA) NOT AA) NOT INSIDE INST
}

RULECHECK CT_6a_R {
@ Min CT enclosure by poly when one or both perpendicular directions <0.04um is 0.04um
SETLAYER X = RECTANGLE ENC (CT INTERACT GT) GT ABUT<90 OUTSIDE ALSO\
  GOOD 0.01 OPPOSITE 0.04 OPPOSITE 0.01 OPPOSITE 0.04 OPPOSITE

SETLAYER A = ENC \[X\] GT < 0.04 OPPOSITE
SETLAYER D2 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION      
OUTLAYER D2 NOT INSIDE INST

OUTLAYER ((CT INTERACT GT) NOT GT) NOT INSIDE INST
}

RULECHECK CT_7c_R {
@ Min M1 enclosure of CT, when M1 width >1um is 0.04um.
SETLAYER M1_CHECK = M1 WITH WIDTH > 1
OUTLAYER (ENC CT M1_CHECK < 0.04 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

VERBATIM {
CT_3 {
@ Min Space between AA and contact on poly is 0.065
  (EXT CT AA < 0.065 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
CT_4a {
@ Min Space between GATE to diffusion contact for 1.0/1.2V is 0.05
  X = EXT GATE_M ACT_CT < 0.05 ABUT<90 SINGULAR REGION 
  (X NOT INSIDE INST) NOT INSIDE EXDRC
}
CT_4b {
@ Min Space between GATE and contact on AA for 1.8/2.5/3.3V is 0.09
  X1 = EXT GATE_D (ACT_CT AND DG) < 0.09 ABUT<90 SINGULAR REGION
  X2 = EXT GATE_T (ACT_CT AND TG) < 0.09 ABUT<90 SINGULAR REGION
  (X1 OR X2) NOT INSIDE EXDRC
}
CT_5 {
@ Min CT enclosure by AA for CT landed on AA is 0.015
  X = CT INTERACT AA
  Y = ENC X AA < 0.015 ABUT<90 SINGULAR REGION OUTSIDE ALSO
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
/*
CT_5_5a {
@ Min CT enclosure by AA for CT landed on AA is 0.015
@ Min CT enclosure by AA when one or both perpendicular directions <0.03um is 0.03um
  X = RECTANGLE ENC (CT INTERACT AA) AA ABUT<90 OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.03 OPPOSITE 0.015 OPPOSITE 0.03 OPPOSITE

  D1 = ENC X AA < 0.015 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  (D1 NOT INSIDE INST) NOT INSIDE EXDRC

  A = ENC [X] AA < 0.03 OPPOSITE
  D2 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION      //; For CT not touching M1
  D2 NOT INSIDE INST

  ((CT INTERACT AA) NOT AA) NOT INSIDE INST
  
 }
*/

CT_6 {
@ Min CT enclosure by poly for CT landed on poly is 0.01
  X = CT INTERACT GT
  Y = ENC X GT < 0.01 ABUT<90 SINGULAR REGION OUTSIDE ALSO
  (Y NOT INSIDE INST) NOT INSIDE EXDRC
}
/*
CT_6_6a {
@ Min CT enclosure by poly for CT landed on poly is 0.01
@ Min CT enclosure by poly when one or both perpendicular directions <0.04um is 0.04um
   X = RECTANGLE ENC (CT INTERACT GT) GT ABUT<90 OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.04 OPPOSITE 0.01 OPPOSITE 0.04 OPPOSITE

  D1 = ENC X GT < 0.01 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  (D1 NOT INSIDE INST) NOT INSIDE EXDRC

  A = ENC [X] GT < 0.04 OPPOSITE
  D2 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION      //; For CT not touching M1
  D2 NOT INSIDE INST

  ((CT INTERACT GT) NOT GT) NOT INSIDE INST
  }
*/

CT_7a_7b {
@ Min M1 enclosure of CT is 0.00
@ Min M1 enclosure of CT when M1 enclosure on one or both perpendicular directions < 0.025um is 0.025
  X = RECTANGLE ENC (CT NOT TOUCH M1) M1 ABUT<90 OUTSIDE ALSO
  GOOD 0 0.025 OPPOSITE 0 0.025 OPPOSITE

  A = ENC [X] M1 < 0.025 OPPOSITE
  D1 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION      //; For CT not touching M1
  (D1 NOT INSIDE INST) NOT INSIDE EXDRC

  B = CT COIN EDGE M1
  D2 = INT B < 0.01 ABUT==90 REGION        //; For CT touch M1 with >= 2 butting edges
  (D2 NOT INSIDE INST) NOT INSIDE EXDRC

  Y = ENC CT M1 < 0.025 OPPOSITE REGION
  C1 = CT COIN EDGE M1
  C2 = CT COIN EDGE Y
  D3 = INT C1 C2 < 0.01 ABUT==90 REGION	//; For CT touch M1 with only 1 edge
  (D3 NOT INSIDE INST) NOT INSIDE EXDRC

  ((CT NOT M1) NOT INSIDE INST) NOT INSIDE EXDRC
  (CT NOT INTERACT M1) NOT INSIDE EXDRC
}

CT_9  {
@ CT is not allowed to land on gate
  ((AND GATE CT) NOT INSIDE INST) NOT INSIDE EXDRC
}
CT_10 {
@ CT should land on salicided surface (except MARKG/MARKS covered area) and CT cannot overlap with (STI without poly) (except SRAM and Efuse area).
@ Waive the CT cutting AA in SRAM area.
  X = CT NOT ((CT CUT AA) AND INST)
  ((X NOT ((AA OR GT) NOT SAB) ) NOT INSIDE (MARKG OR MARKS)) NOT INSIDE EXDRC
  ((CT NOT ((AA OR AADUM) OR GT) ) NOT INSIDE (INST OR EFUSE)) NOT INSIDE EXDRC
}
CT_11 {
@ CT must be fully covered by M1 and (AA OR GT), except INST region.
  ((CT NOT (M1 AND (GT OR AA))) NOT INSIDE INST) NOT INSIDE EXDRC
}
CT_12 {
@ It is not allowed CT overlap with NW, AA, Poly or M1 resistor. For NW, AA, Poly resistor, please refer each resistor section definition.
@ M1 resistor definition: (M1 AND M1R).
  X11 = (RESNW AND NW) NOT INTERACT SAB
  X12 = ((RESNW AND AA) AND NW) AND SAB
  X21 = (RESAA AND AA) NOT INTERACT SAB
  X22 = (RESAA AND AA) AND SAB
  X3 = M1 AND M1R
  X41 = (RESP1 AND GT) AND SAB
  X42 = (RESP1 AND GT) NOT INTERACT SAB
  X5 = ((HRPDMY AND GT) AND HRP) AND SAB
  (CT AND (OR X11 X12 X21 X22 X3 X41 X42 X5)) NOT INSIDE EXDRC
}
}
if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK CT_13_R {
@ Min Space to butted SN/SP edge on AA (overlap of SN/SP boundary on AA is not allowed) is 0.06um.
  SETLAYER X = (SN COIN EDGE SP) NOT OUTSIDE EDGE AA

  OUTLAYER (X INSIDE EDGE CT) NOT INSIDE EDGE EXDRC
  OUTLAYER (ENC CT X < 0.06 ABUT<90 REGION ) NOT INSIDE EXDRC
}
}
if { [string equal $CT_GT_G_CHECK YES] == 1 } {
RULECHECK CT_14_G {
@ Both source/drain side and butted well pick up side should be put CT to avoid high Rs.
  SETLAYER CHECK_SD = OR ((OR PSD LDPS LDPD) TOUCH NTAP) ((OR NSD LDNS LDND) TOUCH PTAP)
  SETLAYER CHECK_TAP = OR (NTAP TOUCH (OR PSD LDPS LDPD)) (PTAP TOUCH (OR NSD LDNS LDND))
  OUTLAYER ((CHECK_SD NOT ENCLOSE CTN) TOUCH CHECK_TAP) NOT INSIDE EXDRC
  OUTLAYER ((CHECK_TAP NOT ENCLOSE CTN) TOUCH CHECK_SD) NOT INSIDE EXDRC
}
}



#//=====================
#//  M1 - Metal 1 DRC
#//=====================

GROUP GM1 M1_?


SETLAYER density_checkarea = DRC:1 NOT INDMY


RULECHECK M1_1 {
@ Min M1 width is 0.09
  OUTLAYER (INT M1 < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK M1_2a {
@ Min Space between two M1 is 0.09,DRC waive check 89 to 90 degree spaces in the INDMY region.
  SETLAYER X = EXT M1 < 0.09 ABUT<90 SINGULAR REGION
  OUTLAYER ((X NOT INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
  SETLAYER Y = EXT M1 < 0.09 ABUT<89 SINGULAR REGION
  OUTLAYER ((Y AND INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
}

RULECHECK M1_2b {
@ Min Space between two M1s is 0.16 when one or both M1 width or length >=1um, and the run length of two M1s is >=2um
@ M1 width or length direction checked by DRC is perpendicular to run length direction.
  Mn_2b M1ALL 2 1 0.16
}

RULECHECK M1_2c {
@ Min Space between two M1s is 0.5 when one or both M1 width or length >= 5um, and run length of two M1s is >= 2um
@ M1 width or length direction checked by DRC is perpendicular to run length direction.
  Mn_2b M1ALL 2 5 0.5
}

#RULECHECK M1_2d {
#@ Min Space between two M1 is 0.16um when one or both M1 width >= 0.4um, and the parallel run length of two M1s is >= 0.4um
#  Mn_2b M1ALL 0.4 0.4 0.16
#}

RULECHECK M1_3 {
@ Max M1 width is 12.
  OUTLAYER (M1 WITH WIDTH > 12) NOT INSIDE EXDRC
}

RULECHECK M1_4 {
@ Min M1 area is 0.027
  SETLAYER X = AREA M1 < 0.027
  OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
}

RULECHECK M1_5 {
@ Min Enclosed dielectric area by M1 is 0.13
  SETLAYER X = (HOLES M1 INNER EMPTY) NOT M1
  OUTLAYER (AREA X < 0.13) NOT INSIDE EXDRC
}


RULECHECK M1_6al {
@ M1 density (including dummy) in 200umX200um window with step size 100um is >= 15% and <= 80%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking
  SETLAYER X = DENSITY M1ALLi < 0.15 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_M1_6al.log
  OUTLAYER ((((X NOT MARKF) NOT MARKG) NOT MARKS) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK M1_6ah {
@ M1 density (including dummy) in 200umX200um window with step size 100um is >= 15% and <= 80%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking
  SETLAYER X = DENSITY M1ALLi > 0.80 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_M1_6ah.log
  OUTLAYER ((((X NOT MARKF) NOT MARKG) NOT MARKS) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK M1_6b {
@ Max M1 density (including dummy) in 50umX50um window with step size 25um is 90%
  OUTLAYER (DENSITY M1ALLi > 0.90 WINDOW 50 STEP 25 backup PRINT density_report_M1_6b.log) NOT INSIDE EXDRC
}

RULECHECK M1_6c {
@ The max difference between M1 density in 200umX200um with step size 200um and those of the adjacent checking windows (including dummy) is 45%. 
@ INDMY/MARKG/MARKF/MARKS covered areas are excluded for this rule checking
  SETLAYER X = DENSITY M1ALLi >= 0 WINDOW 200 GRADIENT > 0.45 ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_M1_6c.log
  OUTLAYER ((((X NOT MARKF) NOT MARKG) NOT MARKS) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK M1_6d {
@ Min M1 density (including dummy) in 25umX25um window with step size 12.5um is 10%.
@ INDMY/MARKG/MARKS covered areas are excluded for this rule checking
  SETLAYER X = DENSITY M1ALLi < 0.1 WINDOW 25 STEP 12.5 backup INSIDE OF LAYER density_checkarea PRINT density_report_M1_6d.log
  OUTLAYER (((X NOT MARKG) NOT MARKS) NOT INDMY) NOT INSIDE EXDRC
}

    if { [string equal $Recommended_rules_OTHER YES] == 1 } {

RULECHECK M1_6e_min_R {
@ M1 average density inside the dummy block area in 25umX25um window with step size 12.5um is >= 10% and <= 90% when the dummy block area >= 25umX25um. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking.
@ Device sensitive areas can be waived.
@ NOTICE: It is a recommended rule.
  SETLAYER X = DENSITY M1ALLi < 0.1 WINDOW 25 STEP 12.5 backup PRINT density_report_M1_6e_min.log
  SETLAYER Y = ((DUMBM OR M1DUB) OR NODMF) NOT (OR INDMY MARKF MARKG MARKS)
  SETLAYER Z = SIZE Y BY 12.5 UNDEROVER
  OUTLAYER (X AND Z) NOT INSIDE EXDRC
}

RULECHECK M1_6e_max_R {
@ M1 average density inside the dummy block area in 25umX25um window with step size 12.5um is >= 10% and <= 90% when the dummy block area >= 25umX25um. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking.
@ Device sensitive areas can be waived.
@ NOTICE: It is a recommended rule.
  SETLAYER X = DENSITY M1ALLi > 0.90 WINDOW 25 STEP 12.5 backup PRINT density_report_M1_6e_max.log
  SETLAYER Y = ((DUMBM OR M1DUB) OR NODMF) NOT (OR INDMY MARKF MARKG MARKS)
  SETLAYER Z = SIZE Y BY 12.5 UNDEROVER
  OUTLAYER (X AND Z) NOT INSIDE EXDRC
}
}

RULECHECK M1_7_a {
@ Min Space between metal lines with one or both are 45 degree, and the bending metal length>=0.5um is 0.105um.
@ (the area with 0.1um distance from bending point need not follow this rule)
  SETLAYER X = ANGLE M1 == 45
  SETLAYER Y = LENGTH X >= 0.5
  OUTLAYER (EXT Y < 0.105 REGION) NOT INSIDE EXDRC
}

RULECHECK M1_7_b {
@ Min Space between metal lines with one or both are 45 degree, and the bending metal length>=0.5um is 0.105
@ (the area with 0.1um distance from bending point need not follow this rule)
  SETLAYER X = ANGLE M1 == 45
  SETLAYER Y = LENGTH X >= 0.5
  OUTLAYER (EXT Y M1 < 0.105 REGION CORNER TO EDGE) NOT INSIDE EXDRC
}






#**********************************************
# Mn: Metal n (n=2~8) design rules
#**********************************************



set metal_list { M2 M3 M4 M5 M6 M7 M8 }
foreach metal_layer $metal_list {
  set tmp CHECK_$metal_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
    GROUP G${metal_layer} ${metal_layer}_?

RULECHECK ${metal_layer}_1 {
@ Min $metal_layer width is 0.10
  OUTLAYER (INT $metal_layer < 0.10 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

#-----------------------------------------------------------------------------------------------
    if { [string equal $metal_layer M2] == 1 } {
RULECHECK ${metal_layer}_2a {
@ Min space between two ${metal_layer}s is 0.1,DRC waive check 89 to 90 degree spaces in the INDMY region
  SETLAYER X = EXT $metal_layer < 0.10 ABUT<90 SINGULAR REGION
  OUTLAYER ((X NOT INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
  SETLAYER Y = EXT $metal_layer < 0.10 ABUT<89 SINGULAR REGION
  OUTLAYER ((Y AND INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
}
    } else {
RULECHECK ${metal_layer}_2a {
@ Min Space between two Mns is 0.10,DRC waive check 89 to 90 degree spaces in the INDMY region
  OUTLAYER ((EXT $metal_layer < 0.10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((EXT $metal_layer < 0.10 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
    }
#----------------------------------------------------------------------------------------------------

RULECHECK ${metal_layer}_2b {
@ Min Space between two ${metal_layer}s is 0.16um when one or both $metal_layer width or length >= 1um, and the run length of two ${metal_layer}s is >= 2um
@ Mn width or length direction checked by DRC is perpendicular to run length direction.  
  Mn_2b ${metal_layer}ALL 2 1 0.16
}

RULECHECK ${metal_layer}_2c {
@ Min Space between two ${metal_layer}s is 0.5um when one or both ${metal_layer} width or length >= 5um, and the run length of two ${metal_layer}s is >= 2um
@ Mn width or length direction checked by DRC is perpendicular to run length direction.
  Mn_2b ${metal_layer}ALL 2 5 0.5
}

#RULECHECK ${metal_layer}_2d {
#@ Min Space between two ${metal_layer}s is 0.16um when one or both ${metal_layer} width >= 0.4um, and the parallel run length of two ${metal_layer}s is >= 0.4um
#  Mn_2b ${metal_layer}ALL 0.4 0.4 0.16
#}

RULECHECK ${metal_layer}_3 {
@ Max $metal_layer width is 12.
@ Metal line greater than this width will comply slot rules.
  OUTLAYER ($metal_layer WITH WIDTH > 12) NOT INSIDE EXDRC
}

#-----------------------------------------------------------------------------------------------
    if { [string equal $metal_layer M2] == 1 } {
RULECHECK ${metal_layer}_4 {
@ Min $metal_layer area is 0.035
  SETLAYER X = AREA $metal_layer  < 0.035
  OUTLAYER (X NOT INSIDE INST) NOT INSIDE EXDRC
}
    } else {
RULECHECK ${metal_layer}_4 {
@ Min $metal_layer area is 0.035
  OUTLAYER (AREA $metal_layer < 0.035) NOT INSIDE EXDRC
}
    }
#-----------------------------------------------------------------------------------------------

RULECHECK ${metal_layer}_5 {
@ Min Enclosed dielectric area by $metal_layer is 0.12
  SETLAYER X = (HOLES $metal_layer INNER) NOT $metal_layer
  OUTLAYER (AREA X < 0.12) NOT INSIDE EXDRC
}

RULECHECK ${metal_layer}_6al {
@ $metal_layer density (including dummy) in 200umX200um window with step size 100um is >= 15% and <= 80%.
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking
  SETLAYER X = DENSITY ${metal_layer}ALLi < 0.15 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_${metal_layer}_6al.log
  OUTLAYER ((((X NOT MARKF) NOT MARKG) NOT MARKS) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK ${metal_layer}_6ah {
@ $metal_layer density (including dummy) in 200umX200um window with step size 100um is >= 15% and <= 80%.
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking
  SETLAYER X = DENSITY ${metal_layer}ALLi > 0.80 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_${metal_layer}_6ah.log
  OUTLAYER ((((X NOT MARKF) NOT MARKG) NOT MARKS) NOT INDMY) NOT INSIDE EXDRC
}
RULECHECK ${metal_layer}_6b {
@ Max $metal_layer density (including dummy) in 50umX50um window with step size 25um is 90%.
  OUTLAYER (DENSITY ${metal_layer}ALLi > 0.90 WINDOW 50 STEP 25 backup PRINT density_report_${metal_layer}_6b.log) NOT INSIDE EXDRC
}
RULECHECK ${metal_layer}_6c {
@ The max difference between $metal_layer density in 200umX200um with step size 200um and those of the adjacent checking windows (including dummy) is 45%
@ INDMY/MARKG/MARKF/MARKS covered areas are excluded for this rule checking
  SETLAYER X = DENSITY ${metal_layer}ALLi >= 0 WINDOW 200 GRADIENT > 0.45 ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_${metal_layer}_6c.log
  OUTLAYER ((((X NOT MARKF) NOT MARKG) NOT MARKS) NOT INDMY) NOT INSIDE EXDRC
}
RULECHECK ${metal_layer}_6d {
@ Minimum $metal_layer density (including dummy) in 25umX25um window with step size 12.5um is 10%
@ INDMY/MARKG/MARKS covered areas are excluded for this rule checking
  SETLAYER X = DENSITY ${metal_layer}ALLi < 0.1 WINDOW 25 STEP 12.5 backup INSIDE OF LAYER density_checkarea PRINT density_report_${metal_layer}_6d.log
  OUTLAYER (((X NOT MARKG) NOT MARKS) NOT INDMY) NOT INSIDE EXDRC
}
RULECHECK ${metal_layer}_7 {
@ Min Space between metal lines with one or both is 45 degree and the bending length >=0.5um is 0.115
@ (the area with 0.1um distance from bending point need not follow this rule)
  SETLAYER X = ANGLE $metal_layer == 45
  SETLAYER Y = LENGTH X >= 0.5
  OUTLAYER (EXT Y < 0.115 REGION) NOT INSIDE EXDRC
  OUTLAYER (EXT $metal_layer Y < 0.115 REGION corner to edge) NOT INSIDE EXDRC
}

    if { [string equal $Recommended_rules_OTHER YES] == 1 } {

RULECHECK ${metal_layer}_6e_min_R {
@ Average density for $metal_layer inside the dummy block area in 25umX25um window with step size 12.5um is >= 10% and <= 90% when the dummy block area >= 25umX25um.
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded from this rule checking.
@ Device sensitive areas can be waived.
@ NOTICE: It is a recommended rule.
  SETLAYER X = DENSITY ${metal_layer}ALLi < 0.1 WINDOW 25 STEP 12.5 backup PRINT density_report_${metal_layer}6e_min.log
  SETLAYER Y = ((DUMBM OR M2DUB) OR NODMF) NOT (OR INDMY MARKF MARKG MARKS)
  SETLAYER Z = SIZE Y BY 12.5 UNDEROVER
  OUTLAYER (X AND Z) NOT INSIDE EXDRC
}
RULECHECK ${metal_layer}_6e_max_R {
@ Average density for $metal_layer inside the dummy block area in 25umX25um window with step size 12.5um is >= 10% and <= 90% when the dummy block area >= 25umX25um.
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded from this rule checking.
@ Device sensitive areas can be waived.
@ NOTICE: It is a recommended rule.
  SETLAYER X = DENSITY ${metal_layer}ALLi > 0.90 WINDOW 25 STEP 12.5 backup PRINT density_report_${metal_layer}6e_max.log
  SETLAYER Y = ((DUMBM OR ${metal_layer}DUB) OR NODMF) NOT (OR INDMY MARKF MARKG MARKS)
  SETLAYER Z = SIZE Y BY 12.5 UNDEROVER
  OUTLAYER (X AND Z) NOT INSIDE EXDRC
}
    }
  }

}


if { [string equal $Recommended_rules_OTHER YES] == 1 } {
if { $CHECK_M4 == 1} {
RULECHECK M4_2d_R {
@ Min Space between two M4s is 0.16um when one or both M4s width >= 0.4um, and the parallel run length of two M4s is >= 0.4um
  Mn_2b M4ALL 0.4 0.4 0.16
}
}

if { $CHECK_M5 == 1} {
RULECHECK M5_2d_R {
@ Min Space between two M5s is 0.16um when one or both M5s width >= 0.4um, and the parallel run length of two M5s is >= 0.4um
  Mn_2b M5ALL 0.4 0.4 0.16
}
}

if { $CHECK_M6 == 1} {
RULECHECK M6_2d_R {
@ Min Space between two M6s is 0.16um when one or both M6s width >= 0.4um, and the parallel run length of two M6s is >= 0.4um
  Mn_2b M6ALL 0.4 0.4 0.16
}
}

if { $CHECK_M7 == 1} {
RULECHECK M7_2d_R {
@ Min Space between two M7s is 0.16um when one or both M7s width >= 0.4um, and the parallel run length of two M7s is >= 0.4um
  Mn_2b M7ALL 0.4 0.4 0.16
}
}

if { $CHECK_M8 == 1} {
RULECHECK M8_2d_R {
@ Min Space between two M8s is 0.16um when one or both M8s width >= 0.4um, and the parallel run length of two M8s is >= 0.4um
  Mn_2b M8ALL 0.4 0.4 0.16
}
}
}

#//========================
#//  V1 - Via 1 DRC
#//========================

GROUP GV1 V1_?

RULECHECK V1_1 {
@ Fixed V1 size(square shape) is 0.09,exclude MARKS area
  OUTLAYER ((NOT RECTANGLE (V1 NOT GV1) == 0.09 BY == 0.09) NOT V1_slot_SG) NOT INSIDE (MARKS OR EXDRC)
}
RULECHECK V1_2a {
@ Min Space between two V1 is 0.11
  OUTLAYER (EXT V1 < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK V1_2b {
@ Min Space between V1s when array equal to or greater than 4*4 is 0.13
@ Two via regions whose space is < 0.15um are considered to be in the same array.
  SETLAYER X = SIZE V1 BY 0.074 OVERUNDER
  SETLAYER Y = SIZE X BY 0.340 UNDEROVER
  SETLAYER Z = V1 INSIDE Y
  OUTLAYER (EXT Z < 0.13 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK V1_3a_3b {
@ V1 must be fully enclosed by M1.
@ Min M1 enclosure of V1 is 0.030 when M1 enclosure on one or both perpendicular directions<0.03um
  SETLAYER X = RECTANGLE ENC (V1 NOT TOUCH M1) M1 ABUT<90 OUTSIDE ALSO \
  GOOD 0 0.030 OPPOSITE 0 0.030 OPPOSITE

  SETLAYER A = ENC \[X\] M1 < 0.030 OPPOSITE
  SETLAYER D1 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION
  OUTLAYER (D1 NOT INSIDE INST) NOT INSIDE EXDRC

  SETLAYER B = V1 COIN EDGE M1
  SETLAYER D2 = INT B < 0.01 ABUT==90 REGION
  OUTLAYER (D2 NOT INSIDE INST) NOT INSIDE EXDRC

  SETLAYER Y = ENC V1 M1 < 0.030 OPPOSITE REGION
  SETLAYER C1 = V1 COIN EDGE M1
  SETLAYER C2 = V1 COIN EDGE Y
  SETLAYER D3 = INT C1 C2 < 0.01 ABUT==90 REGION
  OUTLAYER (D3 NOT INSIDE INST) NOT INSIDE EXDRC

  OUTLAYER (V1 NOT M1) NOT INSIDE EXDRC
 
#SETLAYER BadV11 = RECTANGLE ENCLOSURE V1 M1 ABUT<90 OUTSIDE ALSO \
#                 GOOD 0 0.03 OPPOSITE 0 0.03 OPPOSITE
#OUTLAYER (BadV11 NOT INSIDE INST) NOT INSIDE EXDRC

#SETLAYER BadV12 = V1 NOT M1
#OUTLAYER (BadV12 NOT INSIDE INST) NOT INSIDE EXDRC*/
}
RULECHECK V1_5a_5b {
@ V1 must be fully enclosed by M2.
@ Min M2 enclosure of V1 is 0.005
@ Min M2 Enclosure of V1 when M2 enclosure on one or both perpendicular directions < 0.02um is 0.02
SETLAYER X = RECTANGLE ENC V1 M2 ABUT<90 OUTSIDE ALSO \
  GOOD 0.005 OPPOSITE 0.02 OPPOSITE 0.005 OPPOSITE 0.02 OPPOSITE

  SETLAYER D1 = ENC X M2 < 0.005 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  OUTLAYER (D1 NOT INSIDE INST) NOT INSIDE EXDRC

  SETLAYER Y = ENC \[X\] M2 < 0.02 OPPOSITE
  SETLAYER D2 = INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION
  OUTLAYER (D2 NOT INSIDE INST) NOT INSIDE EXDRC
  OUTLAYER (V1 NOT M2) NOT INSIDE EXDRC
}

RULECHECK V1_10 {
@ Minimum Space between two neighbor V1s (different net and run length>0) is 0.13um.
  OUTLAYER (EXT V1 < 0.13 ABUT<90 OPPOSITE REGION NOT CONNECTED) NOT INSIDE EXDRC
}

    if { [string equal $Recommended_rules_OTHER YES] == 1 } {

RULECHECK V1_11_12_R {
@ There should be at least two V1s at the intersection of M1and M2 when either M1 or M2 width >= 0.5um
@ There should be at least two V1s at the intersection of M1and M2, if either M1 or M2 is connected to a metal line with width d>=0.5um and space c<0.5um (space between V1s at the intersection and the wide metal)
@ NOTICE: It is a recommended rule.
  SETLAYER X = SIZE (M1 WITH WIDTH >= 0.5) BY 0.499 INSIDE OF M1 STEP 0.01
  SETLAYER SV1 = V1 INTERACT SV1_metal
  OUTLAYER (SV1_metal ENCLOSE (((SV1 INTERACT X) NOT LOGO) NOT MARKG)) NOT INSIDE EXDRC
  SETLAYER Y = SIZE (M2 WITH WIDTH >= 0.5) BY 0.499 INSIDE OF M2 STEP 0.01
  OUTLAYER (SV1_metal ENCLOSE (((SV1 INTERACT Y) NOT LOGO) NOT MARKG) ) NOT INSIDE EXDRC
}
}

RULECHECK V1_14 {
@ It is not allowed V1 overlap with M1 or M2 resistor.
@ M1 resistor definition: (M1 AND M1R).
@ M2 resistor definition: (M2 AND M2R).
  SETLAYER X1 = M1 AND M1R
  SETLAYER X2 = M2 AND M2R
  OUTLAYER (V1 AND (X1 OR X2)) NOT INSIDE EXDRC
}

#RULECHECK V1_15 {
#@ Single V1 is not allowed in "H-shape" M2 when:
#@ 1) The M2 has "H-shape" metal interact with two metal holes: both two metal holes' length (L2) <= 5um and area <= 5um2.
#@ 2) The V1 overlaps on the center metal bar of this "H-shape" M2
#@ 3) The center metal bar has the length (L) <= 1um and the width <= 0.3um
#   SETLAYER V1N = V1 AND (RECTANGLE V1 == 0.09 BY == 0.09)
#   SETLAYER RV1 = V1 AND (RECTANGLE V1 ASPECT != 1) 
#   via_in_H_bar V1N M2 5 5 1 0.3
#
#   OUTLAYER (OUT1 NOT INTERACT RV1) NOT INSIDE EXDRC
#}


#***********************************************
# Vn: Via n (n=2,3,4,5,6,7) design rules
#***********************************************


set via_list { V2 V3 V4 V5 V6 V7 }
foreach via_layer $via_list {
  set tmp CHECK_$via_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
    GROUP G${via_layer} ${via_layer}_?
  set number [string index $via_layer 1]
  set bottom_metal M$number
  set up_metal M[expr $number +1]


RULECHECK ${via_layer}_1 {
@ Fixed $via_layer size (square shape) is 0.09,exclude MARKS area
  OUTLAYER ((NOT RECTANGLE ($via_layer NOT G$via_layer) == 0.09 BY == 0.09) NOT ${via_layer}_slot_SG) NOT INSIDE (MARKS OR EXDRC)
}

RULECHECK ${via_layer}_2a {
@ Space between two $via_layer is 0.11
  OUTLAYER (EXT $via_layer < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK ${via_layer}_2b {
@ Space between ${via_layer}s when array equal to or greater than 4*4 is 0.13.
@ Two via regions whose space is < 0.15um are considered to be in the same array.
  SETLAYER X = SIZE $via_layer BY 0.074 OVERUNDER
  SETLAYER Y = SIZE X BY 0.340 UNDEROVER
  SETLAYER Z = $via_layer INSIDE Y
  OUTLAYER (EXT Z < 0.13 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

#--------------------------------------------------------------------------------------------------------
RULECHECK ${via_layer}_3a_3b {
@ Vn must be fully enclosed by Mn >= 0.005 
@ Min $bottom_metal enclosure of $via_layer  is 0.030 when $bottom_metal enclosure on one or both perpendicular directions<0.03um
 SETLAYER  X = RECTANGLE ENC $via_layer $bottom_metal ABUT<90 OUTSIDE ALSO \
            GOOD 0.005 OPPOSITE 0.030 OPPOSITE 0.005 OPPOSITE 0.030 OPPOSITE

  OUTLAYER  (ENC X $bottom_metal < 0.005 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO) NOT INSIDE EXDRC

  SETLAYER  Y = ENC \[X\] $bottom_metal < 0.030 OPPOSITE
  OUTLAYER  (INT Y < 0.005 ABUT== 90 INTERSECTING ONLY REGION) NOT INSIDE EXDRC
  OUTLAYER ($via_layer NOT $bottom_metal) NOT INSIDE EXDRC 
}
RULECHECK ${via_layer}_5a_5b {
@ Vn must be fully enclosed by Mn+1
@ Min $up_metal enclsoure of $via_layer is 0.005
@ Min $up_metal enclosure of $via_layer  is 0.02 when $up_metal enclosure on one or both perpendicular directions<0.02um
SETLAYER  X = RECTANGLE ENC $via_layer $up_metal ABUT<90 OUTSIDE ALSO \
                GOOD 0.005 OPPOSITE 0.02 OPPOSITE 0.005 OPPOSITE 0.02 OPPOSITE

  OUTLAYER (ENC X $up_metal < 0.005 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO) NOT INSIDE EXDRC

  SETLAYER Y = ENC \[X\] $up_metal < 0.02 OPPOSITE
  OUTLAYER (INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION) NOT INSIDE EXDRC
  OUTLAYER ($via_layer NOT $up_metal) NOT INSIDE EXDRC

  }
#-------------------------------------------------------------------------------------------------------------

RULECHECK ${via_layer}_10 {
@ Minimum Space between two neighbor ${via_layer}s (different net and run length>0) is 0.13um.
  OUTLAYER (EXT $via_layer < 0.13 ABUT<90 OPPOSITE REGION NOT CONNECTED) NOT INSIDE EXDRC
}

    if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK ${via_layer}_11_12_R {
@ There should be at least two ${via_layer}s in the $bottom_metal and $up_metal intersection area when either or both $bottom_metal and $up_metal with width >= 0.5um
@ There should be at least two ${via_layer}s in the $bottom_metal and $up_metal intersection area when either or both $bottom_metal and $up_metal 
@ connected with metal line of width>=0.5um and space between $via_layer and wider metal edge <0.5um
@ NOTICE: It is a recommended rule.

  SETLAYER  X = SIZE ($bottom_metal WITH WIDTH >= 0.5) BY 0.499 INSIDE OF $bottom_metal STEP 0.01
  SETLAYER  S$via_layer = $via_layer INTERACT S${via_layer}_metal
  OUTLAYER  (S${via_layer}_metal ENCLOSE (((S$via_layer INTERACT X) NOT LOGO) NOT MARKG)) NOT INSIDE EXDRC
  SETLAYER  Y = SIZE ($up_metal WITH WIDTH >= 0.5) BY 0.499 INSIDE OF $up_metal STEP 0.01
  OUTLAYER  (S${via_layer}_metal ENCLOSE (((S$via_layer INTERACT Y) NOT LOGO) NOT MARKG)) NOT INSIDE EXDRC
}
    }
#-------------------------------------------------------------------
RULECHECK ${via_layer}_14 {
@ It is not allowed Vn overlap with Mn or Mn+1 resistor.
@ Mn resistor definition: (Mn AND MnR).
@ Mn+1 resistor definition: (Mn+1 AND Mn+1R)
  OUTLAYER ($via_layer AND ($bottom_metal AND ${bottom_metal}R)) NOT INSIDE EXDRC
  OUTLAYER ($via_layer AND ($up_metal AND ${up_metal}R)) NOT INSIDE EXDRC
}
#-----------------------------------------------------------------------
}
}
SETLAYER TMP = AA AND GT
#------------------------for via stack------------------------
for {set j 1} { $j < [expr $total_metal - $top_metal ] } {incr j} {
  SETLAYER V${j}N_M = V${j}N INTERACT st_${j}
  SETLAYER st_${j} = (M${j} AND M[expr $j+1]) ENCLOSE V${j} == 1
  SETLAYER V${j}N = V${j} AND (RECTANGLE V${j} == 0.09 BY == 0.09)
  SETLAYER RV${j} = V${j} AND (RECTANGLE V${j} ASPECT != 1)
#--------------------------------------------------------------------------
if { [expr $total_metal - $top_metal -1 -$j -4] >= 0} {
if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK V${j}_13_R {
@ Single vias stacked by more than 4 layers are not allowed. <=4
  SETLAYER X = V${j}N_M INTERACT (V[expr $j +1]N_M INTERACT (V[expr $j +2]N_M INTERACT (V[expr $j +3]N_M INTERACT V[expr $j +4]N_M)))
  OUTLAYER X NOT INSIDE EXDRC
}
}
}
#-----------------------------------------------------------------------
if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK V${j}_15_R {
@ Single Vn is not allowed in "H-shape" Mn+1 when:
@ 1) The Mn+1 has "H-shape" metal interact with two metal holes: both two metal holes' length (L2) <= 5um and area <= 5um2.
@ 2) The Vn overlaps on the center metal bar of this "H-shape" Mn+1
@ 3) The center metal bar has the length (L) <= 1um and the width <= 0.3um
  via_in_H_bar V${j}N M[expr $j +1] 5 5 1 0.3
  OUTLAYER (Z INTERACT V${j}N == 1) NOT INSIDE EXDRC
}
}
#---------------------------------------------------------------
}
#----stack-----







#=======================
#  TV1 - Top Via 1a DRC
#=======================


if { [set CHECK_TV1] == 1 } {
  set bottom_metal_list { M8 M7 M6 M5 M4 M3 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
  }
  
GROUP GTV1 TV1_?

RULECHECK TV1_1 {
@ Fixed TV1 size (square shape) is 0.36,exclude MARKS area
  OUTLAYER  ((NOT RECTANGLE (TV1 NOT GTV1) == 0.36 BY == 0.36) NOT MARKG) NOT INSIDE (MARKS OR EXDRC)
  OUTLAYER  (NOT RECTANGLE (RECTANGLE (TV1 AND MARKG)) == 0.36 BY == 0.36 ) NOT INSIDE (MARKS OR EXDRC)
}

RULECHECK TV1_2a {
@ Min Space between two TV1s is 0.34
  OUTLAYER  (EXT TV1 < 0.34 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK TV1_2b {
@ Min Space between TV1s within array greater or equal to 3x3 (Two via regions whose space is <= 0.56um are considered to be in the same array) is 0.5

  SETLAYER  X = SIZE TV1 BY 0.28 OVERUNDER
  SETLAYER  Y = SIZE X BY 0.855 UNDEROVER
  SETLAYER  Z = TV1 INSIDE Y
  OUTLAYER  (EXT Z < 0.5 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK TV1_3a_3b {
@ Min $bottom_metal fully enclosure of TV1 ($bottom_metal is Metal layer directly underneath TV1) is 0.01
@ Min $bottom_metal enclosure of TV1 is 0.05 when $bottom_metal enclosure on one or both perpendicular directions< 0.05um ($bottom_metal is Metal layer directly underneath TV1)
SETLAYER  X = RECTANGLE ENC TV1 $bottom_metal ABUT<90 OUTSIDE ALSO \
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE

  OUTLAYER  (ENC X $bottom_metal < 0.01 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO) NOT INSIDE EXDRC

  SETLAYER  Y = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  OUTLAYER  (INT Y < 0.01 ABUT==90 REGION INTERSECTING ONLY) NOT INSIDE EXDRC
  OUTLAYER  (TV1 NOT $bottom_metal) NOT INSIDE EXDRC
}
RULECHECK TV1_5 {
@ Min TM1 fully enclosure of TV1 (four directions) is 0.02
  OUTLAYER  (ENC TV1 TM1 < 0.02 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}
RULECHECK TV1_9 {
@ It is not allowed TV1 overlap with Mn or TM1 or STM1 resistor.
@ Mn resistor definition: (Mn AND MnR).
@ TM1 resistor definition: (TM1 AND TM1R).
   SETLAYER X1 = $bottom_metal AND ${bottom_metal}R
   SETLAYER X2 = TM1 AND TM1R
   OUTLAYER (TV1 AND (OR X1 X2)) NOT INSIDE EXDRC
}

if { [string equal $Recommended_rules_CHECK YES] == 1 } {
RULECHECK TV1_10_R {
@ There should be at least two square TV1s at the intersection of Mn and TM1 when either Mn or TM1 width >= 0.5um
SETLAYER TV1_SQ = RECTANGLE TV1 ASPECT == 1
SETLAYER X1_Mn = $bottom_metal ENCLOSE ($bottom_metal WITH WIDTH >= 0.5)
SETLAYER X1_TM1 = TM1 ENCLOSE (TM1 WITH WIDTH >= 0.5)
SETLAYER TM1Mn = $bottom_metal AND TM1
SETLAYER X1 = X1_Mn OR X1_TM1
OUTLAYER (TM1Mn INTERACT TV1_SQ == 1) INTERACT X1
}
}

#=========================
#  TM1 - Top Metal 1a DRC
#=========================



GROUP GTM1 TM1_?

RULECHECK TM1_1 {
@ Min TM1 width is 0.40um
  OUTLAYER (INT TM1 < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK TM1_2a {
@ Min Space between two TM1s is 0.40um,DRC waive check 89 to 90 degree spaces in the INDMY region.
  OUTLAYER ((EXT TM1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((EXT TM1 < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK TM1_2b {
@ Min Space between two TM1s is 0.5um when one or both TM1 width or length >=2um, and the run length of two TM1s is >= 2um
  Mn_2b TM1ALL 2 2 0.5
}

RULECHECK TM1_3 {
@ Min TM1 area is 0.40
  OUTLAYER (AREA TM1 < 0.40) NOT INSIDE EXDRC
}

RULECHECK TM1_4 {
@ Min Enclosed dielectic area by TM1 is 0.6
  SETLAYER X = (HOLES TM1 INNER) NOT TM1
  OUTLAYER (AREA X < 0.6) NOT INSIDE EXDRC
}

RULECHECK TM1_5 {
@ Max TM1 width is 20
@ (Top metal bond pad application and INDMY regions can be waived.)
  SETLAYER X = TM1 WITH WIDTH > 20
  OUTLAYER ((X NOT INTERACT PA) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK TM1_6a {
@ TM1 density (including dummy) in 200umX200um window with step size 100um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
  SETLAYER X = DENSITY TM1ALLi < 0.20 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_TM1a_6a.log
  SETLAYER Y = OR MARKF MARKG MARKS PA INDMY
  OUTLAYER (X NOT Y) NOT INSIDE EXDRC
}

RULECHECK TM1_6a_PA {
@ TM1 density (including dummy) in 200umX200um window with step size 100um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
@ This rule checks PA area. It can be waived.
  SETLAYER X = DENSITY TM1ALLi < 0.20 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_TM1a_6a_PA.log
  OUTLAYER (X AND PA) NOT INSIDE EXDRC
}

RULECHECK TM1_6b {
@ TM1 density (including dummy) in 200umX200um window with step size 100um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
  SETLAYER X = DENSITY TM1ALLi > 0.85 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_TM1a_6b.log
  SETLAYER Y = OR MARKF MARKG MARKS PA INDMY
  OUTLAYER (X NOT Y) NOT INSIDE EXDRC
}

RULECHECK TM1_6b_PA {
@ TM1 density (including dummy) in 200umX200um window with step size 100um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
@ This rule checks PA area. It can be waived.
  SETLAYER X = DENSITY TM1ALLi > 0.85 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_TM1a_6b_PA.log
  OUTLAYER (X AND PA) NOT INSIDE EXDRC
}

}


#---------------------------------------------------------------------------------------------------------------------------------------------------

#=====================================================
#  Special offering for 2X design rule STV1-STM1
#=====================================================


#==========================
#  STV1 - Top Via STV1 DRC
#==========================


if { [set CHECK_STV1] == 1 } {
  set bottom_metal_list { M8 M7 M6 M5 M4 M3 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
  }
  
GROUP GSTV1 STV1_?

RULECHECK STV1_1 {
@ Fixed STV1 size (square shape) except guard ring and seal ring application is 0.2
  OUTLAYER  ((NOT RECTANGLE (STV1 NOT GSTV1) == 0.2 BY == 0.2) NOT MARKG) NOT INSIDE EXDRC
  OUTLAYER  (NOT RECTANGLE (RECTANGLE (STV1 AND MARKG)) == 0.2 BY == 0.2 ) NOT INSIDE EXDRC
}

RULECHECK STV1_2a {
@ Min Space between two STV1s is 0.2
  OUTLAYER  (EXT STV1 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK STV1_2b {
@ Min Space between STV1s within array greater or equal to 3x3 (Two via regions whose space is <= 0.30um are considered to be in the same array) is 0.25
@ NOTICE: It is a recommended rule.
  SETLAYER  X = SIZE STV1 BY 0.15 OVERUNDER
  SETLAYER  Y = SIZE X BY 0.455 UNDEROVER
  SETLAYER  Z = STV1 INSIDE Y
  OUTLAYER  (EXT Z < 0.25 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK STV1_3a_3b {
@ STV1 must be fully enclosed by $bottom_metal.
@ Min $bottom_metal enclosure of STV1 ($bottom_metal is Metal layer directly underneath STV1) is 0
@ Min $bottom_metal enclosure of STV1 is 0.05 when $bottom_metal enclosure on one or both perpendicular directions< 0.05um ($bottom_metal is Metal layer directly underneath STV1)
#  OUTLAYER (RECTANGLE ENC STV1 $bottom_metal ABUT < 90 OUTSIDE ALSO \
#                         GOOD 0 0.05 OPPOSITE 0 0.05 OPPOSITE) NOT INSIDE EXDRC
#  OUTLAYER (STV1 NOT $bottom_metal) NOT INSIDE EXDRC
 
   SETLAYER X = RECTANGLE ENC (STV1 NOT TOUCH $bottom_metal) $bottom_metal ABUT < 90 OUTSIDE ALSO \
   GOOD 0 0.05 OPPOSITE 0 0.05 OPPOSITE


   SETLAYER A = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
   SETLAYER D1 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION
   OUTLAYER D1 NOT INSIDE EXDRC

   SETLAYER B = STV1 COIN EDGE $bottom_metal
   SETLAYER D2 = INT B < 0.01 ABUT==90 REGION
   OUTLAYER D2 NOT INSIDE EXDRC

   
   SETLAYER Y = ENC STV1 $bottom_metal< 0.05 OPPOSITE REGION
   SETLAYER C1 = STV1 COIN EDGE $bottom_metal 
   SETLAYER C2 = STV1 COIN EDGE Y
   SETLAYER D3 = INT C1 C2 < 0.01 ABUT==90 REGION
   OUTLAYER D3 NOT INSIDE EXDRC
   
   OUTLAYER (STV1 NOT $bottom_metal) NOT INSIDE EXDRC  
}

RULECHECK STV1_5a_5b {
@ STV1 must be fully enclosed by STM1.
@ Min STM1 enclosure of STV1 is 0.02
@ Min STM1 Enclosure of STV1 is 0.03 when STM1 enclosure on one or both perpendicular directions< 0.03um
# OUTLAYER (RECTANGLE ENC STV1 STM1 ABUT < 90 OUTSIDE ALSO \
#                         GOOD 0.02 OPPOSITE 0.03 OPPOSITE 0.02 OPPOSITE 0.03 OPPOSITE) NOT INSIDE EXDRC

#  OUTLAYER (STV1 NOT STM1) NOT INSIDE EXDRC


  SETLAYER X = RECTANGLE ENC STV1 STM1 ABUT < 90 OUTSIDE ALSO \
               GOOD 0.02 OPPOSITE 0.03 OPPOSITE 0.02 OPPOSITE 0.03 OPPOSITE       
 
  SETLAYER D1 = ENC X STM1 < 0.02 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  OUTLAYER D1 NOT INSIDE EXDRC

  SETLAYER Y = ENC \[X\] STM1 < 0.03 OPPOSITE
  SETLAYER D2 = INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION
  OUTLAYER D2 NOT INSIDE EXDRC
  OUTLAYER (STV1 NOT STM1) NOT INSIDE EXDRC
 }

RULECHECK STV1_9 {
@ There should be at least two square STV1s in this Mn and STM1 intersection area when either or both Mn (Mn is Metal layer directly underneath STV1) and STM1 width is > 0.9um.
SETLAYER STV1_SQ = RECTANGLE STV1 ASPECT == 1
SETLAYER X1_Mn = $bottom_metal ENCLOSE ($bottom_metal WITH WIDTH > 0.9)
SETLAYER X1_STM1 = STM1 ENCLOSE (STM1 WITH WIDTH > 0.9)
SETLAYER STM1Mn = $bottom_metal AND STM1
SETLAYER X1 = X1_Mn OR X1_STM1
OUTLAYER (STM1Mn INTERACT STV1_SQ == 1) INTERACT X1
}

RULECHECK STV1_10 {
@ It is not allowed STV1 overlap with Mn or STM1 resistor.
@ Mn resistor definition: (Mn AND MnR).
@ STM1 resistor definition: (STM1 AND STM1R).
  SETLAYER X1 = $bottom_metal AND ${bottom_metal}R
  SETLAYER X2 = STM1 AND STM1R
  OUTLAYER (STV1 AND (X1 OR X2)) NOT INSIDE EXDRC
}



#=============================
#  STM1 - Top Metal STM1 DRC
#=============================

GROUP GSTM1 STM1_?


RULECHECK STM1_1 {
@ Min STM1 width is 0.20
  OUTLAYER (INT STM1 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
# OUTLAYER INT STM1DM < 0.20 REGION
}

RULECHECK STM1_2a {
@ Min Space between STM1s is 0.20,DRC waive check 89 to 90 degree spaces in the INDMY region.
  OUTLAYER ((EXT STM1 < 0.20 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((EXT STM1 < 0.20 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
#  OUTLAYER EXT STM1 STM1DM < 0.20 REGION
#  OUTLAYER EXT STM1DM < 0.20 REGION
}

RULECHECK STM1_2b {
@ Min Space between two STM1s is 0.25 when one or both STM1 width or length >= 0.4um, and the run length of two STM1s is >= 0.4um
  Mn_2b STM1ALL 0.4 0.4 0.25
}

RULECHECK STM1_2c {
@ Min Space between two STM1s is 0.40 when one or both STM1 width or length >= 2um, and the run length of two STM1s is >= 2um
  Mn_2b STM1ALL 2 2 0.4
}

RULECHECK STM1_2d {
@ Min Space between two STM1s is 0.50 when one or both STM1 width or length >= 10um, and the run length of two STM1s is >= 2um
  Mn_2b STM1ALL 2 10 0.5
}

RULECHECK STM1_3 {
@ Min STM1 area is 0.12
  OUTLAYER (AREA STM1 < 0.12) NOT INSIDE EXDRC
}

RULECHECK STM1_4 {
@ Min Enclosed dielectic area by STM1 is 0.26
  SETLAYER X = (HOLES STM1 INNER) NOT STM1  
  OUTLAYER (AREA X < 0.26) NOT INSIDE EXDRC
}

RULECHECK STM1_5 {
@ Max STM1 width is 20,except INDMY region.
  OUTLAYER ((STM1 WITH WIDTH > 20) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK STM1_6_l {
@ STM1 density (including dummy) in 200umX200um window with step size 100um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
  SETLAYER X = DENSITY STM1ALLi < 0.20 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_STM1a_6_l.log
  SETLAYER Y = OR MARKF MARKG MARKS PA INDMY
  OUTLAYER (X NOT Y) NOT INSIDE EXDRC
}

RULECHECK STM1_6_h {
@ STM1 density (including dummy) in 200umX200um window with step size 100um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
  SETLAYER X = DENSITY STM1ALLi > 0.85 WINDOW 200 STEP 100 backup INSIDE OF LAYER density_checkarea PRINT density_report_STM1a_6_h.log
  SETLAYER Y = OR MARKF MARKG MARKS PA INDMY
  OUTLAYER (X NOT Y) NOT INSIDE EXDRC
}

RULECHECK STM1_7 {
@ Min Space between STM1 metal lines with one or both are 45 degree bent metal lines is 0.22
  SETLAYER X = ANGLE STM1 == 45
  OUTLAYER (EXT X STM1 < 0.22 ABUT<90 REGION) NOT INSIDE EXDRC
}

}


#=====================================================
#  Special offering for 2X design rule STV2-STM2
#=====================================================


#==========================
#  STV2 - Top Via STV2 DRC
#==========================


if { [set CHECK_STV2] == 1 } {
  set bottom_metal_list {STM1 M8 M7 M6 M5 M4 M3 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
  }
  
GROUP GSTV2 STV2_?

RULECHECK STV2_1 {
@ Fixed STV1 size (square shape) is 0.2,exclude MARKS area
  OUTLAYER  ((NOT RECTANGLE (STV2 NOT GSTV2) == 0.2 BY == 0.2) NOT MARKG) NOT INSIDE (MARKS OR EXDRC)
  OUTLAYER  (NOT RECTANGLE (RECTANGLE (STV2 AND MARKG)) == 0.2 BY == 0.2) NOT INSIDE (MARKS OR EXDRC)
}

RULECHECK STV2_2a {
@ Min Space between two STV2s is 0.2
  OUTLAYER  (EXT STV2 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK STV2_2b {
@ Min Space between STV2s within array greater or equal to 4x4 (Two via regions whose space is <= 0.30um are considered to be in the same array) is 0.25
@ NOTICE: It is a recommended rule.
  SETLAYER  X = SIZE STV2 BY 0.15 OVERUNDER
  SETLAYER  Y = SIZE X BY 0.655 UNDEROVER
  SETLAYER  Z = STV2 INSIDE Y
  OUTLAYER  (EXT Z < 0.25 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK STV2_3a_3b {
@ STV2 must be fully enclosed by STM1.
@ Min $bottom_metal fully enclosure of STV2 ($bottom_metal is Metal layer directly underneath STV2) is 0
@ Min $bottom_metal enclosure of STV2 is 0.05 when $bottom_metal enclosure on one or both perpendicular directions< 0.05um ($bottom_metal is Metal layer directly underneath STV2)
# OUTLAYER (RECTANGLE ENC STV2 $bottom_metal ABUT < 90 OUTSIDE ALSO \
#                         GOOD 0 0.05 OPPOSITE 0 0.05 OPPOSITE) NOT INSIDE EXDRC
#  OUTLAYER  (STV2 NOT $bottom_metal) NOT INSIDE EXDRC

  SETLAYER X = RECTANGLE ENC (STV2 NOT TOUCH $bottom_metal) $bottom_metal ABUT < 90 OUTSIDE ALSO \
               GOOD 0 0.05 OPPOSITE 0 0.05 OPPOSITE   
  
  SETLAYER A = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  SETLAYER D1 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION
  OUTLAYER D1 NOT INSIDE EXDRC

  SETLAYER B = STV2 COIN EDGE $bottom_metal
  SETLAYER D2 = INT B < 0.01 ABUT==90 REGION
  OUTLAYER D2 NOT INSIDE EXDRC

  SETLAYER Y = ENC STV2 $bottom_metal < 0.05 OPPOSITE REGION
  SETLAYER C1 = STV2 COIN EDGE $bottom_metal
  SETLAYER C2 = STV2 COIN EDGE Y
  SETLAYER D3 = INT C1 C2 < 0.01 ABUT==90 REGION
  OUTLAYER D3 NOT INSIDE EXDRC

  OUTLAYER (STV2 NOT $bottom_metal) NOT INSIDE EXDRC 
}

RULECHECK STV2_5a_5b {
@ STV2 must be fully enclosed by STM2.
@ Min STM1 fully enclosure of STV2 is 0
@ Min STM1 Enclosure of STV2 is 0.03 when STM2 enclosure on one or both perpendicular directions< 0.03um
#  OUTLAYER (RECTANGLE ENC STV2 STM2 ABUT < 90 OUTSIDE ALSO \
#                         GOOD 0 0.03 OPPOSITE 0 0.03 OPPOSITE) NOT INSIDE EXDRC

#  OUTLAYER (STV2 NOT STM2) NOT INSIDE EXDRC
  

   SETLAYER X =  RECTANGLE ENC STV2 STM2 ABUT < 90 OUTSIDE ALSO \
                 GOOD 0 0.03 OPPOSITE 0 0.03 OPPOSITE


   SETLAYER A = ENC \[X\] STM2 < 0.03 OPPOSITE
   SETLAYER D1 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION
   OUTLAYER D1 NOT INSIDE EXDRC

   SETLAYER B = STV2 COIN EDGE STM2
   SETLAYER D2 = INT B < 0.01 ABUT==90 REGION
   OUTLAYER D2 NOT INSIDE EXDRC

   SETLAYER Y = ENC STV2 STM2 < 0.03 OPPOSITE REGION
   SETLAYER C1 = STV2 COIN EDGE STM2
   SETLAYER C2 = STV2 COIN EDGE Y
   SETLAYER D3 = INT C1 C2 < 0.01 ABUT==90 REGION
   OUTLAYER D3 NOT INSIDE EXDRC

  OUTLAYER (STV2 NOT STM2) NOT INSIDE EXDRC
}

RULECHECK STV2_9 {
@ There should be at least two square STV2s in this Mn and STM2 intersection area when either or both Mn (Mn is Metal layer directly underneath STV1) and STM2 width is > 0.9um.
SETLAYER STV2_SQ = RECTANGLE STV2 ASPECT == 1
SETLAYER X1_${bottom_metal} = ${bottom_metal} ENCLOSE (${bottom_metal} WITH WIDTH > 0.9)
SETLAYER X1_STM2 = STM2 ENCLOSE (STM2 WITH WIDTH > 0.9)
SETLAYER ${bottom_metal}STM2 = ${bottom_metal} AND STM2
SETLAYER X1 = X1_${bottom_metal} OR X1_STM2
OUTLAYER (${bottom_metal}STM2 INTERACT STV2_SQ == 1) INTERACT X1
}




#=============================
#  STM2 - Top Metal STM2 DRC
#=============================

GROUP GSTM2 STM2_?


RULECHECK STM2_1 {
@ Min STM2 width is 0.20,DRC waive check 89 to 90 degree widths in the INDMY region.
  OUTLAYER ((INT STM2 < 0.2 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((INT STM2 < 0.2 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
#  OUTLAYER INT STM2DM < 0.20 REGION
}

RULECHECK STM2_2a {
@ Min Space between STM2s is 0.20,DRC waive check 89 to 90 degree spaces in the INDMY region
  OUTLAYER ((EXT STM2 < 0.20 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((EXT STM2 < 0.20 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
#  OUTLAYER EXT STM2 STM2DM < 0.20 REGION
#  OUTLAYER EXT STM2DM < 0.20 REGION
}

RULECHECK STM2_2b {
@ Min Space between two STM2s is 0.25 when one or both STM2 width or length >= 0.4um, and the run length of two STM2s is >= 0.4um
  Mn_2b STM2ALL 0.4 0.4 0.25
}

RULECHECK STM2_2c {
@ Min Space between two STM2s is 0.40 when one or both STM2 width or length >= 2um, and the run length of two STM2s is >= 2um
  Mn_2b STM2ALL 2 2 0.4
}

RULECHECK STM2_2d {
@ Min Space between two STM2s is 0.50 when one or both STM2 width or length >= 10um, and the run length of two STM2s is >= 2um
 Mn_2b STM2ALL 2 10 0.5
}

RULECHECK STM2_3 {
@ Min STM1 area is 0.12
  OUTLAYER (AREA STM2 < 0.12) NOT INSIDE EXDRC
}

RULECHECK STM2_4 {
@ Min Enclosed dielectic area by STM2 is 0.26
  SETLAYER X = (HOLES STM2 INNER) NOT STM2
  OUTLAYER (AREA X < 0.26) NOT INSIDE EXDRC
}

RULECHECK STM2_5 {
@ Max STM2 width is 30
@ Top metal bondpad application and INDMY regions can be waived.
  SETLAYER X = STM2 WITH WIDTH > 30
  OUTLAYER ((X NOT INTERACT PA) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK STM2_6 {
@ Min Space between metal lines with one or both are 45 degree bent metal lines is 0.22
  SETLAYER X = ANGLE STM2 == 45
  OUTLAYER (EXT X STM2 < 0.22 ABUT<90 REGION) NOT INSIDE EXDRC
}


RULECHECK STM2_8_l {
@ STM2 density (including dummy) in 400umX400um window with step size 200um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
  SETLAYER X = DENSITY STM2ALLi < 0.20 WINDOW 400 STEP 200 backup INSIDE OF LAYER density_checkarea PRINT density_report_STM2_8_l.log
  SETLAYER Y = OR MARKF MARKG MARKS PA INDMY
  OUTLAYER (X NOT Y) NOT INSIDE EXDRC
}

RULECHECK STM2_8_h {
@ STM2 density (including dummy) in 400umX400um window with step size 200um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
  SETLAYER X = DENSITY STM2ALLi > 0.85 WINDOW 400 STEP 200 backup INSIDE OF LAYER density_checkarea PRINT density_report_STM2_8_h.log
  SETLAYER Y = OR MARKF MARKG MARKS PA INDMY
  OUTLAYER (X NOT Y) NOT INSIDE EXDRC
}


}


#---------------------------------------------------------------------------------------------------------------------------------------------------

if { [set CHECK_TV2] == 1 } {
 
#=======================
#  TV2 - Top Via 2 DRC
#=======================


  set bottom_metal_list { STM1 TM1 M8 M7 M6 M5 M4 M3 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
    }

  if { [set MTT2_UTV2] == 0 } {

 
GROUP GTV2 TV2_?

RULECHECK TV2_1 {
@ Fixed TV2 size (square shape) is 0.36,exclude MARKS area
  OUTLAYER ((NOT RECTANGLE (TV2 NOT GTV2) == 0.36 BY == 0.36) NOT MARKG) NOT INSIDE (MARKS OR EXDRC)
  OUTLAYER (NOT RECTANGLE (RECTANGLE (TV2 AND MARKG)) == 0.36 BY == 0.36 ) NOT INSIDE (MARKS OR EXDRC)
}

RULECHECK TV2_2a {
@ Min Space between two TV2s is 0.34
  OUTLAYER (EXT TV2 < 0.34 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK TV2_2b {
@ Min Recommended space between TV2s within array greater or equal to 3x3 (Two via regions whose space is <=0.56um are considered to be in the same array) is 0.5
@ NOTICE: It is a recommended rule.
  SETLAYER X = SIZE TV2 BY 0.28 OVERUNDER
  SETLAYER Y = SIZE X BY 0.855 UNDEROVER
  SETLAYER Z = TV2 INSIDE Y
  OUTLAYER (EXT Z < 0.5 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
 
RULECHECK TV2_3a_3b {
@ Min $bottom_metal fully enclosure of TV2 is 0.01
@ Min $bottom_metal enclosure of TV2 is 0.05 when TM1 enclosure on one or both perpendicular directions < 0.05um

SETLAYER X = RECTANGLE ENC TV2 $bottom_metal ABUT<90 OUTSIDE ALSO \
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE

  OUTLAYER (ENC X $bottom_metal < 0.01 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO) NOT INSIDE EXDRC

  SETLAYER Y = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  OUTLAYER (INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION) NOT INSIDE EXDRC
  OUTLAYER (TV2 NOT $bottom_metal) NOT INSIDE EXDRC
}

RULECHECK TV2_5 {
@ Min TV2 fully enclosure by TM2 (four directions) is 0.02
  OUTLAYER (ENC TV2 TM2 < 0.02 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK TV2_10 {
@ It is not allowed TV2 overlap with Mn/TM1/STM1 resistor when Mn/TM1/STM1 directly underneath TV2. And It is not allowed TV2 overlap with TM2 resistor when TM2 directly above TV2.
@ Mn resistor definition: (Mn AND MnR).
@ TM1 resistor definition: (TM1 AND TM1R)
@ TM2 resistor definition: (TM2 AND TM2R).
@ STM1 resistor definition: (STM1 AND STM1R).
  SETLAYER X1 = $bottom_metal AND ${bottom_metal}R
  SETLAYER X2 = TM2 AND TM2R
  OUTLAYER (TV2 AND (OR X1 X2 )) NOT INSIDE EXDRC
}

if { [string equal $Recommended_rules_CHECK YES] == 1 } {
RULECHECK TV2_11_R {
@ There should be at least two square TV2s at the intersection of Mn/TM1/STM1 and TM2 when either metal width >= 0.5um
SETLAYER TV2_SQ = RECTANGLE TV2 ASPECT == 1
SETLAYER X1_${bottom_metal} = ${bottom_metal} ENCLOSE (${bottom_metal} WITH WIDTH >= 0.5)
SETLAYER X1_TM2 = TM2 ENCLOSE (TM2 WITH WIDTH >= 0.5)
SETLAYER ${bottom_metal}TM2 = ${bottom_metal} AND TM2
SETLAYER X1 = X1_${bottom_metal} OR X1_TM2
OUTLAYER (${bottom_metal}TM2 INTERACT TV2_SQ == 1) INTERACT X1
}
}


#=========================
#  TM2 - Top Metal 2 DRC
#=========================


GROUP GTM2 TM2_?

RULECHECK TM2_1 {
@ Min TM2 width is 0.40,DRC waive check 89 to 90 degree widths in the INDMY region
  OUTLAYER ((INT TM2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((INT TM2 < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2_2a {
@ Min Space between TM2s is 0.40,DRC waive check 89 to 90 degree spaces in the INDMY region
  OUTLAYER ((EXT TM2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((EXT TM2 < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC 
}

RULECHECK TM2_2b {
@ Min Space between two TM2s when one or both TM2 width or length >= 2um, and the run length of two TM2s is >= 2um is 0.5
  Mn_2b TM2ALL 2 2 0.5
}

RULECHECK TM2_3 {
@ Min TM2 area is 0.40
  OUTLAYER (AREA TM2 < 0.40) NOT INSIDE EXDRC
}

RULECHECK TM2_4 {
@ Min Enclosed dielectic area by TM2 is 0.6
  SETLAYER X = (HOLES TM2 INNER) NOT TM2
  OUTLAYER (AREA X < 0.6) NOT INSIDE EXDRC
}

RULECHECK TM2_5 {
@ Max TM2 width is 30
@ Top metal bondpads and INDMY regions can be waived.
  SETLAYER X = TM2 WITH WIDTH > 30.00
  OUTLAYER ((X NOT INTERACT PA) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2_7_l {
@ TM2 density (including dummy) in 400umX400um window with step size 200um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ Top metal bond pad areas can be waived.
  SETLAYER X = DENSITY TM2ALLi < 0.20 WINDOW 400 STEP 200 backup INSIDE OF LAYER density_checkarea PRINT density_report_TM2_7_l.log
  SETLAYER Y = ((INDMY OR MARKF) OR MARKG) OR MARKS
  OUTLAYER (X NOT Y) NOT INSIDE EXDRC
}

RULECHECK TM2_7_h {
@ TM2 density (including dummy) in 400umX400um window with step size 200um is >= 20% and <= 85%. 
@ INDMY/MARKF/MARKG/MARKS covered areas are excluded for this rule checking. 
@ Top metal bond pad areas can be waived.
  SETLAYER X = DENSITY TM2ALLi > 0.85 WINDOW 400 STEP 200 backup INSIDE OF LAYER density_checkarea PRINT density_report_TM2_7_h.log
  SETLAYER Y = ((INDMY OR MARKF) OR MARKG) OR MARKS
  OUTLAYER (X NOT Y) NOT INSIDE EXDRC
}

  } elseif { [set MTT2_UTV2] == 1 } {
  

#=======================================
# UTV2  -  For RF product application
#=======================================

GROUP GUTV2 UTV2_?

RULECHECK UTV2_1 {
@ Fixed UTV2 size (square shape) is 0.36,exclude MARKS area
  OUTLAYER ((NOT RECTANGLE (TV2 NOT GTV2) == 0.36 BY == 0.36) NOT MARKG) NOT INSIDE (MARKS OR EXDRC)
  OUTLAYER (NOT RECTANGLE (RECTANGLE (TV2 AND MARKG)) == 0.36 BY == 0.36) NOT INSIDE (MARKS OR EXDRC)
}
RULECHECK UTV2_2a {
@ Min Space between two UTV2s is 0.34
  OUTLAYER (EXT TV2 < 0.34 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK UTV2_2b {
@ Recommended space between UTV2s is 0.5 when array equal to or greater than 4x4. 
@ (Two via regions whose space is <=0.56um are considered to be in the same array.)
@ NOTICE: It is a recommended rule.
  SETLAYER X = SIZE TV2 BY 0.28 OVERUNDER
  SETLAYER Y = SIZE X BY 1.22 UNDEROVER
  SETLAYER Z = TV2 INSIDE Y
  OUTLAYER (EXT Z < 0.5 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK UTV2_3_4 {
@ Min $bottom_metal enclosure of UTV2 is 0.01
@ Min $bottom_metal enclosure of UTV2 is 0.05 when $bottom_metal enclosure on perpendicular directions < 0.05um

  SETLAYER X = RECTANGLE ENC TV2 $bottom_metal ABUT<90 OUTSIDE ALSO \
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE

  OUTLAYER (ENC X $bottom_metal < 0.01 ABUT<90 SINGULAR OVERLAP OUTSIDE ALSO REGION) NOT INSIDE EXDRC

  SETLAYER Y = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  OUTLAYER (INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION) NOT INSIDE EXDRC
  OUTLAYER (TV2 NOT $bottom_metal) NOT INSIDE EXDRC 
}
RULECHECK UTV2_5 {
@ Min MTT2 enclosure of UTV2 (four directions) is 0.3
  OUTLAYER (ENC TV2 TM2 < 0.3 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}

#=======================================
#  MTT2 - For RF product application
#=======================================


GROUP GMTT2 MTT2_?

RULECHECK MTT2_1 {
@ Min MTT2 metal width is 1.50,DRC waive check 89 to 90 degree widths in the INDMY region
  OUTLAYER ((INT TM2 < 1.50 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((INT TM2 < 1.50 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
#  OUTLAYER INT TM2DUM < 1.50 SINGULAR REGION
}
RULECHECK MTT2_2a {
@ Min Space between MTT2s is 1.5,DRC waive check 89 to 90 degree spaces in the INDMY region
  OUTLAYER ((EXT TM2 < 1.50 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  OUTLAYER ((EXT TM2 < 1.50 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
#  OUTLAYER EXT TM2 TM2DUM < 1.50 SINGULAR REGION
#  OUTLAYER EXT TM2DUM < 1.50 SINGULAR REGION
}
RULECHECK MTT2_2b {
@ Min Space between two MTT2s  is 2.0 when one or both MTT2 width or length >= 16um, and the run length of two MTT2s >2um
  Mn_2b_SPECIAL TM2ALL 2.001 16 2
}
RULECHECK MTT2_5 {
@ Space between an Inductor MTT2 and other MTT2 (including Inductor MTT2)
@ Inductor MTT2 definition: (INDMY AND MTT2)
  OUTLAYER (EXT (TM2 AND INDMY) (TM2 NOT INDMY) < 30 OPPOSITE REGION) NOT INSIDE EXDRC
}
RULECHECK MTT2_6 {
@ Min Metal area (in um2) is 6.00
@ DRC checking allows 0.0004um2 tolerance in INDMY region.
  SETLAYER TM2_1 = TM2 NOT INTERACT INDMY
  SETLAYER TM2_2 = TM2 INTERACT INDMY
  OUTLAYER (AREA TM2_1 < 6.00) NOT INSIDE EXDRC
  OUTLAYER (AREA TM2_2 < 6.00 - 0.0004 ) NOT INSIDE EXDRC
}
RULECHECK MTT2_7 {
@ Min Enclosed dielectic area by MTT2s is 6.0
@ DRC checking allows 0.0004um2 tolerance in INDMY region.
  SETLAYER X = (HOLES TM2 INNER) NOT TM2
  SETLAYER X1 = X NOT INTERACT INDMY
  SETLAYER X2 = X INTERACT INDMY
  OUTLAYER (AREA X1 < 6.0) NOT INSIDE EXDRC
  OUTLAYER (AREA X2 < 6.0 - 0.0004) NOT INSIDE EXDRC
}
RULECHECK MTT2_8 {
@ Max MTT2 width is 50, except bond pad and INDMY regions.
  SETLAYER X = TM2 WITH WIDTH > 50
  OUTLAYER ((X NOT INTERACT PA) NOT INDMY) NOT INSIDE EXDRC
}
RULECHECK MTT2_9a  {
@ Max. MTT2 density (including dummy) in 400umX400um window with step size 200um is 70%
  OUTLAYER (DENSITY TM2ALLi > 0.70 WINDOW 400 STEP 200 backup PRINT density_report_MTT2_9a.log) NOT INSIDE EXDRC
}
RULECHECK MTT2_9b {
@ Max MTT2 pattern density on the whole chip (including dummy patterns) is 55%
  OUTLAYER (DENSITY TM2ALLi > 0.55 PRINT density_report_MTT2_9b.log) NOT INSIDE EXDRC
}


    if { [string equal $Recommended_rules_OTHER YES] == 1 } {

RULECHECK MTT2_9c_R {
@ Recommend the average MTT2 density of whole chip is larger than 20% (including dummy patterns), otherwise SMIC would help to add dummy patterns.
@ NOTICE: It is a recommended rule.
  OUTLAYER (DENSITY TM2ALLi < 0.2 PRINT density_report_MTT2_9c.log) NOT INSIDE EXDRC
}
    }

RULECHECK MTT2_10 {
@ Both active and passive devices inside Inductor region are not allowed
  SETLAYER Metal_res = ((((((((M1R OR M2R) OR M3R) OR M4R) OR M5R) OR M6R) OR M7R) OR M8R) OR TM1R) OR TM2R
  SETLAYER X = ((((((DSTR OR DMPNP) OR MOMDMY) OR VARJUN) OR RESP1) OR RESAA) OR RESNW) OR Metal_res
  OUTLAYER (AND X INDMY) NOT INSIDE EXDRC
}


RULECHECK MTT2_12 {
@ MTT2 Inductor area must by covered by "INDMY" and the enclosure by "INDMY" is >= 15
  OUTLAYER (ENC (TM2 INTERACT INDMY) INDMY < 15 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXDRC
}


  }
}




#//=====================================              
#//  PA1 -  Passivation One Rules DRC
#//===================================== 

GROUP GPA PA_?
#SETLAYER PA_IN = PA INSIDE INDMY
#SETLAYER PA_OUT = PA NOT INSIDE INDMY

RULECHECK PA_1 {
@ Min PA edge fully enclosure by TM2 or STM2 directly underneath PA is 1.0um
@ DRC allows 0.002um checking tolerance in INDMY region
#OUTLAYER (ENC PA_OUT (TM2 OR STM2) < 1.00 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
#OUTLAYER (ENC PA_IN (TM2 OR STM2) < 1.00 - 0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
 OUTLAYER ((ENC PA (TM2 OR STM2) < 1.00 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INDMY) NOT INSIDE EXDRC
 OUTLAYER ((ENC PA (TM2 OR STM2) < 1.00 - 0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO) AND INDMY) NOT INSIDE EXDRC
}
RULECHECK PA_2 {
@ Min PA width and length is 3.0
@ DRC allows 0.002um checking tolerance in INDMY region
#OUTLAYER (INT PA_OUT < 3 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#OUTLAYER (INT PA_IN < 3 - 0.002 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 OUTLAYER ((INT PA < 3 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
 OUTLAYER ((INT PA < 3 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
RULECHECK PA_3 {
@ Min Space between two PA is 3.0
@ DRC allows 0.002um checking tolerance in INDMY region
#OUTLAYER (EXT PA_OUT < 3 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#OUTLAYER (EXT PA_IN < 3 - 0.002 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 OUTLAYER ((EXT PA < 3 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
 OUTLAYER ((EXT PA < 3 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

if { [string equal $Recommended_rules_CHECK YES] == 1 } {
RULECHECK PA_1_R {
@ Min PA enclosure by TM2 or STM2 directly underneath PA is 1.5
@ DRC allows 0.002um checking tolerance in INDMY region
@ NOTICE: It is a recommended rule.
#OUTLAYER (ENC PA_OUT (TM2 OR STM2) < 1.50 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
#OUTLAYER (ENC PA_IN (TM2 OR STM2) < 1.50 -0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
 OUTLAYER ((ENC PA (TM2 OR STM2) < 1.50 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INDMY) NOT INSIDE EXDRC
 OUTLAYER ((ENC PA (TM2 OR STM2) < 1.50 - 0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO) AND INDMY) NOT INSIDE EXDRC
}
RULECHECK PA_2_R {
@ Min PA width and length (suggest to consult with package vendor) is 55
@ DRC allows 0.002um checking tolerance in INDMY region
@ NOTICE: It is a recommended rule.
#OUTLAYER (INT PA_OUT < 55.0 OPPOSITE REGION PARA ONLY) NOT INSIDE EXDRC
#OUTLAYER (INT PA_IN < 55.0-0.002 OPPOSITE REGION PARA ONLY) NOT INSIDE EXDRC
 OUTLAYER ((INT PA < 55.0 OPPOSITE REGION PARA ONLY) NOT INDMY) NOT INSIDE EXDRC
 OUTLAYER ((INT PA < 55.0 - 0.002 OPPOSITE REGION PARA ONLY) AND INDMY) NOT INSIDE EXDRC
}
RULECHECK PA_3_R {
@ Min Space between two PA is 5.0
@ DRC allows 0.002um checking tolerance in INDMY region
@ NOTICE: It is a recommended rule.
#OUTLAYER (EXT PA_OUT < 5.0 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#OUTLAYER (EXT PA_IN < 5.0 -0.002 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 OUTLAYER ((EXT PA < 5.0 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
 OUTLAYER ((EXT PA < 5.0 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
}


VERBATIM {

//===============================
// RDV -  RDL via design rules
//===============================

GROUP GRDV RDV_?

RDV_Fuse = RDLVF OR GRDLV

 
RDV_1 {
@ Min RDL via enclosure by RDL (except fuse, seal ring and guard ring design) is 1.5
@ DRC allows 0.002um checking tolerance in INDMY region
  X11 = ENC (RDLVIA NOT RDV_Fuse) RDL < 1.50 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  X1 = X11 NOT INDMY
  ((X1 NOT LOGO) NOT INSIDE (OR MARKS MARKF MARKG)) NOT INSIDE EXDRC
  X22 = ENC (RDLVIA NOT RDV_Fuse) RDL < 1.50 - 0.002 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  X2 = X22 AND INDMY
  ((X2 NOT LOGO) NOT INSIDE (OR MARKS MARKF MARKG)) NOT INSIDE EXDRC

}
RDV_2 {
@ Min RDL Via width and length (except fuse, seal ring and guard ring design) is 3.0
@ DRC allows 0.002um checking tolerance in INDMY region
  X11 = INT ((RDLVIA NOT RDV_Fuse) NOT MARKG) < 3 ABUT<90 SINGULAR REGION
  X1 = X11 NOT INDMY
  (X1 NOT INSIDE (OR MARKS MARKF MARKG)) NOT INSIDE EXDRC
  X22 = INT ((RDLVIA NOT RDV_Fuse) NOT MARKG) < 3 -0.002 ABUT<90 SINGULAR REGION
  X2 = X22 AND INDMY
  (X2 NOT INSIDE (OR MARKS MARKF MARKG)) NOT INSIDE EXDRC
}
RDV_3 {
@ Min Space between two RDL vias is 3.0
@ DRC allows 0.002um checking tolerance in INDMY region
  ((EXT (RDLVIA NOT RDV_Fuse) < 3 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  ((EXT (RDLVIA NOT RDV_Fuse) < 3 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
RDV_4 {
@ Min RDL via enclosure by TM2 or other metal layer directly underneath PA1 (except seal ring and guard ring design) is 1.0
@ DRC allows 0.002um checking tolerance in INDMY region
  X11 = ENC (RDLVIA NOT RDV_Fuse) (TM2 OR STM2) < 1.00 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  X1 = X11 NOT INDMY
  ((X1 NOT LOGO) NOT MARKG) NOT INSIDE EXDRC
  X22 = ENC (RDLVIA NOT RDV_Fuse) (TM2 OR STM2) < 1.00 -0.002 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  X2 = X22 AND INDMY
  ((X2 NOT LOGO) NOT MARKG) NOT INSIDE EXDRC
}

RDV_5 {
@ Min Space between RDV via and PA is 5.0
@ DRC allows 0.002um checking tolerance in INDMY region
  ((EXT RDLVIA PA < 5 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  ((EXT RDLVIA PA < 5 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}



//==================================================             
//  RDL -  Al RDL (re-distribution layer) Rules DRC
//================================================== 

GROUP GRDL RDL_?

RDL_1 {
@ Min RDL Width (except fuse design) is 3.0
@ DRC allows 0.002um checking tolerance in INDMY region
  ((INT (RDL NOT ALFUSE) < 3.0 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  ((INT (RDL NOT ALFUSE) < 3.0 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
RDL_2a {
@ Min Space between two RDLs is 2.0
@ DRC allows 0.002um checking tolerance in INDMY region
  ((EXT RDL < 2.0 ABUT<89.9 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  ((EXT RDL < 2.0 - 0.002 ABUT<89.9 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
RDL_2b {
@ Min Space between two RDLs with one or both RDL width larger than 10um is 3.0
@ DRC allows 0.002um checking tolerance in INDMY region
  X1 = (RDL WITH WIDTH > 10) COIN EDGE RDL
  ((EXT X1 RDL <3.0 REGION) NOT INDMY) NOT INSIDE EXDRC
  X2 = (RDL WITH WIDTH > 10) COIN EDGE RDL
  ((EXT X2 RDL <3.0 - 0.002 REGION) AND INDMY) NOT INSIDE EXDRC
}
/*
RDL_2c {
@ RDL space in case RDL width is larger than 35um 5.0
  X = RDL_OUT WITH WIDTH >= 35
  (EXT X <5.0 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}*/
RDL_3 {
@ Min Space between RDL and L mark window is 10
@ DRC allows 0.002um checking tolerance in INDMY region
  ((EXT RDL LOGO < 10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  ((EXT RDL LOGO < 10 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
RDL_4 {
@ Minimum space between RDL and Fuse area (marked by MARKF) is 10
@ DRC allows 0.002um checking tolerance in INDMY region
  ((EXT RDL MARKF < 10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  ((EXT RDL MARKF < 10 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
}
if { [string equal $Recommended_rules_CHECK YES] == 1 } {
RULECHECK RDL_5_R {
@ Min Space to RDLPA2, except bond pad and seal-ring regions is 3.5um
@ DRC allows 0.002um checking tolerance in INDMY region
OUTLAYER (((EXT RDL RDLPA2 < 3.5 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE (PA OR MARKS)) NOT INSIDE EXDRC
OUTLAYER (((EXT RDL RDLPA2 < 3.5 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE (PA OR MARKS)) NOT INSIDE EXDRC
}
}
VERBATIM {

//============================
//  ALPA - ALPA Rules Check 
//============================


/*ALPA patterns include Al pads generated by PA logic generation and RDL patterns. Please check below rules after logic operation*/

GROUP GALPA ALPA_?

//ALPA	= (SIZE PA BY PA_su) OR RDL

ALPA_1 {
@ PA opening without ALPA patterns above is not allowed. 
@ ALPA patterns enclosure of PA	>= 1. 25um
@ DRC allows 0.002um checking tolerance in INDMY region
  ((ENC PA ALPA <= 1.249 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INDMY) NOT INSIDE EXDRC
  ((ENC PA ALPA <= 1.249 - 0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO) AND INDMY) NOT INSIDE EXDRC
}

ALPA_2 {
@ Min Space between ALPA patterns is >= 2um
@ DRC allows 0.002um checking tolerance in INDMY region
@ DRC waive check 89 to 90 degree spaces in the INDMY region.
  ((EXT ALPA < 2 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
  ((EXT ALPA < 2 - 0.002 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
ALPA_3 {
@ Min Space between Al patterns of width larger than 35um and Fuse window edge is >= 50.0um
@ DRC allows 0.002um checking tolerance in INDMY region
  X = ALPA WITH WIDTH > 35
  ((EXT X FUSE < 50 ABUT<90 SINGULAR REGION) NOT INDMY)NOT INSIDE EXDRC
  ((EXT X FUSE < 50 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY)NOT INSIDE EXDRC
}
}
if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK ALPA_4_R {
@ Min ALPA density is 10%
  OUTLAYER (DENSITY ALPA < 0.1 PRINT density_report_ALPA_4.log) NOT INSIDE EXDRC
}
RULECHECK ALPA_5_R {
@ Max ALPA density is 70%
  OUTLAYER (DENSITY ALPA > 0.7 PRINT density_report_ALPA_5.log) NOT INSIDE EXDRC
}
}
VERBATIM {
//=====================================              
//  PA2 -  Passivation Two Rules DRC
//===================================== 

GROUP GRDLPA2 RDLPA2_?
}

#SETLAYER RDLPA2_OUT = RDLPA2 NOT INSIDE INDMY
#SETLAYER RDLPA2_IN = RDLPA2 INSIDE INDMY
RULECHECK RDLPA2_1 {
@ Min RDL PA2 width is 10 (suggest to consult with package vendor)
@ DRC allows 0.002um checking tolerance in INDMY region
#  OUTLAYER (INT RDLPA2_OUT < 10 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#  OUTLAYER (INT RDLPA2_IN < 10 - 0.002 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
   OUTLAYER ((INT RDLPA2 < 10 ABUT<90 SINGULAR REGION) NOT INDMY)NOT INSIDE EXDRC
   OUTLAYER ((INT RDLPA2 < 10 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY)NOT INSIDE EXDRC
}
RULECHECK RDLPA2_2 {
@ Min Space between two RDL PA2 is 5 (suggest to consult with package vendor)
@ DRC allows 0.002um checking tolerance in INDMY region
#  OUTLAYER (EXT RDLPA2_OUT < 5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#  OUTLAYER (EXT RDLPA2_IN < 5 - 0.002 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
   OUTLAYER ((EXT RDLPA2 < 5 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
   OUTLAYER ((EXT RDLPA2 < 5 - 0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
VERBATIM {
RDLPA2_3 {
@ Min RDL enclosure of PA2 is 1.25
@ DRC allows 0.002um checking tolerance in INDMY region
  ((ENC RDLPA2 RDL < 1.25 ABUT<90 SINGULAR REGION) NOT INDMY)NOT INSIDE EXDRC
  ((ENC RDLPA2 RDL < 1.25-0.002 ABUT<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
RDLPA2_4 {
@ Minimum Space between RDLPA2 and RDL via (except fuse and guard ring/seal ring design) Via is 1um.
@ DRC allows 0.002um checking tolerance in INDMY region
  X11 = EXT RDLPA2 (RDLVIA NOT RDV_Fuse) < 1 ABUT<90 SINGULAR REGION
  X1 = X11 NOT INDMY
  (X1 NOT INSIDE (OR MARKS MARKF MARKG)) NOT INSIDE EXDRC
  X22 = EXT RDLPA2 (RDLVIA NOT RDV_Fuse) < 1 - 0.002 ABUT<90 SINGULAR REGION
  X2 = X22 AND INDMY
  (X2 NOT INSIDE (OR MARKS MARKF MARKG)) NOT INSIDE EXDRC
}
RDLPA2_5 {
@ RDL Via is not allowed to overlap with RDLPA2.
  X = (RDLVIA NOT RDV_Fuse) NOT MARKG
  (X AND RDLPA2) NOT INSIDE EXDRC
}
}


if { [string equal $BORDER_CHECK YES] == 1 } {
#//==================
#//  Border Rules
#//==================

GROUP GBD BD_?

SETLAYER BD_EXTENT = EXTENT DRAWN ORIGINAL
SETLAYER BD_EXTENT_OTHER = EXTENT DRAWN ORIGINAL IGNORE BORDERi
SETLAYER BD_OTHER_OUTSIDE = BD_EXTENT_OTHER NOT BORDER

SETLAYER MS_OUT_TEMP1 = (((((((M1i AND MARKS) OR (M2i AND MARKS)) OR (M3i AND MARKS)) OR (M4i AND MARKS)) OR (M5i AND MARKS)) OR (M6i AND MARKS)) OR (M7i AND MARKS))  OR (M8i AND MARKS)
SETLAYER MS_OUT_TEMP2 = ((TM1i AND MARKS) OR (TM2i AND MARKS)) OR (RDLi AND MARKS)
SETLAYER MS_OUT = MS_OUT_TEMP1 OR MS_OUT_TEMP2

RULECHECK BD_1 {
@ Border layer must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer)
@ This rule is not applicable if customers insert seal ring by themselves.
@ This rule checking layer are DNW,AA,NW,PSUB,VTNH,VTPH,LVN, LVP,DG,TG,GT,SN,SP,NPR1,HRP,ESD1,SAB,CT,Mn(n=1-8),Vn(n=1-7), TV1,TV2,TM1,TM2,STV1,STV2,STM1,STM2,PA,BCB1,BCB2,RDL, FUSE,AADUM,GTDUM,MnDUM(n=1-8),TM1DUM,TM2DUM, STM1DUM, STM2DUM.
SETLAYER BD_EXTENT_OTHER_temp = EXTENT DRAWN DNWi AAi NWi PSUBi VTNHi VTPHi LVNi LVPi DGi TGi GTi SNi SPi NPR1 HRPi ESD1 SABi CTi M10 M20 M30 M40 M50 M60 M70 M80 V1i V2i V3i V4i V5i V6i V7i TV1i TV2i TM10 TM20 STV1i STV2i STM10 STM20 PAi RDLVIAi RDLPA2i RDLi FUSEi AADUMi GTDUMi M1DUMi M2DUMi M3DUMi M4DUMi M5DUMi M6DUMi M7DUMi M8DUMi TM1DUMi TM2DUMi STM1DMi STM2DMi IGNORE BORDERi MARKS NODMF  
OUTLAYER (ENC BD_EXTENT_OTHER_temp BORDER < 0.37 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK BD_2 {
@ Min Border layer enclosure of DNW is 6
OUTLAYER (ENC DNW BORDER < 6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

#RULECHECK BD_3 {
#@ BORDER layer must enclose all chip layout pattern
#OUTLAYER COPY BD_OTHER_OUTSIDE
#}

RULECHECK BD_4 {
@ Enclosure of seal ring outer ring outline edge by BORDER layer (excluding seal ring corner dummy area) if seal ring has been added by designers. >= 1.5
OUTLAYER (ENC MS_OUT BORDER < 1.5 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

}



VERBATIM {
//=================================================
//                   SRAM rules
//=================================================


SRAM_1 {
@ If gate is enclosed by INST layer, it should be also enclosed by bit cell marking layer (STSRAM, DNSRAM, UDSRAM, DPSRAM,  LRSRAM, 2PSRAM, D2SRAM RFSRAM).
  X = GATE NOT OUTSIDE INST
  (X NOT (OR STSRAM DNSRAM UDSRAM DPSRAM LRSRAM 2PSRAM D2SRAM RFSRAM)) NOT INSIDE EXDRC
}

SRAM_1b {
@ If the area is covered by bit cell marking layers (STSRAM, DPSRAM, LRSRAM, 2PSRAM, DNSRAM, D2SRAM, UDSRAM, RFSRAM), it should be also covered by INST layer.
@ DRC waive if no device (AA AND GT) in the area ((INST OR bit cell marker layer) NOT (INST AND bit cell markler layer)).
  ((OR STSRAM DPSRAM LRSRAM 2PSRAM DNSRAM D2SRAM UDSRAM RFSRAM) NOT INTERACT INST) NOT INSIDE EXDRC
 (((OR STSRAM DPSRAM LRSRAM 2PSRAM DNSRAM D2SRAM UDSRAM RFSRAM) NOT INST) INTERACT (AA AND GT))NOT INSIDE EXDRC  
}


//===================================
//  SRAM AA -SRAM Active Area DRC
//===================================

GROUP GSRAA SRAA_?

SRAA_2a {
@ Min Channel width for 1.0/1.2V NMOS/PMOS transistors is 0.085um
  Y = LENGTH GATE_M_W < 0.085
  ((EXPAND EDGE Y INSIDE BY 0.001) NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRAA_4 {
@ Min N+AA enclosure by NW(excluding NW interacting with RESNW) is 0.055um
  X = ENC NACT (NW NOT INTERACT RESNW) < 0.055 ABUT<90 SINGULAR REGION
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRAA_5 {
@ Min Space between NW and N+AA inside PW is 0.06um
  X = EXT NW (NACT AND PW) < 0.06 ABUT<90 SINGULAR REGION
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRAA_6 {
@ Min P+AA enclosed by NW is 0.06um
  X = ENC PACT NW < 0.06 ABUT<90 SINGULAR REGION
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRAA_7 {
@ Min Space between NW and P+AA inside PW is 0.11um
  X = EXT NW (PACT INSIDE PW) < 0.11 ABUT<90 SINGULAR REGION
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRAA_8 {
@ Min AA area is 0.029um2
  X = AREA AA < 0.029
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}

//======================================
//  SRAM VTNH: SRAM High Vt NMOS Implant
//======================================

GROUP GSRVTNH SRVTNH_?

SRVTNH_4 {
@ Min VTNH extension outside of NMOS AA along gate poly length direction is 0.065
  X = (NACT AND VTNH) TOUCH EDGE GATE 
  Y = ENC X VTNH < 0.065 ABUT<90 REGION OPPOSITE
  (Y NOT OUTSIDE INST) NOT INSIDE EXDRC
  }
SRVTNH_5 {
@ Min space between VTNH and MOS AA of other device along other device's gate poly length direction is 0.065
  X1 = NACT TOUCH EDGE (AA INSIDE EDGE GT)
  X2 = PACT TOUCH EDGE (AA INSIDE EDGE GT)
  X = X1 OR EDGE X2
  ((EXT X VTNH < 0.065 ABUT<90 REGION OPPOSITE) NOT OUTSIDE INST) NOT INSIDE EXDRC
}

SRVTNH_8 {
@ Min VTNH area is 0.11
  ((AREA VTNH < 0.11) NOT OUTSIDE INST) NOT INSIDE EXDRC
}

//======================================
//  SRAM VTPH: SRAM High Vt PMOS Implant
//======================================

GROUP GSRVTPH SRVTPH_?

SRVTPH_4 {
@ Min VTPH extension outside of PMOS AA along gate poly length direction is 0.065
  X = (PACT AND VTPH) TOUCH EDGE GATE
  Y = ENC X VTPH < 0.065 ABUT<90 REGION OPPOSITE
  (Y NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRVTPH_5 {
@ Min Space between VTPH and MOS AA of other device along other device's gate poly length direction is 0.065
  X1 = PACT TOUCH EDGE (AA INSIDE EDGE GT)
  X2 = NACT TOUCH EDGE (AA INSIDE EDGE GT)
  X = X1 OR EDGE X2
  ((EXT X VTPH < 0.065 ABUT<90 REGION OPPOSITE) NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRVTPH_8 {
@ Min VTPH area is 0.11
  ((AREA VTPH < 0.11) NOT OUTSIDE INST) NOT INSIDE EXDRC
}

//==============================
//   SRAM GT -SRAM Poly Rule DRC
//==============================

GROUP GSRGT SRGT_?


POLYEND = CONVEX EDGE GT ANGLE1 >0 ANGLE2 > 0 LENGTH1 > 0.14 LENGTH2 > 0.14 WITH LENGTH <= 0.14

SRGT_3a1 {
@ Min Space between GTs with the parallel run length >0.12um is 0.12 except poly line end to end patterns. 

   END_END = EXT [POLYEND] < 0.12 OPPOSITE
  
   X = (EXT [GT] < 0.12 OPPOSITE) NOT COIN EDGE END_END
   Y = LENGTH X > 0.12
   (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRGT_3a2 {
@ Min Space between GTs with the parallel run lenght > 0.025 and <= 0.12um is 0.107 except poly line end to end patterns.

   END_END = EXT [POLYEND] < 0.107 OPPOSITE

   X = (EXT [GT] < 0.107 OPPOSITE) NOT COIN EDGE END_END
   Y = LENGTH X > 0.025 <= 0.12
   (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRGT_3a3 {
@ Min Space between GTs with the parallel run lenght <= 0.025um is 0.06 except poly line end to end patterns.

   END_END = EXT [POLYEND] < 0.06 OPPOSITE

   X = (EXT [GT] < 0.06 OPPOSITE) NOT COIN EDGE END_END
   Y = LENGTH X <= 0.025
   (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRGT_3c {
@ Min Space between GTs on the same AA is >= 0.13
  X = EXT GT_EMPTY < 0.13 ABUT < 90 SINGULAR REGION CONNECTED
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRGT_3d {
@ Min Space between poly line end to end is 0.105                            
  X = EXT POLYEND < 0.105 OPPOSITE REGION EXCLUDE SHIELDED
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRGT_4a {
@ Min Space between AA and GT on field oxide with the parallel run length > 0.04 is 0.05 except poly line end to end patterns.
  X = AA INSIDE EDGE GT
  Y = AA NOT COIN EDGE X
  A = EXT [Y] INTERGT < 0.05 OPPOSITE
  B = LENGTH A > 0.04
  (B NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRGT_4b {
@ Min Space between AA and GT on field oxide with the parallel run length <= 0.04 is 0.032 except poly line end to end patterns.
  X = AA INSIDE EDGE GT
  Y = AA NOT COIN EDGE X
  A = EXT [Y] INTERGT < 0.032 OPPOSITE
  B = LENGTH A <=0.04
  (B NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRGT_5a {
@ Min Extension of AA outside of GT with parallel run length > 0.15 (not include dummy AA and dummy Poly) is 0.095 except poly line end to end patterns.
   X = ENC [GT] AA < 0.095 OPPOSITE
   Y = LENGTH X > 0.15  
   (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRGT_5b {
@ Min Extension of AA outside of GT with parallel run length >0.015 and <=0.04 (not include dummy AA and dummy Poly) is 0.077 except poly line end to end patterns.
   X = ENC [GT] AA < 0.077 OPPOSITE
   Y = LENGTH X > 0.015 <=0.04  
   (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRGT_5c {
@ Min Extension of AA outside of GT with parallel run length > 0.04 and <= 0.15 (not include dummy AA and dummy Poly) is 0.077 except poly line end to end patterns.
@ DRC doesn't flag if AA extends out of ((AA AND GT) NOT GATE) >= 0um and <= 0.01um.

   X = ENC [GT] AA < 0.077 OPPOSITE
   Y = LENGTH X > 0.04 <= 0.15
 
   Z = (GT AND AA) NOT (OR GATE_M GATE_D GATE_T)
   L = ENC [Z] AA <= 0.01 OPPOSITE
   M = LENGTH L > 0.04 <= 0.15

   ((Y NOT COIN EDGE M) NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRGT_6 {
@ Min Extension of gate poly end-cap outside of AA (not include dummy AA and dummy Poly)  is 0.068
  X = GATE COIN EDGE AA
  Y = ENC X GT < 0.068 ABUT<90 REGION
  (Y NOT OUTSIDE INST) NOT INSIDE EXDRC
}



//=======================================
// SRAM SN - SRAM N+ S/D Implantation DRC
//=======================================

GROUP GSRSN SRSN_?

SRSN_3a {
@ Min Space between SN and P+AA inside NW with the parallel run length > 0.055 is 0.065
  X = (PACT NOT PTAP) NOT TOUCH EDGE SN
  Y = EXT [SN] X < 0.065 OPPOSITE
  A = LENGTH Y > 0.055
  (A NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRSN_3b {
@ Min Space between SN and P+AA inside NW with the parallel run length <=0.055 is 0.06 
  X = (PACT NOT PTAP) NOT TOUCH EDGE SN
  Y = EXT [SN] X < 0.06 OPPOSITE
  A = LENGTH Y <= 0.055
  (A NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRSN_5 {
@ Min Space between SN and PMOS gate along source/drain direction is 0.219
  X = GATE_W INSIDE EDGE SP
  Y = EXT X SN < 0.219 ABUT<90 REGION OPPOSITE
  (Y NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRSN_6 {
@ Min SN extension outside of poly gate along source/drain direction for NMOS is 0.214
  X = GATE_W INSIDE EDGE SN
  Y = ENC X SN < 0.214 ABUT<90 REGION OPPOSITE
  (Y NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRSN_7a_8a {
@ Min SN extension outside of NMOS AA along gate poly length direction with the parallel run length >0.055um is 0.065, if the distance to the related poly is > 0.20um
@ Min SN extension outside of NMOS AA along gate poly length direction with the parallel run length >0.055um is 0.065, if the distance to the related poly is <= 0.20um
  AAEIGT  = AA INSIDE EDGE GT
  X = NMOS TOUCH EDGE AAEIGT
  Y = ENC X [SN] < 0.065 OPPOSITE
  A = LENGTH Y > 0.055
  (A NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}

SRSN_7b_8b {
@ Min SN extension outside of NMOS AA along gate poly length direction with the parallel run length <=0.055um is 0.06, if the distance to the related poly is > 0.20um
@ Min SN extension outside of NMOS AA along gate poly length direction with the parallel run length <=0.055um is 0.06, if the distance to the related poly is <= 0.20um
  AAEIGT  = AA INSIDE EDGE GT
  X = NMOS TOUCH EDGE AAEIGT
  Y = ENC X [SN] < 0.06 OPPOSITE
  A = LENGTH Y <= 0.055
  (A NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}

//=======================================
// SRAM SP - SRAM P+ S/D Implantation DRC
//=======================================

GROUP GSRSP SRSP_?

SRSP_3a {
@ Min Space between SP and N+AA inside PW with the parallel run length > 0.055 is 0.065
  X = (NACT NOT NTAP) NOT TOUCH EDGE SP
  Y = EXT [SP] X < 0.065 OPPOSITE
  A = LENGTH Y > 0.055
  (A NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRSP_3b {
@ Min Space between SP and N+AA inside PW with the parallel run length <=0.055 is 0.06 
  X = (NACT NOT NTAP) NOT TOUCH EDGE SP
  Y = EXT [SP] X < 0.06 OPPOSITE
  A = LENGTH Y <= 0.055
  (A NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRSP_5 {
@ Min Space between SP and NMOS gate along source/drain direction is 0.219
  X = GATE_W INSIDE EDGE SN
  Y = EXT X SP < 0.219 ABUT<90 REGION OPPOSITE
  (Y NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRSP_6 {
@ Min SP extension outside of PMOS gate along source/drain direction is 0.214
  X = (GT INSIDE EDGE PACT) COIN EDGE GATE
  Y = ENC X SP < 0.214 ABUT<90 REGION OPPOSITE
  (Y NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRSP_7a_8a {
@ Min SP extension outside of PMOS AA along gate poly length direction with the parallel run length >0.055µm is 0.065, if the distance to the related poly is > 0.20um
@ Min SP extension outside of PMOS AA along gate poly length direction with the parallel run length >0.055µm is 0.065, if the distance to the related poly is <= 0.20um
  AAEIGT  = AA INSIDE EDGE GT
  X = PMOS TOUCH EDGE AAEIGT
  Y = ENC X [SP] < 0.065 OPPOSITE
  A = LENGTH Y > 0.055
  (A NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}

SRSP_7b_8b {
@ Min SP extension outside of PMOS AA along gate poly length direction with the parallel run length <=0.055um is 0.06, if the distance to the related poly is > 0.20µm
@ Min SP extension outside of PMOS AA along gate poly length direction with the parallel run length <=0.055um is 0.06, if the distance to the related poly is <= 0.20um
  AAEIGT  = AA INSIDE EDGE GT
  X = PMOS TOUCH EDGE AAEIGT
  Y = ENC X [SP] < 0.06 OPPOSITE
  A = LENGTH Y <= 0.055
  (A NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}

//============================
//  SRAM CT -SRAM Contact DRC
//============================

GROUP GSRCT SRCT_?

CT_SR = CT INSIDE INST
SCT_SR = RECTANGLE CT_SR ASPECT == 1
RCT_SR = CT_SR NOT SCT_SR

SRCT_2a1 {
@ Min Space between contacts (runlength > 0.02) is 0.11
  X = EXT [CT] < 0.11 OPPOSITE
  Y = LENGTH X > 0.02
  (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRCT_2a2 {
@ Min Space between contacts (runlength <=0.02) is 0.09
  X = EXT [CT] < 0.09 OPPOSITE
  Y = LENGTH X <= 0.02
  (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRCT_4a {
@ Min Space between GATE and contact on AA for 1.0V/1.2V is 0.038
  X = EXT GATE_M ACT_CT < 0.038 ABUT<90 SINGULAR REGION 
  ((X NOT DGTG) NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRCT_5 {
@ Min Square CT area enclosed by AA for CT landed on AA is 87%
  X = SCT_SR CUT AA
  Y = X AND AA
  Z = DFM PROPERTY X Y OVERLAP ABUT ALSO
      [- = COUNT(Y)] == 1
      [- = AREA(Y)/AREA(X)] >= 0.87
  (X NOT Z) NOT INSIDE EXDRC
}
SRCT_6 {
@ Min CT enclosure by poly for CT landed on poly (exclude rectangular CT) is 0
  ((SCT_SR INTERACT GT) NOT GT) NOT INSIDE EXDRC
}
SRCT_7 {
@ Min M1 enclosure of CT (four directions, exclude rectangular CT) is 0
  (SCT_SR NOT M1) NOT INSIDE EXDRC
}
SRCT_9 {
@ Square CT is not allowed to land on gate  
  X = AND GATE (RECTANGLE CT ASPECT == 1)
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRCT_101b {
@ Min Rectangular CT width is 0.08
  (INT RCT_SR < 0.08 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SRCT_101c {
@ Min Rectangular CT overlap AA area is 0.01
  X = RCT_SR AND AA
  (AREA X < 0.01) NOT INSIDE EXDRC
}
SRCT_101d {
@ Min Rectangular CT overlap poly is 0.073
  (INT RCT_SR GT < 0.073 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
SRCT_101e {
@ Min Rectangular CT overlap poly area is 0.006
  X = AND RCT_SR GT
  (AREA X < 0.006) NOT INSIDE EXDRC
}
SRCT_101f {
@ Min Rectangular CT overlap M1 area is 0.017
  X = AND RCT_SR M1
  (AREA X < 0.017) NOT INSIDE EXDRC
}
SRCT_101g {
@ Min Poly extension outside of rectangular CT is -0.008
/*  X = GT INSIDE EDGE RCT_SR
  Y = EXPAND EDGE X OUTSIDE BY 0.008
  Z = (GT WITH EDGE X) OR Y
  (RCT_SR INTERACT Z) NOT Z
*/
  X = GT AND RCT_SR
  Y = CT ENCLOSE X
  Z = CONVEX EDGE X == 2
  M = Z NOT COIN EDGE Y
  L = CONVEX EDGE M ANGLE1 > 0 ANGLE2 > 0
  (ENC (L) Y <= 0.008 OPPOSITE) NOT INSIDE EDGE EXDRC  
}
SRCT_101h {
@ Max Rectangular CT extension outside of poly (without AA overlap) is 0.02 
 /* X = SIZE (GT AND RCT_SR) BY 0.02 
  ((RCT_SR NOT X) NOT AA) TOUCH X*/

  X = GT AND RCT_SR
  Y = CT ENCLOSE X
  Z = CONVEX EDGE X == 2
  M = Z NOT COIN EDGE Y
  L = CONVEX EDGE M ANGLE1 == 0 ANGLE2 >= 0
  H = ENC (L) Y <= 0.02 OPPOSITE
  (H NOT INSIDE EDGE AA) NOT INSIDE EDGE EXDRC
}
SRCT_101i {
@ Min M1 enclosure of rectangular CT is -0.032
  X = M1 INSIDE EDGE RCT_SR
  Y = EXPAND EDGE X OUTSIDE BY 0.032
  Z = (M1 WITH EDGE X) OR Y
  ((RCT_SR INTERACT Z) NOT Z) NOT INSIDE EXDRC
}

//===========================
// SRAM M1 - Metal 1 SRAM DRC
//===========================

GROUP GSRM1 SRM1_?

SRM1_2a1 {
@ Min Space between M1s	 with the parallel run length>0.26um is 0.09
  X = EXT [M1] < 0.09 OPPOSITE
  Y = LENGTH X > 0.26
  (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC 
}
SRM1_2a2 {
@ Min Space between two M1s with the parallel run length >=0.09um and <=0.26um is 0.08
  X = EXT [M1] < 0.08 OPPOSITE
  Y = LENGTH X >= 0.09 <= 0.26
  (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRM1_2a3 {
@ Min Space between two M1s with the parallel run length <0.09um is 0.075
  X = EXT [M1] < 0.075 OPPOSITE
  Y = LENGTH X < 0.09
  (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRM1_4 {
@ Min M1 area is >= 0.027
 X = AREA M1 < 0.027
 (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
M1_SRE = EMPTY OR (M1i INTERACT INST)
CT_SRE = EMPTY OR ((SIZE CT_SR BY -0.032) AND M1_SRE)    //Refer to SRCT.101i
V1_SRE = EMPTY OR V1i
CONNECT M1_SRE CT_SRE
CONNECT M1_SRE V1_SRE

SRM1_101 {
@ Min Space between M1 and adjacent CT with parallel run length >0 is >= 0.082
//Refer to SRCT.101i
  X = EXT M1_SRE CT_SRE < 0.114 ABUT<90 REGION OPPOSITE EXTENDED 0.032 MEASURE ALL NOT CONNECTED
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}
SRM1_102 {
@ Min Space between M1 and adjacent V1 with parallel run length >=0 is >=0.087
//refer to SRV1_3a
  X = EXT M1_SRE [V1_SRE] < 0.087 ABUT<90 OPPOSITE MEASURE ALL NOT CONNECTED
//  Y = LENGTH X > 0.03
  (X NOT OUTSIDE EDGE INST ) NOT INSIDE EDGE EXDRC
}

//==========================
//  SRAM V1 - Via 1 SRAM DRC
//==========================

GROUP GSRV1 SRV1_?

SRV1_3a {
@ Min M1 enclosure of V1 (four directions) is 0
 ((V1 NOT M1) NOT OUTSIDE INST) NOT INSIDE EXDRC                          
}
SRV1_5a {
@ Min M2 enclosure of V1 (four directions) is 0
 ((V1 NOT M2) NOT OUTSIDE INST ) NOT INSIDE EXDRC                             
}

//===========================
// SRAM M2 - Metal 2 SRAM DRC
//===========================

GROUP GSRM2 SRM2_?

SRM2_2a1 {
@ Min Space between two M2s with the run length >=0.25um is 0.10
  X = EXT [M2] < 0.10 OPPOSITE
  Y = LENGTH X >= 0.25
  (Y NOT OUTSIDE EDGE INST ) NOT INSIDE EDGE EXDRC
}
SRM2_2a2 {
@ Min Space between two M2s with the run length >=0.02um and <0.25um is 0.095
  X = EXT [M2] < 0.095 OPPOSITE
  Y = LENGTH X >= 0.02 < 0.25
  (Y NOT OUTSIDE EDGE INST ) NOT INSIDE EDGE EXDRC
}
SRM2_2a3 {
@ Min Space between two M2s with the run length <0.02um is 0.09
  X = EXT [M2] < 0.09 OPPOSITE
  Y = LENGTH X < 0.02
  (Y NOT OUTSIDE EDGE INST) NOT INSIDE EDGE EXDRC
}
SRM2_4 {
@ Min M2 area is 0.03
  X = AREA (M2 OR M2DUM) < 0.03
  (X NOT OUTSIDE INST) NOT INSIDE EXDRC
}

//============================
//    Conventional Check
//============================

GROUP GConvention Convention_?

Convention_1 {
@ NW not interacting with N+ pickup is not allowed
  (NW NOT INTERACT NTAPi) NOT INSIDE EXDRC
}
Convention_2 {
@ PMOS in PW is not allowed
  PGT = PACT INTERACT GATE
  (PW AND ((PGT NOT LDBK) NOT VARMOS)) NOT INSIDE EXDRC
}
Convention_3 {
@ AA must be fully enclosed by (SN OR SP), except NW resistor region
  X = AA NOT INTERACT (RESNW AND NW)
  ((X NOT SN) NOT SP) NOT INSIDE EXDRC
}
}


VERBATIM {
//===========================
//   AAR - AA Resistor DRC
//===========================

GROUP GRESAA RESAA_?

AAR_SA = AAR AND SAB
AAR_NS = NOT INTERACT AAR SAB


RESAA_1 {
@ Min width of non-silicide AA resistor is 0.4um
@ NOTICE: It is a guidelines rule.
  X = (RESAA AND AA) AND SAB
  L = X INSIDE EDGE AA
  (LENGTH L < 0.4) NOT INSIDE EDGE EXDRC
}

RESAA_2 {
@ Non-silicide AA resistor region should be covered by SAB and implanted by SN or SP.
@ NOTICE: It is a guidelines rule.
  X = AAR INTERACT SAB
  (X NOT (OR SN SP)) NOT INSIDE EXDRC
}

RESAA_3 {
@ Dummy layer RESAA is drawn to block LDD implant in the resistor area according to LOTA table.
@NOTICE: It is a guidelines rule.
  X = RESAA INTERACT SAB
  (AND NLL X) NOT INSIDE EXDRC
  (AND NLH X) NOT INSIDE EXDRC
  (AND PLL X) NOT INSIDE EXDRC
  (AND PLH X) NOT INSIDE EXDRC
  (AND NLHT X) NOT INSIDE EXDRC
  (AND PLHT X) NOT INSIDE EXDRC
}

RESAA_5a {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@NOTICE: It is a guidelines rule.
  X = SN NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5b {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@NOTICE: It is a guidelines rule.
  X = SP NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5c {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@NOTICE: It is a guidelines rule.
  X = NW NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5d {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@NOTICE: It is a guidelines rule.
  X = VTNH NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5e {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@NOTICE: It is a guidelines rule.
  X = VTPH NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5f {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@NOTICE: It is a guidelines rule.
  X = LVN NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5g {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@NOTICE: It is a guidelines rule.
  X = LVP NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5h {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@ NOTICE: It is a guidelines rule.
  X = NPR1 NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5i {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@ NOTICE: It is a guidelines rule.
  X = ESD1 NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}
RESAA_5j {
@ Min Space between non-silicide AA resistors area and other implant region is 0.2
@ NOTICE: It is a guidelines rule.
  X = HRP NOT INTERACT RESAA
  (EXT X AAR_SA < 0.2 ABUT<90 REGION) NOT INSIDE EXDRC
}

RESAA_6 {
@ Extension of RESAA outside of non-silicide AA min.distance is 0.2um
@ NOTICE: It is a guidelines rule.
  (ENC AAR_SA RESAA < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESAA_7 {
@ Non-silicide AA resistor with SP must be inside NW
@ NOTICE: It is a guidelines rule.
  (((AAR INTERACT SAB) AND SP) NOT INSIDE NW) NOT INSIDE EXDRC
}
RESAA_8 {
@ For Silicide AA AA resistor, two sides of RESAA must be along the CT edge
@ NOTICE: It is a guidelines rule.
  X = CT AND AAR_NS 
  Y = (RESAA NOT INTERACT SAB) INSIDE EDGE AA
  (Y NOT TOUCH EDGE X ) NOT INSIDE EDGE EXDRC
}
RESAA_9 {
@ Fixed Space between SAB and CT for non-silicide AA resistor is 0.2
@ NOTICE: It is a guidelines rule.
  X = AAR INTERACT SAB
  Y = CT AND X
  ((SIZE Y BY 0.2) NOT TOUCH AAR_SA) NOT INSIDE EXDRC
}
RESAA_10 {
@ Min SP/SN enclosure of resistor AA is 0.16um.
@ NOTICE: It is a guidelines rule.
  /*X = SP OR SN
  ENC AAR_SA X < 0.16 ABUT<90 SINGULAR REGION*/

  X = SP OR SN
  (ENC (AA AND RESAA) X < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK RESAA_1a_R {
@ Suggest the Nsq >= 1 for stable Resistivity
SETLAYER  X = RESAA AND SAB
SETLAYER  Y = (AA AND RESAA) AND SAB
SETLAYER  L = (INSIDE EDGE AA X) OR EDGE (AA COIN EDGE X)
SETLAYER  W = INSIDE EDGE Y AA
OUTLAYER  (DFM PROPERTY Y L W OVERLAP ABUT ALSO \[SQUARES = LENGTH(L)/LENGTH(W)\] < 1) NOT INSIDE EXDRC
}
RULECHECK RESAA_4_R {
@ Dog-bone design at the end of AA resistor for contact pick-up is not suggested
  SETLAYER X = AAR INTERACT SAB
  OUTLAYER (CONVEX EDGE X ==1) NOT INSIDE EDGE EXDRC
}

}


VERBATIM {
//====================
//  RESNWAA Rules
//====================

GROUP GRNWA RESNWAA_?

RESNWAA_1 {
@ Minimum NW-Resistor width is 1.6um.
@ NOTICE: It is a guidelines rule.
 X = ((RESNW AND AA) AND NW) AND SAB
 (LENGTH (X INSIDE EDGE NW) < 1.6) NOT INSIDE EDGE EXDRC
//INT ((NWR NOT ENCLOSE SN) NOT IN EDGE SN) < 1.6 ABUT<90 REGION
}
RESNWAA_2 {
@ Minimum AA enclosure of NW-Resistor is 0.3um.
@ NOTICE: It is a guidelines rule.
 X = ((RESNW AND AA) AND NW) AND SAB
 (ENC X (AA ENCLOSE X) < 0.3 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
//ENC (NWR NOT SN) AA < 0.3 ABUT<90 SINGULAR REGION
}
RESNWAA_3 {
@ Minimum SAB enclosure of AA is 0.2um.
@ NOTICE: It is a guidelines rule.
 X = ((RESNW AND AA) AND NW) AND SAB
 Y1 = AA ENCLOSE X
 Y2 = SAB NOT COIN EDGE (HOLES SAB)
 (ENC Y1 Y2 < 0.2 ABUT<90 REGION) NOT INSIDE EDGE EXDRC
}
RESNWAA_4 {
@ Minimum NW enclosure of CT is 0.2um.
@ NOTICE: It is a guidelines rule.
 X = ((RESNW AND AA) AND NW) AND SAB
 (ENC (CT AND (HOLES SAB)) (NW ENCLOSE X) < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
// ENC (CT AND (HOLES SAB)) (NWR NOT SAB) < 0.2 ABUT<90 SINGULAR REGION
}
RESNWAA_5 {
@ Minimum enclosure of SAB beyond related NW is 0.2um.
@NOTICE: It is a guidelines rule.
 X1 = HOLES SAB
 X2 = SAB TOUCH X1
 (ENC NWR X1 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (ENC NWR X2 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (((NWR INTERACT X1) NOT X1) NOT SAB) NOT INSIDE EXDRC
}

//RESNWAA_6 has been covered by RESNWST_7

RESNWAA_7 {
@ Fixed Space between RESNW and silicided CT area is 0.2um.
@NOTICE: It is a guidelines rule.
  X = HOLES (SAB INTERACT RESNW)
  ((SIZE X BY 0.2) NOT TOUCH RESNW) NOT INSIDE EXDRC
}
RESNWAA_8 {
@ Minimum Space between NW of NW resistors and un-related implant region is 0.6um.
@NOTICE: It is a guidelines rule.
 X = NWR INTERACT (HOLES SAB)
 (EXT X (NW NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (VTNH NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (VTPH NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (LVN NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (LVP NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (SN NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (SP NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (NPR1 NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (ESD1 NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
 (EXT X (HRP NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESNWAA_9 {
@ Minimum extension of RESNW outside of AA is 0.2um.
@NOTICE: It is a guidelines rule.
  (ENC AA (RESNW INTERACT SAB) < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESNWAA_10 {
@ SAB must cover NW resistor except CT area
@NOTICE: It is a guidelines rule.
  X = RESNW ENCLOSE (RESNW AND AA)
  Y = (SAB OR (HOLES SAB)) INTERACT X
  (Y NOT ENCLOSE (RESNW AND NW)) NOT INSIDE EXDRC
}
RESNWAA_11 {
@ Fixed Space between RESNW and CT is 0.4
@NOTICE: It is a guidelines rule.
  X = RESNW ENCLOSE (RESNW AND AA)
  Y = CT AND (AA INTERACT X)
  ((SIZE Y BY 0.4) NOT TOUCH X) NOT INSIDE EXDRC
}
  

//=======================
//  RESNWSTI Rules
//=======================

GROUP GRNWS RESNWST_?

NWRSTI = NWR NOT INTERACT SAB

RESNWST_1 {
@ Minimum NWSTI resitor width is 1.6um.
@NOTICE: It is a guidelines rule.
 X = (RESNW AND NW) NOT INTERACT SAB
 (LENGTH (X INSIDE EDGE NW) < 1.6) NOT INSIDE EDGE EXDRC
//INT NWRSTI < 1.6 ABUT<90 SINGULAR REGION
}
RESNWST_2 {
@ Minimum space between NWSTI resistor and adjacent AA is 0.5um.
@NOTICE: It is a guidelines rule.
 (EXT NWRSTI AA < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESNWST_3 {
@ Minimum CT enclosed by silicided AA is 0.2um.
@NOTICE: It is a guidelines rule.
 X = CT AND NWRSTI
 Y = AA INTERACT X
 (ENC X Y < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESNWST_4 {
@ Minimum SN implant area enclosure of silicided AA is 0.15um.
@NOTICE: It is a guidelines rule.
 X = AA AND NWRSTI
 Y = SN INTERACT NWRSTI
 (ENC X Y < 0.15 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESNWST_5 {
@ Minimum enclosure of NW to silicided AA area is 0.2um.
@NOTICE: It is a guidelines rule.
 X = AA AND NWRSTI
 Y = NW INTERACT NWRSTI
 (ENC X Y < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESNWST_6 {
@ Minimum space of RESNW to silicided AA area is 0.
@NOTICE: It is a guidelines rule.
 X = RESNW INTERACT NWRSTI
 (AND X AA) NOT INSIDE EXDRC
}
RESNWST_7 {
@ RESNW must not overlap with dummy pattern and other implant layers(except NW) in the resistor area
@ RESNWAA_6 has been covered by these codes
@NOTICE: It is a guidelines rule.
 ((RESNW INTERACT SN) AND AADUM) NOT INSIDE EXDRC
 ((RESNW INTERACT SN) AND GTDUM) NOT INSIDE EXDRC
 (RESNW AND VTNH) NOT INSIDE EXDRC
 (RESNW AND VTPH) NOT INSIDE EXDRC
 (RESNW AND LVN) NOT INSIDE EXDRC
 (RESNW AND LVP) NOT INSIDE EXDRC
 (RESNW AND SP) NOT INSIDE EXDRC
 (RESNW AND NPR1) NOT INSIDE EXDRC
 (RESNW AND ESD1) NOT INSIDE EXDRC
 (RESNW AND HRP) NOT INSIDE EXDRC
}
RESNWST_8 {
@ Min Extension of RESNW outside of NW is 0.2
@NOTICE: It is a guidelines rule.
  (ENC NW RESNW < 0.2 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESNWST_9 {
@ No silicide is allowed on NW Resistor except for CT pick-up AA area.
@NOTICE: It is a guidelines rule.
 //X = SIZE (NWR AND AA) BY -0.01
 //(RESNW NOT INTERACT X) AND SAB
 X = (RESNW AND NW) NOT INTERACT SAB
 (X AND (AA NOT INTERACT CT)) NOT INSIDE EXDRC
}
}

VERBATIM {
//==========================
//  GR - Poly Resistor DRC
//==========================

GROUP GRESP1 RESP1_?

GTR_SA = GTR AND SAB
GTR_NS = GTR NOT INTERACT SAB

RESP1_1 {
@ Min Width of non-silicide poly resistor is 0.4
@ NOTICE: It is a guidelines rule.
  X = (RESP1 AND GT) AND SAB
  L = X INSIDE EDGE GT
  (LENGTH L < 0.4) NOT INSIDE EDGE EXDRC
}
RESP1_2 {
@ For non-silicide poly resistor, make sure the poly be covered by SAB and implanted by either SN or SP
@NOTICE: It is a guidelines rule.
  X = GTR INTERACT SAB
  (X NOT (SN OR SP)) NOT INSIDE EXDRC
}
RESP1_3 {
@ Dummy layer RESP1 is drawn to block LDD implant in the resistor area according to LOTA table.
@NOTICE: It is a guidelines rule.
  X = RESP1 INTERACT GTR_SA
  (AND NLL X) NOT INSIDE EXDRC
  (AND NLH X) NOT INSIDE EXDRC
  (AND PLL X) NOT INSIDE EXDRC
  (AND PLH X) NOT INSIDE EXDRC
  (AND PLHT X) NOT INSIDE EXDRC
  (AND NLHT X) NOT INSIDE EXDRC
}
RESP1_5a {
@ Min Space between non-silicide poly resistors and un-related implant region (follow GT.10 rule) is 0.16um
@NOTICE: It is a guidelines rule.
  X = SP NOT INTERACT RESP1
  (EXT X GTR_SA < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESP1_5b {
@ Min Space between non-silicide poly resistors and un-related implant region (follow GT.10 rule) is 0.16um
@NOTICE: It is a guidelines rule.
  X = SN NOT INTERACT RESP1
  (EXT X GTR_SA < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESP1_5c {
@ Min Space between non-silicide poly resistors and un-related implant region (follow GT.10 rule) is 0.16um
@NOTICE: It is a guidelines rule.
  X = ESD1 NOT INTERACT RESP1
 (EXT X GTR_SA < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESP1_5d {
@ Min Space between non-silicide poly resistors and un-related implant region (follow GT.10 rule) is 0.16um
@NOTICE: It is a guidelines rule.
  X = HRP NOT INTERACT RESP1
  (EXT X GTR_SA < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESP1_5e {
@ Min Space between non-silicide poly resistors and un-related implant region (follow GT.10 rule) is 0.16um
@NOTICE: It is a guidelines rule.
  X = NPR1 NOT INTERACT RESP1
  (EXT X GTR_SA < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESP1_6 {
@ Min Extension of RESP1 outside of non-silicide poly resistor area is 0.2
@ NOTICE: It is a guidelines rule.
  //ENC GTR_SA RESP1 < 0.2 ABUT>0 <90 SINGULAR REGION
  X = GTR_SA COIN EDGE GT
  (ENC X RESP1 < 0.2 ABUT <90 REGION) NOT INSIDE EDGE EXDRC
}
RESP1_7 {
@ For silicide Poly resistor, two sides of RESP1 must be along the CT edge
@ NOTICE: It is a guidelines rule.
  X = CT AND GTR_NS
  Y = (RESP1 NOT INTERACT SAB) INSIDE EDGE GT
 (Y NOT TOUCH EDGE X) NOT INSIDE EDGE EXDRC
}
RESP1_8 {
@ Min Extension of SAB outside of non-silicide poly resistor area(follow SAB.6 rule) is 0.2
@ NOTICE: It is a guidelines rule.
  (ENC GTR SAB < 0.2 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
RESP1_9 {
@ Fixed Space between SAB and CT for non-silicide poly resistor is 0.2
@NOTICE: It is a guidelines rule.
  X = GTR INTERACT SAB
  Y = CT AND X
  ((SIZE Y BY 0.2) NOT TOUCH GTR_SA) NOT INSIDE EXDRC

}
RESP1_10 {
@ Min Enclosure of SP/SN outside of a Poly resistor area (following GT.9 rule) is 0.16
@NOTICE: It is a guidelines rule.
  X = RESP1 AND GT
  (ENC X SN < 0.16 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
  (ENC X SP < 0.16 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}
if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK RESP1_1a_R {
@ Suggest the Nsq >= 1 for stable Resistivity
SETLAYER  X = RESP1 AND SAB 
SETLAYER  Y = (GT AND RESP1) AND SAB 
SETLAYER  L = (INSIDE EDGE GT X) OR EDGE (GT COIN EDGE X)
SETLAYER  W = INSIDE EDGE Y GT
OUTLAYER  (DFM PROPERTY Y L W OVERLAP ABUT ALSO \[SQUARES = LENGTH(L)/LENGTH(W)\] < 1) NOT INSIDE EXDRC
}
RULECHECK RESP1_4_R {
@ Dog-bone design at the end of non-silicide poly resistor for contact pick-up is not suggested
@ NOTICE: It is a guidelines rule.
  SETLAYER X = GTR INTERACT SAB
  OUTLAYER (CONVEX EDGE X ==1) NOT INSIDE EDGE EXDRC
}
}



if { [string equal $Poly_EFuse_CHECK YES] ==1 } {

VERBATIM {
//=======================
//    Poly E-Fuse DRC 
//=======================

GROUP GEFU EFU_?
EFU_1b_G {
@ FUSEMK1 (81:152) must interact with EFUSE (81:2) region.
(FUSEMK1 NOT INTERACT EFUSE) NOT INSIDE EXDRC
}
EFU_1c_G {
@ FUSEMK1 (81:152) must fully cover EFUSE (81:2) region.
(EFUSE NOT FUSEMK1) NOT INSIDE EXDRC
}
EFU_2b_G {
@ EFUSE (81:2) must interact with GTFUSE(81:1).
(EFUSE NOT INTERACT GTFUSE) NOT INSIDE EXDRC
}
EFU_2c_G {
@ EFUSE (81:2) must fully cover GTFUSE(81:1).
(GTFUSE NOT EFUSE) NOT INSIDE EXDRC
}
}
}


VERBATIM {
//==================================
//  HRP - High Resistance Poly DRC
//==================================

GROUP GHRP HRP_?

HRP_1 {
@ Min Width of HRP is 0.21
@NOTICE: It is a guidelines rule.
  (INT HRP < 0.21 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
HRP_2 {
@Min Space between two HRP is 0.21
@NOTICE: It is a guidelines rule.
  (EXT HRP < 0.21 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
HRP_4 {
@ Min HRP enclosure of high resistance poly is 0.2
@NOTICE: It is a guidelines rule.
  (ENC GT_HRP HRP < 0.20 ABUT SINGULAR REGION) NOT INSIDE EXDRC
}
HRP_5_6 {
@ Minimum clearance from HRP region to Polygate of NMOS/PMOS is 0.16
@NOTICE: It is a guidelines rule.
  GT_MOS = GT INTERACT GATE
  (EXT HRP GT_MOS < 0.16 ABUT SINGULAR REGION) NOT INSIDE EXDRC
}
HRP_7 {
@ Minimum and maximum P+ implant for pickup overlap with SAB is 0.30
@NOTICE: It is a guidelines rule.
  SP_HRP = SP INTERACT HRP
  SAB_HRP = SAB INTERACT HRP
  X = SP_HRP AND SAB_HRP
  (INT X < 0.30 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  (SIZE X BY 0.15 UNDEROVER) NOT INSIDE EXDRC
}
HRP_8 {
@ Minimum extension from SAB region beyond a poly resistor region is 0.22
@NOTICE: It is a guidelines rule.
  (ENC (GT INTERACT GT_HRP) SAB < 0.22 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
HRP_9 {
@ Minimum width of Poly region for high resistance poly resistor is 2.00
@NOTICE: It is a guidelines rule.
  X = (GT INTERACT GT_HRP) NOT COIN EDGE SP
  (INT X < 2.0 OPPOSITE REGION) NOT INSIDE EXDRC
}
HRP_10 {
@ Dummy layer "HRPDMY" is needed for DRC for high resistance Poly region
@NOTICE: It is a guidelines rule.
  SAB_HRP = SAB INTERACT HRP
  (SAB_HRP NOT INTERACT HRPDMY) NOT INSIDE EXDRC
}
HRP_11 {
@ (SN, SP) layers are not allowed in the HRPDMY region (when checking the rule, size down the HRPDMY by 0.3um along the current direction)
@NOTICE: It is a guidelines rule.
 HRPR    = GT INTERACT HRP
 HRP_END = SIZE (HRPR NOT HRPDMY) BY 0.3
 HRP_MID = HRPR NOT HRP_END
 ((SN OR SP) AND HRP_MID) NOT INSIDE EXDRC
}
HRP_12 {
@ HRPDMY edge should align with SAB edge.
@NOTICE: It is a guidelines rule.
 SAB_AND_HRP = (SAB INTERACT HRP) AND GT
 DMY_AND_HRP = HRPDMY AND GT
 (SAB_AND_HRP XOR DMY_AND_HRP) NOT INSIDE EXDRC
}
HRP_14 {
@ Fixed Space between SAB and CT in HRP region is 0.2
@NOTICE: It is a guidelines rule.
  X = HRP INTERACT SAB
  Y = CT AND X
  ((SIZE Y BY 0.2) NOT TOUCH (SAB INTERACT HRP)) NOT INSIDE EXDRC
}
}
if { [string equal $Recommended_rules_OTHER YES] == 1 } {
RULECHECK HRP_3_R {
@ It is strongly suggest that resistor square number >= 5 for precision Rs
SETLAYER  X = HRPDMY INTERACT SAB
SETLAYER  Y = X INTERACT HRP 
SETLAYER  Z = (GT AND HRPDMY) AND SAB
SETLAYER  L = (INSIDE EDGE GT Y) OR EDGE (GT COIN EDGE Y)
SETLAYER  W = INSIDE EDGE Z GT
OUTLAYER  (DFM PROPERTY Z L W OVERLAP ABUT ALSO \[SQUARES = LENGTH(L)/LENGTH(W)\] < 5) NOT INSIDE EXDRC
}
}

VERBATIM {
LDAA = AA AND LDBK
LDPAA = LDAA AND SP
LDNAA = LDAA AND SN
//LDPAAOD = LDPAA AND OVERPL
//LDNAAOD = LDNAA AND OVERPL
LDPGATE = LDPAA AND GT
LDNGATE = LDNAA AND GT
//LDPGATEOD = LDPGATE AND OVERPL
//LDNGATEOD = LDNGATE AND OVERPL
LDPD = (LDPAA NOT INTERACT GT) TOUCH STIDMY
LDND = (LDNAA NOT INTERACT GT) TOUCH STIDMY
LDPS = (LDPAA INTERACT GT) NOT LDPGATE
LDNS = (LDNAA INTERACT GT) NOT LDNGATE
SD_LDMOS = OR LDPD LDND LDPS LDNS
GT_LDMOS = LDPGATE OR LDNGATE
AA_LDMOS = SD_LDMOS OR GT_LDMOS
}

if { [string equal $LDMOS_CHECK YES] == 1 } {
VERBATIM {
//============================
//  LDAA - LDMOS layout DRC
//============================

GROUP GLDAA LD_?
/*
LD_1a_G {
@ Min. LDMOS gate length is 0.48
@NOTICE: It is a guidelines rule.
  (INT LDNGATE < 0.48 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  (INT LDPGATE < 0.48 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
LD_2_G {
@ Dummy layer STIDMY is required for LDMOS transistor field plate area.
@ Fixed STI width for LDMOS transistor drain side field plate is 0.11
@NOTICE: It is a guidelines rule.
  (INT STIDMY < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  (STIDMY ENCLOSE (SIZE STIDMY BY -0.11/2)) NOT INSIDE EXDRC
}
LD_3_G {
@ Fixed Overlap of NW and LDNMOS gate is 0.20
@NOTICE: It is a guidelines rule.
  (INT NW LDNGATE < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  ((LDNGATE AND NW) ENCLOSE (SIZE (LDNGATE AND NW) BY -0.10)) NOT INSIDE EXDRC
}
LD_4_G {
@ Fixed Overlap of PW and LDPMOS gate is 0.20
@NOTICE: It is a guidelines rule.
  (ENC NW LDPGATE < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  ((LDPGATE NOT NW) ENCLOSE (SIZE (LDPGATE NOT NW) BY -0.10)) NOT INSIDE EXDRC
}
LD_5a_G {
@ Min. channel width for LDMOS transistors is 2
@NOTICE: It is a guidelines rule.
  (INT (LDAA IN EDGE GT) < 2 ABUT<90 REGION) NOT INSIDE EXDRC
}
LD_6_G {
@ Min Space between one LDMOS gate poly to another LDMOS gate poly on source side is 0.27
@NOTICE: It is a guidelines rule.
  X = GT INSIDE EDGE LDAA
  (EXT X < 0.27 REGION) NOT INSIDE EXDRC
}
LD_7_G {
@ Min NW or PW extension outside of LDMOS AA along gate poly length direction is 0.25(Extension <= 0 is not allowed)
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE STIDMY
  X2 = INT X1 LDAA < 0.005 ABUT REGION INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) NOT COIN EDGE X1
  (ENC X3 NW < 0.25 ABUT < 90 REGION) NOT INSIDE EXDRC
  (EXT X3 NW < 0.25 ABUT < 90 REGION) NOT INSIDE EXDRC
}
LD_8a_G {
@ Min Space between LDMOS source side AA and pickup AA along source/drain direction is 0.6
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE GT
  X2 = INT X1 LDAA < 0.005 ABUT REGION INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) OR EDGE X1
  X4 = (LDAA WITH EDGE X3) NOT COIN EDGE X3
  (EXT X4 (PTAP OR NTAP) < 0.6 ABUT < 90 REGION ) NOT INSIDE EXDRC
}
LD_8b_G {
@ Min Space between LDMOS source side AA and pickup AA along gate poly direction is 0.9
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE GT
  X2 = INT X1 LDAA < 0.005 ABUT REGION INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) NOT TOUCH EDGE X1
  (EXT X3 (PTAP OR NTAP) < 0.9 ABUT < 90 REGION) NOT INSIDE EXDRC
}
LD_9_G {
@ GT to STI drain side field plate overlap is 0
@NOTICE: It is a guidelines rule.
  (GT AND STIDMY) NOT INSIDE EXDRC
  ((STIDMY AND LDBK) NOT TOUCH GT) NOT INSIDE EXDRC
}
LD_10_G {
@ LDMOS block layer (LDBK) is used to identify LDMOS function area.
@ Min LDBK extension outside of MOSAA is 0.4.
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH STIDMY
  (ENC X1 LDBK < 0.4 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
LD_11_G {
@ STIDMY enclosure LDMOS drain side field plate is 0
@NOTICE: It is a guidelines rule.
  X = STIDMY AND LDAA
  Y = STIDMY NOT TOUCH (LDAA NOT GT)
  (X OR Y) NOT INSIDE EXDRC
}
LD_12_G {
@ Min CT to GT space on LDMOS at source side is 0.11
@NOTICE: It is a guidelines rule.
  X =  CT AND (LDAA INTERACT GT)
  (EXT X GT < 0.11 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

LD_14_G {
@ LDMOS drain side AA width. >= 0.21um
@ NOTICE: It is a guidelines rule.
  X = (AA NOT GT) TOUCH STIDMY
  (INT X < 0.21 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
*/



LD_1a_G {
@ Min. LDMOS gate length is 0.48
@NOTICE: It is a guidelines rule.
  (INT LDNGATE < 0.48 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  (INT LDPGATE < 0.48 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
LD_1a_NOSHR_G {
@ Min. LDMOS gate length is 0.532
@NOTICE: It is a guidelines rule.
  X1 = INT LDNGATE < 0.532 ABUT<90 SINGULAR REGION
  (X1 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC

  X2 = INT LDPGATE < 0.532 ABUT<90 SINGULAR REGION
  (X2 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//-------------------------------------------------------------------------
LD_2_G {
@ Dummy layer STIDMY is required for LDMOS transistor field plate area.
@ Fixed STI width for LDMOS transistor drain side field plate is 0.11
@NOTICE: It is a guidelines rule.
  X1 = INT STIDMY < 0.11 ABUT<90 SINGULAR REGION
  (X1 NOT INSIDE NOSHR) NOT INSIDE EXDRC 

  X2 = STIDMY ENCLOSE (SIZE STIDMY BY -0.11/2)
  (X2 NOT INSIDE NOSHR) NOT INSIDE EXDRC
}
LD_2_NOSHR_G {
@ Dummy layer STIDMY is required for LDMOS transistor field plate area.
@ Fixed STI width for LDMOS transistor drain side field plate is 0.122
@NOTICE: It is a guidelines rule.
  X1 = INT STIDMY < 0.121 ABUT<90 SINGULAR REGION
  (X1 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC

  X2 = STIDMY ENCLOSE (SIZE STIDMY BY -0.062)
  (X2 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_3_G {
@ Fixed Overlap of NW and LDNMOS gate is 0.20
@NOTICE: It is a guidelines rule.
  X1 = INT NW LDNGATE < 0.20 ABUT<90 SINGULAR REGION
  (X1 NOT INSIDE NOSHR) NOT INSIDE EXDRC

  X2 = (LDNGATE AND NW) ENCLOSE (SIZE (LDNGATE AND NW) BY -0.10)
  (X2 NOT INSIDE NOSHR) NOT INSIDE EXDRC
}
LD_3_NOSHR_G {
@ Fixed Overlap of NW and LDNMOS gate is 0.222
@NOTICE: It is a guidelines rule.
  X1 = INT NW LDNGATE < 0.221 ABUT<90 SINGULAR REGION
  (X1 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC

  X2 = (LDNGATE AND NW) ENCLOSE (SIZE (LDNGATE AND NW) BY -0.112)
  (X2 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_4_G {
@ Fixed Overlap of PW and LDPMOS gate is 0.20
@NOTICE: It is a guidelines rule.
  X1 = ENC NW LDPGATE < 0.20 ABUT<90 SINGULAR REGION
  (X1 NOT INSIDE NOSHR) NOT INSIDE EXDRC

  X2 = (LDPGATE NOT NW) ENCLOSE (SIZE (LDPGATE NOT NW) BY -0.10)
  (X2 NOT INSIDE NOSHR) NOT INSIDE EXDRC
}
LD_4_NOSHR_G {
@ Fixed Overlap of PW and LDPMOS gate is 0.222
@NOTICE: It is a guidelines rule.
  X1 = ENC NW LDPGATE < 0.221 ABUT<90 SINGULAR REGION
  (X1 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC

  X2 = (LDPGATE NOT NW) ENCLOSE (SIZE (LDPGATE NOT NW) BY -0.112)
  (X2 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_5a_G {
@ Min. channel width for LDMOS transistors is 2
@NOTICE: It is a guidelines rule.
  (INT (LDAA IN EDGE GT) < 2 ABUT<90 REGION) NOT INSIDE EXDRC
}
LD_5a_NOSHR_G {
@ Min. channel width for LDMOS transistors is 2.219
@NOTICE: It is a guidelines rule.
  X = INT (LDAA IN EDGE GT) < 2.219 ABUT<90 REGION
  (X NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_6_G {
@ Min Space between one LDMOS gate poly to another LDMOS gate poly on source side is 0.27
@NOTICE: It is a guidelines rule.
  X = GT INSIDE EDGE LDAA
  (EXT X < 0.27 REGION) NOT INSIDE EXDRC
}
LD_6_NOSHR_G {
@ Min Space between one LDMOS gate poly to another LDMOS gate poly on source side is 0.299
@NOTICE: It is a guidelines rule.
  X = GT INSIDE EDGE LDAA
  Y = EXT X < 0.299 REGION
  (Y NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_7_G {
@ Min NW or PW extension outside of LDMOS AA along gate poly length direction is 0.25(Extension <= 0 is not allowed)
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE STIDMY
  X2 = INT X1 [LDAA] < 0.005 ABUT INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) NOT COIN EDGE X1
 (ENC X3 NW < 0.25 ABUT < 90 REGION) NOT INSIDE EXDRC
 (EXT X3 NW < 0.25 ABUT < 90 REGION) NOT INSIDE EXDRC
}
LD_7_NOSHR_G {
@ Min NW or PW extension outside of LDMOS AA along gate poly length direction is 0.277
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE STIDMY
  X2 = INT X1 [LDAA] < 0.005 ABUT INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) NOT COIN EDGE X1
  Y1 = ENC X3 NW < 0.277 ABUT < 90 REGION
  (Y1 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
 
  Y2 = EXT X3 NW < 0.277 ABUT < 90 REGION
  (Y2 NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_8a_G {
@ Min Space between LDMOS source side AA and pickup AA along source/drain direction is 0.6
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE GT
  X2 = INT X1 [LDAA] < 0.005 ABUT INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) OR EDGE X1
  X4 = (LDAA WITH EDGE X3) NOT COIN EDGE X3
  (EXT X4 (PTAP OR NTAP) < 0.6 ABUT < 90 REGION) NOT INSIDE EXDRC
}
LD_8a_NOSHR_G {
@ Min Space between LDMOS source side AA and pickup AA along source/drain direction is 0.665
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE GT
  X2 = INT X1 [LDAA] < 0.005 ABUT INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) OR EDGE X1
  X4 = (LDAA WITH EDGE X3) NOT COIN EDGE X3
  Y = EXT X4 (PTAP OR NTAP) < 0.665 ABUT < 90 REGION
  (Y NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_8b_G {
@ Min Space between LDMOS source side AA and pickup AA along gate poly direction is 0.9
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE GT
  X2 = INT X1 [LDAA] < 0.005 ABUT INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) NOT TOUCH EDGE X1
 (EXT X3 (PTAP OR NTAP) < 0.9 ABUT < 90 REGION) NOT INSIDE EXDRC
}
LD_8b_NOSHR_G {
@ Min Space between LDMOS source side AA and pickup AA along gate poly direction is 0.998
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH EDGE GT
  X2 = INT X1 [LDAA] < 0.005 ABUT INTERSECTING ONLY
  X3 = (LDAA TOUCH EDGE X2) NOT TOUCH EDGE X1
  Y = EXT X3 (PTAP OR NTAP) < 0.998 ABUT < 90 REGION
 (Y NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_9_G {
@ GT to STI drain side field plate overlap is 0
@NOTICE: It is a guidelines rule.
  (GT AND STIDMY) NOT INSIDE EXDRC
  ((STIDMY AND LDBK) NOT TOUCH GT) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_10_G {
@ LDMOS block layer (LDBK) is used to identify LDMOS function area.
@ Min LDBK extension outside of MOSAA is 0.4.
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH STIDMY
  (ENC X1 LDBK < 0.4 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
LD_10_NOSHR_G {
@ LDMOS block layer (LDBK) is used to identify LDMOS function area.
@ Min LDBK extension outside of MOSAA is 0.443.
@NOTICE: It is a guidelines rule.
  X1 = LDAA TOUCH STIDMY
  Y = ENC X1 LDBK < 0.443 ABUT < 90 SINGULAR REGION
  (Y NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_11_G {
@ STIDMY enclosure LDMOS drain side field plate is 0
@NOTICE: It is a guidelines rule.
  X = STIDMY AND LDAA
  Y = STIDMY NOT TOUCH (LDAA NOT GT)
  (X OR Y) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_12_G {
@ Min CT to GT space on LDMOS at source side is 0.11
@NOTICE: It is a guidelines rule.
  X =  CT AND (LDAA INTERACT GT)
  (EXT X GT < 0.11 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
LD_12_NOSHR_G {
@ Min CT to GT space on LDMOS at source side is 0.121
@NOTICE: It is a guidelines rule.
  X = CT AND (LDAA INTERACT GT)
  Y = EXT X GT < 0.121 ABUT < 90 SINGULAR REGION
  (Y NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}

//---------------------------------------------------------------------------------
LD_14_G {
@ LDMOS drain side AA width. >= 0.21um
@ NOTICE: It is a guidelines rule.
  X = (AA NOT GT) TOUCH STIDMY
  (INT X < 0.21 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
LD_14_NOSHR_G {
@ LDMOS drain side AA width. >= 0.233um
@ NOTICE: It is a guidelines rule.
  X = (AA NOT GT) TOUCH STIDMY
  Y = INT X < 0.233 ABUT < 90 SINGULAR REGION
  (Y NOT OUTSIDE NOSHR) NOT INSIDE EXDRC
}
}
}

if { [string equal $DUP_CHECK YES] ==1 } {
VERBATIM {
//=========================================
// DUP (Device Under Pad) Pad Guidelines
//=========================================

padarea = DUPMK1 AND MD
}

GROUP GDUP DUP_?

RULECHECK DUP_1_G {
@ For MD that interacts with DUPMK1, this piece of MD must be fully covered by DUPMK1.
OUTLAYER  ((MD INTERACT DUPMK1) NOT DUPMK1) NOT INSIDE EXDRC
}		
RULECHECK DUP_2_G {
@ Two metal layers (TM and TM-1) are needed between DUP pad and device, where the metal design must be solid.
OUTLAYER ( padarea ENCLOSE (padarea NOT [lindex $metal_all end])) NOT INSIDE EXDRC
OUTLAYER ( padarea ENCLOSE (padarea NOT [lindex $metal_all end-1])) NOT INSIDE EXDRC
}
RULECHECK DUP_5_G {
@ ALPAR, MOMDMY, INDMY, Resistor of TM or TM-1 must be outside of DUP pad area.
SETLAYER X1 = (ALPAR OR MOMDMY) OR INDMY
SETLAYER X2 = ([lindex $metal_all end]R AND [lindex $metal_all end]) OR ([lindex $metal_all end-1]R AND [lindex $metal_all end-1])
OUTLAYER  ((X1 OR X2) AND padarea) NOT INSIDE EXDRC
}
RULECHECK DUP_6_G {
@ For one top metal process: TV-1 pattern is not allowed under the DUP pad opening area.
@ For two top metal process: TV1 or STV1 patterns are not allowed under the DUP pad opening area.
OUTLAYER (padarea AND [lindex $via_all end-1]) NOT INSIDE EXDRC
}
}

#//====================
#//  Seal Ring Rules
#//====================

GROUP GSRCK SRCK_?


#//Contact, via and TV slots are not permitted for main chip design except guard ring/seal ring applications.
#//(CT/via patterns, with the width/length ratio larger than 3, should be taken as Contact/via slots.)

SETLAYER CTS = CT AND MARKS
SETLAYER CTS_SL = CT AND (ENCLOSE RECTANGLE CTS 0.09 0.27)
SETLAYER CTS_SQ = CTS NOT CTS_SL

SETLAYER AAS = AAi AND (AAi ENCLOSE CTS)

foreach j $m_j {
  SETLAYER M${j}S = M${j}i AND MARKS
  SETLAYER M${j}S_INNER = M${j}S TOUCH (HOLES M${j}S INNER) == 1
  SETLAYER M${j}S_OUTER = HOLES M${j}S
  SETLAYER M${j}S_RING = M${j}i AND (M${j}S INTERACT M${j}S_OUTER)
  if { ($j < 8) && ([set CHECK_V$j] == 1) } {
  SETLAYER V${j}S = V${j} AND MARKS
  SETLAYER V${j}S_SL = V${j} AND (ENCLOSE RECTANGLE V${j}S 0.09 0.27)
  SETLAYER V${j}S_SQ = V${j}S NOT V${j}S_SL
  VERBATIM { }
  }
}

if { ([set CHECK_TV1] == 1) && ([set CHECK_TM1] == 1) } {
  SETLAYER TV1S = TV1i AND MARKS
  SETLAYER TV1S_SL = TV1i AND (ENCLOSE RECTANGLE TV1S 0.25 0.75)
  SETLAYER TV1S_SQ = TV1S NOT TV1S_SL

  SETLAYER TM1S = TM1i AND MARKS
  SETLAYER TM1S_INNER = TM1S TOUCH (HOLES TM1S INNER) == 1
  SETLAYER TM1S_OUTER = HOLES TM1S
  SETLAYER TM1S_RING = TM1i AND (TM1S INTERACT TM1S_OUTER)

  VERBATIM { }
}

if { ([set CHECK_TV2] == 1) && ([set CHECK_TM2] == 1) } {
  SETLAYER TV2S = TV2i AND MARKS
  SETLAYER TV2S_SL = TV2i AND (ENCLOSE RECTANGLE TV2S 0.25 0.75)
  SETLAYER TV2S_SQ = TV2S NOT TV2S_SL

  SETLAYER TM2S = TM2i AND MARKS
  SETLAYER TM2S_INNER = TM2S TOUCH (HOLES TM2S INNER) == 1
  SETLAYER TM2S_OUTER = HOLES TM2S
  SETLAYER TM2S_RING = TM2i AND (TM2S INTERACT TM2S_OUTER)

  VERBATIM { }
}

if { ([set CHECK_STV1] == 1) && ([set CHECK_STM1] == 1) } {
  SETLAYER STV1S = STV1i AND MARKS
  SETLAYER STV1S_SL = STV1i AND (ENCLOSE RECTANGLE STV1S 0.19 0.57)
  SETLAYER STV1S_SQ = STV1S NOT STV1S_SL

  SETLAYER STM1S = STM1i AND MARKS
  SETLAYER STM1S_INNER = STM1S TOUCH (HOLES STM1S INNER) == 1
  SETLAYER STM1S_OUTER = HOLES STM1S
  SETLAYER STM1S_RING = STM1i AND (STM1S INTERACT STM1S_OUTER)

  VERBATIM { }
}

if { ([set CHECK_STV2] == 1) && ([set CHECK_STM2] == 1) } {
  SETLAYER STV2S = STV2i AND MARKS
  SETLAYER STV2S_SL = STV2i AND (ENCLOSE RECTANGLE STV2S 0.19 0.57)
  SETLAYER STV2S_SQ = STV2S NOT STV2S_SL

  SETLAYER STM2S = STM2i AND MARKS
  SETLAYER STM2S_INNER = STM2S TOUCH (HOLES STM2S INNER) == 1
  SETLAYER STM2S_OUTER = HOLES STM2S
  SETLAYER STM2S_RING = STM2i AND (STM2S INTERACT STM2S_OUTER)

  VERBATIM { }
}

SETLAYER RDLVIAS = RDLVIAi AND MARKS
SETLAYER RDLS = RDLi AND MARKS
SETLAYER RDLS_INNER = RDLS TOUCH (HOLES RDLS INNER) == 1
SETLAYER RDLS_OUTER = HOLES RDLS
SETLAYER RDLS_RING = RDLi AND (RDLS INTERACT RDLS_OUTER)

VERBATIM { }


set MS_RING_INNER "RDLS_INNER OR [lindex $metal_all 0]S_INNER"
foreach metal_each [lreplace $metal_all 0 0] {
  set MS_RING_INNER "(${MS_RING_INNER}) OR ${metal_each}S_INNER"
}
SETLAYER MS_RING_INNER = $MS_RING_INNER

set M_ALL "[lindex $metal_all 0]i OR [lindex $metal_all 1]i"
foreach metal_each [lreplace $metal_all 0 1] {
  set M_ALL "(${M_ALL}) OR ${metal_each}i"
}
SETLAYER M_ALL = $M_ALL

set MDUM_ALL "[lindex $metal_dummy_list 0] OR [lindex $metal_dummy_list 1]"
foreach metal_dummy_each [lreplace $metal_dummy_list 0 1] {
  set MDUM_ALL "(${MDUM_ALL}) OR $metal_dummy_each"
}
SETLAYER MDUM_ALL = $MDUM_ALL

SETLAYER MA_ALL = M_ALL NOT INSIDE MARKS

set ISOLATION "MARKS AND (HOLES M1S_INNER INNER)"
foreach metal_each [lreplace $metal_all 0 0] {
  set ISOLATION "(${ISOLATION}) AND (MARKS AND (HOLES ${metal_each}S_INNER INNER))"
}
SETLAYER ISOLATION = $ISOLATION


CONNECT AAS M1S_RING BY CTS
for { set i 0 } { $i < [expr [llength $v_m_list] -2] } { incr i 2 } {
  CONNECT [lindex $v_m_list $i]S_RING [lindex $v_m_list [expr $i +2]]S_RING BY [lindex $v_m_list [expr $i +1]]S
}
CONNECT MARKS [lindex $v_m_list end]S_RING
CONNECT [lindex $v_m_list end]S_RING RDLS_RING BY RDLVIAS



RULECHECK SRCK_1 {
@ Fixed CT slot width is 0.09
@ NOTICE: It is a guidelines rule.
  SETLAYER X = INT CTS < 0.089 ABUT<90 SINGULAR REGION
  SETLAYER Y = CTS WITH WIDTH > 0.091
  OUTLAYER (X OR Y) NOT INSIDE EXDRC
}

RULECHECK SRCK_2 {
@ Fixed Vn slot width (n=1~7) is 0.09
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  OUTLAYER (INT ${via}S < 0.089 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
  OUTLAYER (${via}S WITH WIDTH > 0.091) NOT INSIDE EXDRC
}
}

if { ($CHECK_TV1 == 1) || ($CHECK_TV2 == 1) } {
RULECHECK SRCK_3 {
@ Fixed TVn(n=1~2) (for 4X option and UTV2) slot width is = 0.28,DRC waive check 0.36um square TVn
foreach top_via { TV1 TV2 } {
  if { [set CHECK_$top_via] == 1 } {
    SETLAYER VIA_${top_via} = RECTANGLE ${top_via}S == 0.36 BY == 0.36
    SETLAYER TOP_${top_via} = ${top_via}S NOT VIA_${top_via}      
    OUTLAYER (INT TOP_${top_via} < 0.279 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
    OUTLAYER (TOP_${top_via} WITH WIDTH > 0.281) NOT INSIDE EXDRC
    
#   OUTLAYER (INT ${top_via}S < 0.279 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#   OUTLAYER (${top_via}S WITH WIDTH > 0.281) NOT INSIDE EXDRC
  }
}
}
}

if { ($CHECK_STV1 == 1) || ($CHECK_STV2 == 1) } {
RULECHECK SRCK_4 {
@ STVn(n=1~2) slot width (for 2X option) is >= 0.20 and <= 0.222
@ NOTICE: It is a guidelines rule.
foreach top_via { STV1 STV2 } {
  if { [set CHECK_$top_via] == 1 } {
    OUTLAYER (INT ${top_via}S < 0.199 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
    OUTLAYER (${top_via}S WITH WIDTH > 0.223) NOT INSIDE EXDRC
  }
}
}
}

RULECHECK SRCK_5 {
@ Minimum space between contact slots is 1.33
@ NOTICE: It is a guidelines rule.
  OUTLAYER (EXT CTS_SL < 1.33 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK SRCK_6 {
@ Minimum space between via slots is 1.33
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  OUTLAYER (EXT ${via}S_SL < 1.33 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK SRCK_7 {
@ Minimum space between TV slots is 1.33
@ NOTICE: It is a guidelines rule.
foreach t_v_list_layer $t_v_j {
  OUTLAYER (EXT ${t_v_list_layer}S_SL < 1.33 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK SRCK_8 {
@ Minimum space between square contact and contact slot is 0.444
@ NOTICE: It is a guidelines rule.
  OUTLAYER (EXT CTS_SL CTS_SQ < 0.444 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}


RULECHECK SRCK_9 {
@ Minimum space between square via and via slot is 0.444
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  OUTLAYER (EXT ${via}S_SL ${via}S_SQ < 0.444 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK SRCK_10 {
@ Minimum space between square TV and TV slot is 0.422
@ NOTICE: It is a guidelines rule.
foreach t_v_list_layer $t_v_j {
  OUTLAYER (EXT ${t_v_list_layer}S_SL ${t_v_list_layer}S_SQ < 0.422 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}


RULECHECK SRCK_11 {
@ V1 (both square via and slot patterns) enclosure by M1 in MARKS covered areas is 0.1
@ NOTICE: It is a guidelines rule.
  OUTLAYER (ENC V1S M1S < 0.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}


RULECHECK SRCK_12 {
@ Vn (both square via and slot patterns) enclosure by Mn in MARKS covered areas (n=2~7) is 0.1
@ NOTICE: It is a guidelines rule.
for { set j 2 } { $j <= [lindex $v_j end] } { incr j } {
  OUTLAYER (ENC V${j}S M${j}S < 0.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK SRCK_13 {
@ Vn (both square via and slot patterns)enclosure by Mn+1 in MARKS covered areas (n=2~7) is 0.1
@ NOTICE: It is a guidelines rule.
for { set j 2 } { $j <= [lindex $m_j end] } { incr j } {
  set i [expr $j-1]
  OUTLAYER (ENC V${i}S M${j}S < 0.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK SRCK_14 {
@ Min TM1/TM2 (STM1/STM2/MTT2) enclosure of TV1/TV2 (STV1/STV2/UTV2, both square via and slot patterns) in MARKS covered areas is 0.1
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC [lindex $top_v_m_list 0]S [lindex $top_v_m_list 1]S < 0.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
if { [llength $top_v_m_list] == 4 } {
  OUTLAYER (ENC [lindex $top_v_m_list 2]S [lindex $top_v_m_list 3]S < 0.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
} 
}

RULECHECK SRCK_15 {
@ Min Mn enclosure of TV1/TV2 (or STV1/STV2/UTV2, both square via and slot patterns) in MARKS covered areas is 0.1.
@ ( Mn is the metal layer underneath of TV1/TV2/STV1/STV2/UTV2.)
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC [lindex $top_v_m_list 0]S [lindex $m_j_layer end]S < 0.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
if { [llength $top_v_m_list] == 4 } {
  OUTLAYER (ENC [lindex $top_v_m_list end-1]S [lindex $top_v_m_list end-2]S < 0.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK SRCK_17 {
@ Min Isolation distance between active patterns (AA/GT/METAL/RDL) and internal metal ring edge is 11.1
@ NOTICE: It is a guidelines rule.
OUTLAYER (EXT (AA NOT INSIDE MARKS) MS_RING_INNER < 11.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT (GT NOT INSIDE MARKS) MS_RING_INNER < 11.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT MA_ALL MS_RING_INNER < 11.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT (RDL NOT INSIDE MARKS) MS_RING_INNER < 11.1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK SRCK_18 {
@ No patterns (AA/GT/METAL/RDL) are allowed inside isolation areas
@ NOTICE: It is a guidelines rule.

OUTLAYER (AND ISOLATION AA) NOT INSIDE EXDRC
OUTLAYER (AND ISOLATION GT) NOT INSIDE EXDRC
OUTLAYER (AND ISOLATION M_ALL) NOT INSIDE EXDRC
OUTLAYER (AND ISOLATION RDL) NOT INSIDE EXDRC
}

RULECHECK SRCK_19 {
@ No AA/GT/Metal dummy patterns are allowed MARKS covered areas.
@ NOTICE: It is a guidelines rule.
OUTLAYER (AND MARKS AADUM) NOT INSIDE EXDRC
OUTLAYER (AND MARKS GTDUM) NOT INSIDE EXDRC
OUTLAYER (AND MARKS MDUM_ALL) NOT INSIDE EXDRC
}

#list SRCK20,SRCK20_layer
RULECHECK SRCK_20 {
@ Designers should refer to the seal ring layout (Fig. 1), which should include AA, CT, Mn(n=1~8), TM1(STM1), TM2(STM2/MTT2), Vn(n=1~7), TV1/STV1, TV2/STV2,
@ to provide a low resistance path to ground for surge currents
@ NOTICE: It is a guidelines rule.
SETLAYER X = NET AREA RATIO MARKS $SRCK20_layer CTS AAS > 0 \[${SRCK20}!!(AREA(CTS))*!!(AREA(AAS))\]
OUTLAYER (MARKS NOT X) NOT INSIDE EXDRC

SETLAYER Y = NET AREA RATIO RDLS_RING RDLVIAS [lindex $SRCK20_layer 0] > 0 \[[lindex $SRCK20 0]!!(AREA(RDLVIAS))*!!(AREA(RDLS_RING))\]
OUTLAYER ((MARKS ENCLOSE RDLS_RING) NOT ENCLOSE Y) NOT INSIDE EXDRC

SETLAYER Z = NET AREA RATIO RDLVIAS RDLS_RING [lindex $SRCK20_layer 0] > 0 \[[lindex $SRCK20 0]!!(AREA(RDLVIAS))*!!(AREA(RDLS_RING))\]
OUTLAYER ((MARKS ENCLOSE RDLVIAS) NOT ENCLOSE Z) NOT INSIDE EXDRC
}

RULECHECK SRCK_21 {
@ Min Passivation slot width ('RDL via' is recommended as drawing layer) in MARKS covered areas is 2.22
@ NOTICE: It is a guidelines rule.
OUTLAYER (INT RDLVIAS < 2.22 ABUT<90 SINGULAR REGION ) NOT INSIDE EXDRC
}

RULECHECK SRCK_22 {
@ Min Passivation slot  (RDL via) enclosure by Al pattern (RDL) in MARKS covered areas is 1.11
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC RDLVIAS RDL < 1.11 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK SRCK_23 {
@ Min Passivation slot (RDL via) enclosure by TM2 in MARKS covered areas is 0.555
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC RDLVIAS [lindex $top_v_m_list end] < 0.555 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK SRCK_24 {
@ Enclosure of seal ring outer ring outline edge by BORDER layer (excluding seal ring corner dummy area) if seal ring has been added by designers. >= 1.665
@ NOTICE: It is a guidelines rule.
foreach metal_layer $metal_all {
OUTLAYER (ENC (${metal_layer}S TOUCH ${metal_layer}S_OUTER) BORDER < 1.665 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
OUTLAYER (ENC (RDLS TOUCH RDLS_OUTER) BORDER < 1.665 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK SRCK_25 {
@ All seal ring patterns should be enclosed by Border
@ NOTICE: It is a guidelines rule.
OUTLAYER (MARKS NOT BORDER) NOT INSIDE EXDRC
}


RULECHECK SRCK_26 {
@ AA, CT, M1/Mn/Vn/TMn/TVn/BCB1(RDL via) and RDL layers are must drawn layers in MARKS seal ring region. (STV2/STM2 for 4X option)
OUTLAYER (MARKS NOT INTERACT AA) NOT INSIDE EXDRC
#OUTLAYER (MARKS NOT INTERACT GT) NOT INSIDE EXDRC
OUTLAYER (MARKS NOT INTERACT CT) NOT INSIDE EXDRC
OUTLAYER (MARKS NOT INTERACT RDL) NOT INSIDE EXDRC
OUTLAYER (MARKS NOT INTERACT RDLVIA) NOT INSIDE EXDRC
foreach j $metal_all {
OUTLAYER (MARKS NOT INTERACT $j) NOT INSIDE EXDRC
}
foreach i $via_all {
OUTLAYER (MARKS NOT INTERACT $i) NOT INSIDE EXDRC
}
}





SETLAYER CTG = CT AND MARKGi
SETLAYER CTG_SL = CT AND (ENCLOSE RECTANGLE CTG 0.09 0.27)
SETLAYER CTG_SQ = CTG NOT CTG_SL

SETLAYER AAG = AAi AND (AAi ENCLOSE CTG)

foreach j $m_j {
  SETLAYER M${j}G = M${j}i AND MARKGi
  SETLAYER M${j}G_INNER = M${j}G TOUCH (HOLES M${j}G INNER) == 1
  SETLAYER M${j}G_OUTER = HOLES M${j}G
  SETLAYER M${j}G_RING = M${j}i AND (M${j}G INTERACT M${j}G_OUTER)
  if { ($j < 8) && ([set CHECK_V$j] == 1) } {
  SETLAYER V${j}G = V${j} AND MARKGi
  SETLAYER V${j}G_SL = V${j} AND (ENCLOSE RECTANGLE V${j}G 0.09 0.27)
  SETLAYER V${j}G_SQ = V${j}G NOT V${j}G_SL
  VERBATIM { }
  }
}

if { ([set CHECK_TV1] == 1) && ([set CHECK_TM1] == 1) } {
  SETLAYER TV1G = TV1i AND MARKGi
  SETLAYER TV1G_SL = TV1i AND (ENCLOSE RECTANGLE TV1G 0.25 0.75)
  SETLAYER TV1G_SQ = TV1G NOT TV1G_SL

  SETLAYER TM1G = TM1i AND MARKGi
  SETLAYER TM1G_INNER = TM1G TOUCH (HOLES TM1G INNER) == 1
  SETLAYER TM1G_OUTER = HOLES TM1G
  SETLAYER TM1G_RING = TM1i AND (TM1G INTERACT TM1G_OUTER)

}

if { ([set CHECK_TV2] == 1) && ([set CHECK_TM2] == 1) } {
  SETLAYER TV2G = TV2i AND MARKGi
  SETLAYER TV2G_SL = TV2i AND (ENCLOSE RECTANGLE TV2G 0.25 0.75)
  SETLAYER TV2G_SQ = TV2G NOT TV2G_SL

  SETLAYER TM2G = TM2i AND MARKGi
  SETLAYER TM2G_INNER = TM2G TOUCH (HOLES TM2G INNER) == 1
  SETLAYER TM2G_OUTER = HOLES TM2G
  SETLAYER TM2G_RING = TM2i AND (TM2G INTERACT TM2G_OUTER)

}

if { ([set CHECK_STV1] == 1) && ([set CHECK_STM1] == 1) } {
  SETLAYER STV1G = STV1i AND MARKGi
  SETLAYER STV1G_SL = STV1i AND (ENCLOSE RECTANGLE STV1G 0.19 0.57)
  SETLAYER STV1G_SQ = STV1G NOT STV1G_SL

  SETLAYER STM1G = STM1i AND MARKGi
  SETLAYER STM1G_INNER = STM1G TOUCH (HOLES STM1G INNER) == 1
  SETLAYER STM1G_OUTER = HOLES STM1G
  SETLAYER STM1G_RING = STM1i AND (STM1G INTERACT STM1G_OUTER)

}

if { ([set CHECK_STV2] == 1) && ([set CHECK_STM2] == 1) } {
  SETLAYER STV2G = STV2i AND MARKGi
  SETLAYER STV2G_SL = STV2i AND (ENCLOSE RECTANGLE STV2G 0.19 0.57)
  SETLAYER STV2G_SQ = STV2G NOT STV2G_SL

  SETLAYER STM2G = STM2i AND MARKGi
  SETLAYER STM2G_INNER = STM2G TOUCH (HOLES STM2G INNER) == 1
  SETLAYER STM2G_OUTER = HOLES STM2G
  SETLAYER STM2G_RING = STM2i AND (STM2G INTERACT STM2G_OUTER)

}

SETLAYER RDLVIAG = RDLVIAi AND MARKGi
SETLAYER RDLG = RDLi AND MARKGi
SETLAYER RDLG_INNER = RDLG TOUCH (HOLES RDLG INNER) == 1
SETLAYER RDLG_OUTER = HOLES RDLG
SETLAYER RDLG_RING = RDLi AND (RDLG INTERACT RDLG_OUTER)

set MG_RING_INNER "RDLG_INNER OR [lindex $metal_all 0]G_INNER"
foreach metal_each [lreplace $metal_all 0 0] {
  set MG_RING_INNER "(${MG_RING_INNER}) OR ${metal_each}G_INNER"
}
SETLAYER MG_RING_INNER = $MG_RING_INNER

SETLAYER MA_ALL_G = M_ALL NOT INSIDE MARKGi

if { [string equal $Guard_ring_CHECK YES] ==1 } {

#//====================
#//  Guard Ring Rules
#//====================

GROUP GGR GR_?

#//Contact, via and TV slots are not permitted for main chip design except guard ring/seal ring applications.
#//(CT/via patterns, with the width/length ratio larger than 3, should be taken as Contact/via slots.)


RULECHECK GR_1_G {
@ Fixed CT slot width in guard ring is 0.09
@ NOTICE: It is a guidelines rule.
  SETLAYER X = INT CTG < 0.089 ABUT<90 SINGULAR REGION
  SETLAYER Y = CTG WITH WIDTH > 0.091
  OUTLAYER (X OR Y) NOT INSIDE EXDRC
}

RULECHECK GR_2_G {
@ Fixed Vn slot width (n=1~7) in guard ring is 0.09
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  OUTLAYER INT ${via}G < 0.089 ABUT<90 SINGULAR REGION
  OUTLAYER (${via}G WITH WIDTH > 0.091) NOT INSIDE EXDRC
}
}

if { ($CHECK_TV1 == 1) || ($CHECK_TV2 == 1) } {
RULECHECK GR_3a_G {
@ TV slot (option a) width in guard ring is >= 0.25 and <= 0.36
@ NOTICE: It is a guidelines rule.
foreach top_via { TV1 TV2 } {
  if { [set CHECK_$top_via] == 1 } {
    OUTLAYER (${top_via}G NOT WITH WIDTH >= 0.25 <= 0.36) NOT INSIDE EXDRC
  }
}
}
}

if { ($CHECK_STV1 == 1) || ($CHECK_STV2 == 1) } {
RULECHECK GR_3b_G {
@ STV slot (option a) width in guard ring is >= 0.19 and <= 0.2
@ NOTICE: It is a guidelines rule.
foreach top_via { STV1 STV2 } {
  if { [set CHECK_$top_via] == 1 } {
    OUTLAYER (${top_via}G NOT WITH WIDTH >= 0.19 <= 0.2) NOT INSIDE EXDRC
  }
}
}
}

RULECHECK GR_4_G {
@ Minimum space between contact slots in guard ring is 1.2
@ NOTICE: It is a guidelines rule.
 OUTLAYER (EXT CTG_SL < 1.2 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK GR_5_G {
@ Minimum space between via slots in guard ring is 1.2
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  OUTLAYER (EXT ${via}G_SL < 1.2 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK GR_6_G {
@ Minimum space between TV slots in guard ring is 1.2
@ NOTICE: It is a guidelines rule.
foreach t_v_list_layer $t_v_j {
  OUTLAYER (EXT ${t_v_list_layer}G_SL < 1.2 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK GR_7_G {
@ Minimum space between square contact and contact slot in guard ring is 0.4
@ NOTICE: It is a guidelines rule.
  OUTLAYER (EXT CTG_SL CTG_SQ < 0.4 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK GR_8_G {
@ Minimum space between square via and via slot in guard ring is 0.4
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  OUTLAYER (EXT ${via}G_SL ${via}G_SQ < 0.4 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK GR_9_G {
@ Minimum space between square TV and TV slot in guard ring is 0.38
@ NOTICE: It is a guidelines rule.
foreach t_v_list_layer $t_v_j {
  OUTLAYER (EXT ${t_v_list_layer}G_SL ${t_v_list_layer}G_SQ < 0.38 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK GR_10_G {
@ Min V1 (both square via and slot patterns) enclosure by M1 in guard ring is 0.09
@ NOTICE: It is a guidelines rule.
  OUTLAYER (ENC V1G M1G < 0.09 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK GR_11_G {
@ Min Vn (both square via and slot patterns) enclosure by Mn in guard ring (n=2~7) is 0.09
@ NOTICE: It is a guidelines rule.
for { set j 2 } { $j <= [lindex $v_j end] } { incr j } {
  OUTLAYER (ENC V${j}G M${j}G < 0.09 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK GR_12_G {
@ Min Vn (both square via and slot patterns) enclosure by Mn+1 in guard ring (n=2~7) is 0.09
@ NOTICE: It is a guidelines rule.
for { set j 2 } { $j <= [lindex $m_j end] } { incr j } {
  set i [expr $j-1]
  OUTLAYER (ENC V${i}G M${j}G < 0.09 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK GR_13_G {
@ Min TV1/TV2 (both square via and slot patterns) enclosure by TM1/TM2 in guard ring is 0.09
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC [lindex $top_v_m_list 0]G [lindex $top_v_m_list 1]G < 0.09 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
if { [llength $top_v_m_list] == 4 } {
  OUTLAYER (ENC [lindex $top_v_m_list 2]G [lindex $top_v_m_list 3]G < 0.09 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK GR_14_G {
@ Min TV1/TV2 (both square via and slot patterns) enclosure by Mn in guard ring (Mn presents metal layer right beneath TV1/TV2) is 0.09
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC [lindex $top_v_m_list 0]G [lindex $m_j_layer end]G < 0.09 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
if { [llength $top_v_m_list] == 4 } {
  OUTLAYER (ENC [lindex $top_v_m_list end-1]G [lindex $top_v_m_list end-2]G < 0.09 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}


RULECHECK GR_16_G {
@ Min Isolation space between active patterns (AA/GT/METAL/RDL) and internal metal ring edge is 1
@ NOTICE: It is a guidelines rule.
OUTLAYER (EXT (AA NOT INSIDE MARKGi) MG_RING_INNER < 1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT (GT NOT INSIDE MARKGi) MG_RING_INNER < 1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT MA_ALL_G MG_RING_INNER < 1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT (RDL NOT INSIDE MARKGi) MG_RING_INNER < 1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK GR_17_G {
@ No dummy patterns (AA/GT/METAL/RDL) are allowed inside isolation areas
@ NOTICE: It is a guidelines rule.
OUTLAYER (AND MARKGi AADUMi) NOT INSIDE EXDRC
OUTLAYER (AND MARKGi GTDUMi) NOT INSIDE EXDRC
OUTLAYER (AND MARKGi MDUM_ALL) NOT INSIDE EXDRC
}

RULECHECK GR_18_G {
@ Min Passivation slot width ('RDL via' is recommended as drawing layer) in guard ring is 2
@ NOTICE: It is a guidelines rule.
OUTLAYER (INT RDLVIAG < 2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK GR_19_G {
@ Min Passivation slot  (RDL via) enclosure by Al pattern (RDL) in guard ring is 1
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC RDLVIAG RDL < 1 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK GR_20_G {
@ Min Passivation slot (RDL via) enclosure by TM2 in guard ring is 0.5
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC RDLVIAG [lindex $top_v_m_list end] < 0.5 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

if { [string equal $Al_Fuse_CHECK YES] ==1 } {
#//==========================
#//   Al Fuse Rules Check
#//==========================

GROUP GALF ALF_?

#//AL fuse element rule (to use RDL as drawing layer)

foreach metal_layer $metal_all {
SETLAYER ${metal_layer}F = $metal_layer AND MARKF
SETLAYER ${metal_layer}F_RING = (${metal_layer}F TOUCH (HOLES ${metal_layer}F)) NOT FUSE
SETLAYER ${metal_layer}F_FUSE = ${metal_layer}F INTERACT FUSE
}

SETLAYER RDLF = RDL AND MARKF
SETLAYER RDLF_RING = (RDLF TOUCH (HOLES RDLF)) NOT FUSE
SETLAYER RDLF_FUSE = RDLF INTERACT FUSE



RULECHECK ALF_1_G {
@ AL fuse element width is 0.88
@ NOTICE: It is a guidelines rule.
OUTLAYER (NOT ENCLOSE RECTANGLE ALFUSE 0.88 4.44) NOT INSIDE EXDRC
}

RULECHECK ALF_2_G {
@ AL fuse element length (metal length between two Vias) is 4.44
@ NOTICE: It is a guidelines rule.
OUTLAYER (ALFUSE NOT WITH EDGE Al_fuse_1 >= 2) NOT INSIDE EXDRC
SETLAYER RDLVIA_1 = RDLVIA INTERACT ALFUSE
SETLAYER X = EXT RDLVIA_1 < 4.44 ABUT<90 SINGULAR REGION OPPOSITE
OUTLAYER ((X INTERACT ALFUSE == 1) NOT TM2) NOT INSIDE EXDRC
}

RULECHECK ALF_3_G {
@ Space between AL fuse elements is 4.44
@ NOTICE: It is a guidelines rule.
OUTLAYER (EXT Alfuse_edge < 4.44 ABUT<90 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT Alfuse_edge_1 < 4.44 ABUT<90 REGION) NOT INSIDE EXDRC
}

RULECHECK ALF_4_G {
@ Space between fuse edge and p-well edge is 8.80
@ NOTICE: It is a guidelines rule.
OUTLAYER (EXT ALFUSE NW < 8.80 ABUT<90 REGION) NOT INSIDE EXDRC
}

RULECHECK ALF_5_G {
@ AL fuse must be connected to GT through stacked via/contact
@ NOTICE: It is a guidelines rule.
SETLAYER GT_FUSE = GT INTERACT Stack_Vn
SETLAYER X = ALFUSE INTERACT GT_FUSE == 2
OUTLAYER (ALFUSE NOT X) NOT INSIDE EXDRC
}

RULECHECK ALF_7_G {
@ No AA/Poly/Metal dummy patterns are allowed in Fuse area covered by MARKF
@ NOTICE: It is a guidelines rule.
OUTLAYER (AADUM AND MARKF) NOT INSIDE EXDRC
OUTLAYER (GTDUM AND MARKF) NOT INSIDE EXDRC
foreach metal_dummy $metal_dummy_list {
  OUTLAYER ($metal_dummy AND MARKF) NOT INSIDE EXDRC
}
}

RULECHECK ALF_8_G {
@ Min Space between metal edge (Mn/TM1/TM2/STM1/STM2 interact with Fuse) and metal ring edge of guard ring is 2.5
@ NOTICE: It is a guidelines rule.
foreach metal_layer $metal_all {
  OUTLAYER (EXT ${metal_layer}F_RING ${metal_layer}F_FUSE < 2.5 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK ALF_9_G {
@ Min Space between Al fuse metal edge and Al ring edge of guard ring is 2.5
@ NOTICE: It is a guidelines rule.
OUTLAYER (EXT RDLF_RING ALFUSE < 2.5 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

#//=======================================================
#// Stack via/CT connection to ALfuse rules
#//=======================================================

GROUP GSV SV_?

RULECHECK SV_1_G {
@ CT enclosure by GT  in fuse window region is 0.145
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC CTFUSE GT < 0.145 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK SV_2_G {
@ CT enclosure by M1 in fuse window region is 0.145
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC CTFUSE M1 < 0.145 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK SV_3_G {
@ Vn enclosure by Mn or Mn+1 for stacked via in fuse window region is 0.145
@ NOTICE: It is a guidelines rule.
foreach j $v_j {
  OUTLAYER (ENC V${j}FUSE M$j < 0.145 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
  OUTLAYER (ENC V${j}FUSE M[expr $j + 1] < 0.145 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}
}

RULECHECK SV_4_G {
@ TV1/TV2(STV1/STV2) enclosure by TM1/TM2(STM1/STM2) for stacked via in fuse window region is 0.10
@ NOTICE: It is a guidelines rule.
if { [llength $t_v_j] > 1} {
  OUTLAYER (ENC [lindex $t_v_j 0]FUSE [lindex $t_m_j 0] < 0.10 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
  OUTLAYER (ENC [lindex $t_v_j end]FUSE [lindex $t_m_j 0] < 0.10 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}
OUTLAYER (ENC [lindex $t_v_j end]FUSE [lindex $t_m_j end] < 0.10 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK SV_5_G {
@ TV1 enclosure by Mn for stack via in fuse window region is 0.10
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC [lindex $t_v_j 0]FUSE M[lindex $m_j end] < 0.10 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK SV_6_G {
@ RDL via enclosure by TM for stack via in fuse window region is 0.60
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC RDLVF [lindex $t_m_j end] < 0.60 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK SV_7_G {
@ RDL via enclosure by RDL for stacked via in fuse window region is 0.60
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC RDLVF RDL < 0.60 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK SV_8_G {
@ Min RDL via width and length in fuse window region is 1.66
@ NOTICE: It is a guidelines rule.
OUTLAYER (INT RDLVF < 1.66 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}



#//==========================
#//Fuse window rules
#//==========================

GROUP GFUSE FUSE_?

RULECHECK Fuse_1_2_G {
@ Fuse window width is 5.50, length is 20.0
@ NOTICE: It is a guidelines rule.
OUTLAYER (NOT ENCLOSE RECTANGLE (FUSE AND MARKF) 5.50 20) NOT INSIDE EXDRC
}

RULECHECK Fuse_3_G {
@ Space between fuse window and protection ring is 1.66
@ NOTICE: It is a guidelines rule.
foreach metal_layer $metal_all {
  OUTLAYER (EXT FUSE G$metal_layer < 1.66 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
OUTLAYER (EXT FUSE GRDL < 1.66 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK Fuse_4_G {
@ Space between fuse edge and fuse window is 3.8
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC Alfuse_edge FUSE < 3.8 ABUT<90 REGION) NOT INSIDE EXDRC
OUTLAYER (ENC Alfuse_edge_1 FUSE < 3.8 ABUT<90 REGION) NOT INSIDE EXDRC
}
}

if { [string equal $LMARK_CHECK YES] ==1 } {
#//============================================================
#//   Guideline for Fuse Repairing Alignment Mark Rule Check 
#//============================================================   

GROUP GMark Mark_?

RULECHECK Mark_1_G {
@ L mark minimum width is 10.0
@ NOTICE: It is a guidelines rule.
OUTLAYER (INT LMARK < 10.0 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK Mark_2_G {
@ L mark maximum width is 20.0
@ NOTICE: It is a guidelines rule.
OUTLAYER (LMARK WITH WIDTH > 20.0) NOT INSIDE EXDRC
}

RULECHECK Mark_4_G {
@ L mark maximum length is 50.0
@ NOTICE: It is a guidelines rule.
OUTLAYER (LENGTH LMARK > 50) NOT INSIDE EDGE EXDRC
}

RULECHECK Mark_5_G {
@ Minimum space between L mark and FUSE window is 10.0
@ NOTICE: It is a guidelines rule.
OUTLAYER (ENC LMARK FUSE < 10.0 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK Mark_6_G {
@ Minimum space between FUSE window and protection ring is 1.5
@ NOTICE: It is a guidelines rule.
OUTLAYER (EXT FUSE Stack_MR < 1.50 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

if { [string equal $LOGO_CHECK YES] ==1 } {
#//=======================================
#//  Logo Design Guidelines
#//=======================================

GROUP GLOGO LOGO_?

RULECHECK LOGO_1_G {
@ Space between LOGO and AA, GT or Metal is >= 10.0um.
OUTLAYER  (EXT LOGO AA < 10 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER  (EXT LOGO GT < 10 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
foreach j [concat $metal_all ] {
OUTLAYER  (EXT LOGO $j < 10 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

RULECHECK LOGO_2_G {
@ LOGO overlap with PA, ALPA, Metal fuse (MARKF) is not allowed
OUTLAYER  (LOGO AND PA) NOT INSIDE EXDRC
OUTLAYER  (LOGO AND ALPA) NOT INSIDE EXDRC
OUTLAYER  (LOGO AND MARKF) NOT INSIDE EXDRC
}
}

if { [string equal $Metal_Slot_CHECK YES] ==1 } {
#//========================================
#//  SLOT - Recommended metal slot rules
#//========================================
GROUP GSL SL_?


RULECHECK SL_1_2_G {
@ Min Slot width is 0.8um
@ Min Slot length is 1.0um
foreach j [concat $metal_all ] {
OUTLAYER (NOT RECTANGLE ${j}SLOT >= 0.8 BY >= 1.0) NOT INSIDE EXDRC
}
#OUTLAYER  INT ${j}SLOT < 0.8 ABUT<90 SINGULAR REGION
}

RULECHECK SL_5_G {
@ Open slot must be fully enclosed by metal line >= 2.0um.
foreach j [concat $metal_all ] {
OUTLAYER  (ENC ${j}SLOT (${j} OR ${j}SLOT) < 2.0 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}
RULECHECK SL_6_CT_G {
@ Min Distance between open slot edge and contact or viasdirectly underneath/above the metal is 0.5um
OUTLAYER (EXT M1SLOT CT < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
RULECHECK SL_6_V1_G {
@ Min Distance between open slot edge and contact or viasdirectly underneath/above the metal is 0.5um
OUTLAYER (EXT M1SLOT V1 < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT M2SLOT V1 < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC

}
set via_list { V2 V3 V4 V5 V6 V7}
foreach via_layer $via_list {
  set tmp CHECK_$via_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
    
  set number [string index $via_layer 1]
  set bottom_metal M$number
  set up_metal M[expr $number +1]
RULECHECK SL_6_${via_layer}_G {
@ Min Distance between open slot edge and contact or viasdirectly underneath/above the metal is 0.5um
OUTLAYER (EXT ${up_metal}SLOT $via_layer  < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT ${bottom_metal}SLOT $via_layer  < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}
}
RULECHECK SL_6_TV_G {
@ Min Distance between open slot edge and contact or viasdirectly underneath/above the metal is 0.5um
#SETLAYER TOPVIA = COPY [lindex $t_v_j 0]
set topvia [lindex $t_v_j 0]
OUTLAYER (EXT ${up_metal}SLOT $topvia < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
if { [string equal $top_metal 1] == 1 } {
set topvia [lindex $t_v_j 0]
set topmetal [lindex $t_m_j 0]
OUTLAYER (EXT ${topmetal}SLOT $topvia < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
if { [string equal $top_metal 2] == 1 } {
set topvia1 [lindex $t_v_j 0]
set topmetal1 [lindex $t_m_j 0]
OUTLAYER (EXT ${topmetal1}SLOT $topvia1 < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
set topvia2 [lindex $t_v_j end]
set topmetal2 [lindex $t_m_j 0]
OUTLAYER (EXT ${topmetal2}SLOT $topvia2 < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
set topvia3 [lindex $t_v_j end]
set topmetal3 [lindex $t_m_j end]
OUTLAYER (EXT ${topmetal3}SLOT $topvia3 < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}


RULECHECK SL_7_G {
@ Slot density of wide metal >= 10% when
@ 1. Metal width > 12um for inter-metal, Metal width > 20um for TM1, Metal width > 30um for TM2/STM2, Metal width > 50um for MTT2. DRC checks the metal main pattern (61:0, 62:0,...), not following (Mn-MnSLOT).
@ 2. The wide metal interacts with metal slot (61:2, 62:2,...).
@ 3. Metal slot (61:2, 62:2,...) size > 10*10 um are not included this rule density calculation.
@ 4. DRC doesn't check metals interact with PA.
@ 5. DRC individually exports result by each metal layer.
foreach j [concat $m_j_layer] {
SETLAYER X1${j} = ((${j}0 NOT INTERACT PA) WITH WIDTH > 12) INTERACT ${j}SLOTi
SETLAYER Y1${j} = (${j}SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z1${j} = DFM PROPERTY X1${j} Y1${j} OVERLAP \[- = AREA(Y1${j})/AREA(X1${j})\] < 0.1
OUTLAYER DFM RDB Z1${j} "density_report_SL_8_${j}.log"
OUTLAYER (DFM COPY Z1${j}) NOT INSIDE EXDRC
}
if { $CHECK_TV1 == 1 } { 
SETLAYER X2 = ((TM10 NOT INTERACT PA) WITH WIDTH > 20) INTERACT TM1SLOTi
SETLAYER Y2 = (TM1SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z2 = DFM PROPERTY X2 Y2 OVERLAP \[- = AREA(Y2)/AREA(X2)\] < 0.1
OUTLAYER DFM RDB Z2 "density_report_SL_8_TM1.log"
OUTLAYER (DFM COPY Z2) NOT INSIDE EXDRC
}
if { $CHECK_STV1 == 1 } {
SETLAYER X3 = ((STM10 NOT INTERACT PA) WITH WIDTH > 20) INTERACT STM1SLOTi
SETLAYER Y3 = (STM1SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z3 = DFM PROPERTY X3 Y3 OVERLAP \[- = AREA(Y3)/AREA(X3)\] < 0.1
OUTLAYER DFM RDB Z3 "density_report_SL_8_STM1.log"
OUTLAYER (DFM COPY Z3) NOT INSIDE EXDRC
}
if { $CHECK_STV2 == 1 } {
SETLAYER X4 = ((STM20 NOT INTERACT PA) WITH WIDTH > 30) INTERACT STM2SLOTi
SETLAYER Y4 = (STM2SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z4 = DFM PROPERTY X4 Y4 OVERLAP \[- = AREA(Y4)/AREA(X4)\] < 0.1
OUTLAYER DFM RDB Z4 "density_report_SL_8_STM2.log"
OUTLAYER (DFM COPY Z4) NOT INSIDE EXDRC
}
if { $CHECK_TV2 == 1 } {
if { [string equal $MTT2_UTV2 0] == 1 } {
SETLAYER X5 = ((TM20 NOT INTERACT PA) WITH WIDTH > 30) INTERACT TM2SLOTi
SETLAYER Y5 = (TM2SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z5 = DFM PROPERTY X5 Y5 OVERLAP \[- = AREA(Y5)/AREA(X5)\] < 0.1
OUTLAYER DFM RDB Z5 "density_report_SL_8_TM2.log"
OUTLAYER (DFM COPY Z5) NOT INSIDE EXDRC
}
if { [string equal $MTT2_UTV2 1] == 1 } {
SETLAYER X5 = ((TM20 NOT INTERACT PA) WITH WIDTH > 50) INTERACT TM2SLOTi
SETLAYER Y5 = (TM2SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z5 = DFM PROPERTY X5 Y5 OVERLAP \[- = AREA(Y5)/AREA(X5)\] < 0.1
OUTLAYER DFM RDB Z5 "density_report_SL_8_TM2.log"
OUTLAYER (DFM COPY Z5) NOT INSIDE EXDRC
}
}
}
}

if { [string equal $DFM_except_Priority1 YES] ==1 } {
RULECHECK DFM_102 {
@ Slot density of wide metals is >=15%       
@ Density check window size: 100um* 100um, step size:50um
foreach j [concat $m_j_layer] {
SETLAYER X1${j} = ((${j}0 NOT INTERACT PA) WITH WIDTH > 12) INTERACT ${j}SLOTi
SETLAYER Y1${j} = (${j}SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z1${j} = DFM PROPERTY X1${j} Y1${j} OVERLAP \[- = AREA(Y1${j})/AREA(X1${j})\] < 0.15
OUTLAYER DFM RDB Z1${j} "density_report_SL_8_${j}.log"
OUTLAYER (DFM COPY Z1${j}) NOT INSIDE EXDRC
}
if { $CHECK_TV1 == 1 } { 
SETLAYER X2 = ((TM10 NOT INTERACT PA) WITH WIDTH > 20) INTERACT TM1SLOTi
SETLAYER Y2 = (TM1SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z2 = DFM PROPERTY X2 Y2 OVERLAP \[- = AREA(Y2)/AREA(X2)\] < 0.15
OUTLAYER DFM RDB Z2 "density_report_SL_8_TM1.log"
OUTLAYER (DFM COPY Z2) NOT INSIDE EXDRC
}
if { $CHECK_STV1 == 1 } {
SETLAYER X3 = ((STM10 NOT INTERACT PA) WITH WIDTH > 20) INTERACT STM1SLOTi
SETLAYER Y3 = (STM1SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z3 = DFM PROPERTY X3 Y3 OVERLAP \[- = AREA(Y3)/AREA(X3)\] < 0.15
OUTLAYER DFM RDB Z3 "density_report_SL_8_STM1.log"
OUTLAYER (DFM COPY Z3) NOT INSIDE EXDRC
}
if { $CHECK_STV2 == 1 } {
SETLAYER X4 = ((STM20 NOT INTERACT PA) WITH WIDTH > 30) INTERACT STM2SLOTi
SETLAYER Y4 = (STM2SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z4 = DFM PROPERTY X4 Y4 OVERLAP \[- = AREA(Y4)/AREA(X4)\] < 0.15
OUTLAYER DFM RDB Z4 "density_report_SL_8_STM2.log"
OUTLAYER (DFM COPY Z4) NOT INSIDE EXDRC
}
if { $CHECK_TV2 == 1 } {
if { [string equal $MTT2_UTV2 0] == 1 } {
SETLAYER X5 = ((TM20 NOT INTERACT PA) WITH WIDTH > 30) INTERACT TM2SLOTi
SETLAYER Y5 = (TM2SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z5 = DFM PROPERTY X5 Y5 OVERLAP \[- = AREA(Y5)/AREA(X5)\] < 0.15
OUTLAYER DFM RDB Z5 "density_report_SL_8_TM2.log"
OUTLAYER (DFM COPY Z5) NOT INSIDE EXDRC
}
if { [string equal $MTT2_UTV2 1] == 1 } {
SETLAYER X5 = ((TM20 NOT INTERACT PA) WITH WIDTH > 50) INTERACT TM2SLOTi
SETLAYER Y5 = (TM2SLOTi WITH WIDTH <=10) NOT INTERACT PA
SETLAYER Z5 = DFM PROPERTY X5 Y5 OVERLAP \[- = AREA(Y5)/AREA(X5)\] < 0.15
OUTLAYER DFM RDB Z5 "density_report_SL_8_TM2.log"
OUTLAYER (DFM COPY Z5) NOT INSIDE EXDRC
}
}
}
}

if { [string equal $Metal_Slot_CHECK YES] ==1 } {
RULECHECK SL_10_G {
@ Metal slot must be rectangle.
foreach j [ concat $metal_all]  {
OUTLAYER  (NOT RECTANGLE ${j}SLOT) NOT INSIDE EXDRC
} 
}
}


#//======================================
#//  Dummy Pattern check DRC
#//======================================

RULECHECK AADUMCK_1_AA_1 {
@ AA.1	Width of interconnect AADUM >= 0.08um
#AA.1
OUTLAYER (INT AADUM < 0.08 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_1_AA_3a {
@ AA.3a	Space between two AADUMs in the same well >= 0.10um
#AA.3a
#OUTLAYER (EXT AADUM < 0.10 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER ((EXT AADUM < 0.10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT AADUM < 0.10 ABUT<44 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT AADUM < 0.10 ABUT>46<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_1_AA_3b {
@ AA.3b	Space between AADUMs when one or both AADUM width greater than 0.15um in the same well >= 0.11	um
#AA.3b
SETLAYER Y = AADUM WITH WIDTH > 0.15
OUTLAYER (EXT Y AADUM < 0.11 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_1_AA_8 {
@ AA.8	AADUM area >= 0.038 um2
#AA.8
OUTLAYER ((AREA AADUM < 0.038) NOT INSIDE INST) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_1_AADUM_19 {
@ AADUM.19 Space between dummy AA2 and NW edge (DUMNW)	>= 0.30	um
#AADUM.19
OUTLAYER (EXT AADUM NW < 0.3 ABUT < 90 REGION) NOT INSIDE EXDRC
OUTLAYER (ENC AADUM NW < 0.3 ABUT < 90 REGION) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_1_AADUM_21 {
@ AADUM.21 Space between dummy AA2 and GTFUSE	>= 3.20	um
#AADUM.21
OUTLAYER (EXT AADUM GTFUSE < 3.2 ABUT < 90 REGION INSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_1_AADUM_26 {
@ AADUM.26 No dummy AA is allowed to straddle on a boundary of NW
#AADUM.26
OUTLAYER (AADUM CUT NW) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_2_AA_3a {
@ Space between AA dummy and AA main patterns can not violate AA.3a and AA.3b.
@ AA.3a	Space between AA and AADUM in the same well >= 0.10um
#AA.3a
#OUTLAYER (EXT AADUM AA < 0.10 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER ((EXT AADUM AA < 0.10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT AADUM AA < 0.10 ABUT<44 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT AADUM AA < 0.10 ABUT>46<90 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_2_AA_3b {
@ Space between AA dummy and AA main patterns can not violate AA.3a and AA.3b.
@ AA.3b	Space between AA and AADUM when one or both AADUM width greater than 0.15um in the same well >= 0.11	um
#AA.3b
SETLAYER C = AA WITH WIDTH > 0.15
SETLAYER Z = AADUM WITH WIDTH > 0.15
OUTLAYER (EXT C AADUM < 0.11 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT Z AA < 0.11 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_3 {
@ GT.4 Space between AADUM and GT on field oxide is >= 0.05um. 
@ DRC waive check the INDMY covered region.
SETLAYER X = EXT AADUM (GT NOT INSIDE (AA OR AADUM)) < 0.05 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDRC
}

RULECHECK AADUMCK_4 {
@ AA dummy patterns cannot touch AA main patterns  
OUTLAYER (AADUM INTERACT AA  ) NOT INSIDE EXDRC                              
}

RULECHECK AADUMCK_5_6 {
@ No AA dummy pattern is allowed to inside RESAA/RESNW/RESP1/VARMOS/MARKG/MARKF/MARKS covered areas.
@ Space between dummy AA and RESAA/RESNW/RESP1/VARMOS/MARKG/MARKF/MARKS layers is 0.4.
OUTLAYER (EXT AADUM RESAA < 0.4 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT AADUM RESNW < 0.4 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT AADUM RESP1 < 0.4 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT AADUM MARKF < 0.4 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT AADUM MARKG < 0.4 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT AADUM MARKS < 0.4 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT AADUM VARMOS < 0.4 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_1_GT_2 {
@ GT.2 	Width of GTDUM >= 0.06um
#GT.2
OUTLAYER (INT GTDUM < 0.06 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_1_GT_3a {
@ GT.3a	Space between two GTs.DRC waive check the INDMY covered region.	>=0.12um
#GT.3a
OUTLAYER ((EXT GTDUM < 0.12 ABUT<90 SINGULAR REGION) NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_1_GT_3b {
@ GT.3b	Space between two GTs when one or both GT width is >= 0.4um,and the run length of two GTs is >= 0.5um. >= 0.16um
#GT.3b
SETLAYER GTDUM_W = WITH WIDTH GTDUM >= 0.4
SETLAYER GTDUM_S = EXT GTDUM_W GTDUM < 0.16 OPPOSITE REGION PARA ONLY
SETLAYER GTDUM_LS = LENGTH GTDUM_S >= 0.5
OUTLAYER (GTDUM_S WITH EDGE GTDUM_LS) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_1_PODUM_21 {
@ PODUM.21 Minimum space between dummy poly2 and GTFUSE is 3.24um. 
#PODUM.21
OUTLAYER (EXT GTDUM GTFUSE < 3.24 ABUT<90 SINGULAR REGION INSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_1_PODUM_24 {
@ PODUM.24 No dummy poly pattern is allowed to exist above AA circuit pattern (not including dummy AA).
#PODUM.24
OUTLAYER (GTDUM AND AA) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_1_PODUM_25 {
@ PODUM.25 Poly dummy is either adding overlap with AA dummy or on STI			
#PODUM.25
OUTLAYER ((GTDUM INTERACT AADUM) NOT AADUM) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_2_GT_3a {
@ Space between GTDUM and GT is 0.12.(GT.3a)
#GT.3a
OUTLAYER ((EXT GTDUM GT < 0.12 ABUT<90 SINGULAR REGION) NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_2_GT_3b {
@ Space between two parallel GTDUM and GT (parallel area length is >=0.5um)with one or both line parallel area width is >= 0.4, min. space is 0.16(GT.3b) 
#GT.3b
SETLAYER GT_W = WITH WIDTH GT >= 0.4
SETLAYER GT_S = EXT GT_W GTDUM < 0.16 OPPOSITE REGION PARA ONLY
SETLAYER GT_LS = LENGTH GT_S >= 0.5
OUTLAYER ((GT_S WITH EDGE GT_LS) NOT INSIDE INST) NOT INSIDE EXDRC
SETLAYER GTDUM_W = WITH WIDTH GTDUM >= 0.4
SETLAYER GTDUM_S = EXT GTDUM_W GT < 0.16 OPPOSITE REGION PARA ONLY
SETLAYER GTDUM_LS = LENGTH GTDUM_S >= 0.5
OUTLAYER (GTDUM_S WITH EDGE GTDUM_LS) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_3 {
@ GT.4	Space between AA and GTDUM on field oxide.
@ DRC waive check the INDMY covered region.>=0.05	um
SETLAYER X = EXT AA GTDUM < 0.05 ABUT<90 SINGULAR REGION INSIDE ALSO
OUTLAYER ((X NOT INSIDE (AA OR AADUM)) NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDRC
}

RULECHECK GTDUMCK_4 {
@ GT dummy patterns cannot touch GT main patterns  
OUTLAYER (GTDUM INTERACT GT  ) NOT INSIDE EXDRC                              
}

RULECHECK GTDUMCK_5_6 {
@ No dummy pattern is allowed to inside RESAA/RESNW/RESP1/MARKF/MARKG/MARKS/VARMOS covered areas.
@ Space between dummy poly2 and RESAA/RESNW/RESP1/MARKF/MARKG/MARKS/VARMOS layers is 0.44.
OUTLAYER (EXT GTDUM RESAA < 0.44 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT GTDUM RESNW < 0.44 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT GTDUM RESP1 < 0.44 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT GTDUM MARKF < 0.44 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT GTDUM MARKG < 0.44 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT GTDUM MARKS < 0.44 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
OUTLAYER (EXT GTDUM VARMOS < 0.44 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_1_2_Mn_1 {
@ M1DUM width is 0.09(M1.1)
#M1.1
OUTLAYER (INT M1DUM < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_1_2_Mn_2a {
@ Space between two M1DUM is 0.09(M1.2a),DRC waive check 89 to 90 degree spaces in the INDMY region.
#M1.2a
OUTLAYER (((EXT M1DUM < 0.09 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER (((EXT M1 M1DUM < 0.09 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER (((EXT M1DUM < 0.09 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER (((EXT M1 M1DUM < 0.09 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_1_2_Mn_2b {
@ Space between two (M1DUM or M1) having run length >=2um with one or both M1DUM width orlength >=1um is 0.16(M1.2b)
#M1.2b
Mn_2b_DUM M1ALL M1DUM 2 1 0.16
}

RULECHECK MnDUMCK_1_2_Mn_3 {
@ Max M1DUM line width allowed is 12(M1.3)
#M1.3
OUTLAYER (M1DUM WITH WIDTH > 12) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_1_2_Mn_4 {
@ M1DUM area is 0.027(M1.4)
#M1.4
OUTLAYER ((AREA M1DUM < 0.027) NOT INSIDE INST) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_1_2_Mn_5 {
@ Dielectric area enclosure by M1DUM is 0.13.(M1.5)
#M1.5
SETLAYER X = (HOLES M1DUM INNER) NOT M1DUM 
OUTLAYER (AREA X < 0.13) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_1_2_Mn_2c {
@ Space between two (M1DUM or M1) having run length >=2um with one or both M1DUM width orlength >=5um is 0.50(M1.2c)
Mn_2c_DUM M1ALL M1DUM 2 5 0.5
}


foreach m_dummy [lreplace $m_j_layer 0 0] {
RULECHECK MnDUMCK_3_4_Mn_1_$m_dummy {
@ MnDUM (n=2~8) width is 0.10(Mn.1)
#Mn.1
OUTLAYER (INT ${m_dummy}DUM < 0.10 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_3_4_Mn_2a_$m_dummy {
@ Space between two MnDUM (n=2~8) is 0.10(Mn.2a),DRC waive check 89 to 90 degree spaces in the INDMY region.
#Mn.2a-----------------------------------------------------
if { [string equal $m_dummy M2] == 1 } {
OUTLAYER (((EXT ${m_dummy}DUM < 0.10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER (((EXT ${m_dummy}DUM $m_dummy < 0.10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER (((EXT ${m_dummy}DUM < 0.10 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
OUTLAYER (((EXT ${m_dummy}DUM $m_dummy < 0.10 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE INST) NOT INSIDE EXDRC
}
if { [string equal $m_dummy M2] == 0 } {
OUTLAYER ((EXT ${m_dummy}DUM < 0.10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT ${m_dummy}DUM $m_dummy < 0.10 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT ${m_dummy}DUM < 0.10 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT ${m_dummy}DUM $m_dummy < 0.10 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}
}

RULECHECK MnDUMCK_3_4_Mn_2b_$m_dummy {
@ Space between two (MnDUM (n=2~8) or Mni) having run length >=2um with one or both MnDUM width orlength >=1um is 0.16(Mn.2b)
#Mn.2b-------------------------------------------------------
Mn_2b_DUM ${m_dummy}ALL ${m_dummy}DUM 2 1 0.16
}

RULECHECK MnDUMCK_3_4_Mn_3_$m_dummy {
@ Max MnDUM (n=2~8) line width allowed is 12(Mn.3)
#Mn.3----------------------------------------------------
OUTLAYER (${m_dummy}DUM WITH WIDTH > 12) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_3_4_Mn_4_$m_dummy {
@ MnDUM (n=2~8) area is 0.035(Mn.4)
#Mn.4--------------------------------------------------------------
if { [string equal $m_dummy M2] == 1 } {
  OUTLAYER ((AREA ${m_dummy}DUM < 0.035) NOT INSIDE INST) NOT INSIDE EXDRC
}
if { [string equal $m_dummy M2] == 0 } {
  OUTLAYER (AREA ${m_dummy}DUM < 0.035) NOT INSIDE EXDRC
}
}

RULECHECK MnDUMCK_3_4_Mn_5_$m_dummy {
@ Dielectric area enclosure by MnDUM (n=2~8) is 0.12.(Mn.5)
#Mn.5-------------------------------------------
SETLAYER A = (HOLES ${m_dummy}DUM INNER) NOT ${m_dummy}DUM 
  OUTLAYER (AREA A < 0.12) NOT INSIDE EXDRC
}

RULECHECK MnDUMCK_3_4_Mn_2c_$m_dummy {
@ Space between two (MnDUM (n=2~8) or Mni) having run length >=2um with one or both MnDUM width orlength >=5um is 0.50(Mn.2c)
Mn_2c_DUM ${m_dummy}ALL ${m_dummy}DUM 2 5 0.5
}
}

RULECHECK MnDUMCK_5 {
@ MnDUM (n=1~8) metal can not be interacted with Mn metal design patterns.
OUTLAYER (M1DUM INTERACT M1) NOT INSIDE EXDRC
OUTLAYER (M2DUM INTERACT M2) NOT INSIDE EXDRC
OUTLAYER (M3DUM INTERACT M3) NOT INSIDE EXDRC
if { [expr $total_metal - $top_metal ] >= 4 } {
OUTLAYER (M4DUM INTERACT M4) NOT INSIDE EXDRC

if { [expr $total_metal - $top_metal ] >= 5 } {
OUTLAYER (M5DUM INTERACT M5) NOT INSIDE EXDRC

if { [expr $total_metal - $top_metal ] >= 6 } {
OUTLAYER (M6DUM INTERACT M6) NOT INSIDE EXDRC

if { [expr $total_metal - $top_metal ] >= 7 } {
OUTLAYER (M7DUM INTERACT M7) NOT INSIDE EXDRC

if { [expr $total_metal - $top_metal ] >= 8 } {
OUTLAYER (M8DUM INTERACT M8) NOT INSIDE EXDRC
}
}
}
}
}
}

RULECHECK MnDUMCK_6 {
@ MnDUM (n=1~8) patterns are not allowed inside MARKF, MARKG and MARKS covered areas.
OUTLAYER (M1DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
OUTLAYER (M2DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
OUTLAYER (M3DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
if { [expr $total_metal - $top_metal ] >= 4 } {
OUTLAYER (M4DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC

if { [expr $total_metal - $top_metal ] >= 5 } {
OUTLAYER (M5DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC 

if { [expr $total_metal - $top_metal ] >= 6 } { 
OUTLAYER (M6DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC

if { [expr $total_metal - $top_metal ] >= 7 } {
OUTLAYER (M7DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC

if { [expr $total_metal - $top_metal ] >= 8 } {
OUTLAYER (M8DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
}
}
}
}
}
}

if { ($STM1_STV1 == 0) && ($STM2_STV2 == 0) && ($top_metal == 2) } {
RULECHECK TM1DUMCK_1_2_TM1_1 {
@ TM1DUM width is 0.40(TM1.1)
#TM1.1
OUTLAYER (INT TM1DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK TM1DUMCK_1_2_TM1_2a {
@ Space between two TM1s or TM1DUMs  is 0.40.(TM1.2a),DRC waive check 89 to 90 degree spaces in the INDMY region.
#TM1.2a
OUTLAYER ((EXT TM1DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM1 TM1DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM1DUM < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM1 TM1DUM < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK TM1DUMCK_1_2_TM1_2b {
@ Space between two TM1s or TM1DUMs having parallel segment >=2um with one or both width >=2um is 0.50um (TM1.2b)
#TM1.2b
Mn_2b_DUM TM1ALL TM1DUM 2 2 0.5
}

RULECHECK TM1DUMCK_1_2_TM1_3 {
@ TM1DUM area is 0.40.(TM1.3) 
#TM1.3
OUTLAYER (AREA TM1DUM < 0.40) NOT INSIDE EXDRC
}

RULECHECK TM1DUMCK_1_2_TM1_4 {
@ Dielectric area enclosed by TM1DUM is 0.6 (TM1.4)
#TM1.4
SETLAYER X = (HOLES TM1DUM INNER) NOT TM1DUM 
OUTLAYER (AREA X < 0.6) NOT INSIDE EXDRC
}

RULECHECK TM1DUMCK_1_2_TM1_5 {
@ TM1 width (Top metal bond pad application can be waived.)<= 20.0um (TM1.5)
#TM1.5
OUTLAYER (((TM1DUM WITH WIDTH > 20) NOT INTERACT PA) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK TM1DUMCK_3 {
@ TM1DUM  metal can not be interacted with TM1 metal design patterns.
OUTLAYER (TM1DUM INTERACT TM1) NOT INSIDE EXDRC
}

RULECHECK TM1DUMCK_4 {
@ TM1DUM  patterns are not allowed inside MARKF, MARKG and MARKS covered areas.
OUTLAYER (TM1DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
}
}

if { $STM1_STV1 == 1 } {
RULECHECK STM1DUMCK_1_2_STM1_1 {
@ STM1DM width is 0.20 (STM1.1)
#STM1.1------------------------------------------
OUTLAYER (INT STM1DM < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK STM1DUMCK_1_2_STM1_2a {
@ Space between two STM1DMs or STM1 is 0.20 (STM1.2a),DRC waive check 89 to 90 degree spaces in the INDMY region.
#STM1.2a------------------------------------------
OUTLAYER ((EXT STM1DM < 0.20 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT STM1DM STM1 < 0.20 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT STM1DM < 0.20 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT STM1DM STM1 < 0.20 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK STM1DUMCK_1_2_STM1_2b {
@ Space between two STM1s having parallel segment >=0.4um with one or both width >=0.4um is 0.25um (STM1.2b)
#STM1.2b--------------------------------------------
Mn_2b_DUM STM1ALL STM1DM 0.4 0.4 0.25 
}

RULECHECK STM1DUMCK_1_2_STM1_3 {
@ STM1DM area is 0.12(STM1.3)
#STM1.3-------------------------
OUTLAYER (AREA STM1DM < 0.12) NOT INSIDE EXDRC
}

RULECHECK STM1DUMCK_1_2_STM1_4 {
@ Dielectric area enclosed by STM1DM is 0.26 (STM1.4)
#STM1.4----------------------------------------
SETLAYER X = (HOLES STM1DM INNER) NOT STM1DM 
OUTLAYER (AREA X < 0.26) NOT INSIDE EXDRC
}

RULECHECK STM1DUMCK_1_2_STM1_5 {
@ STM1DM Max. width allowed is 20 (STM1.5)
#STM1.5----------------------------
OUTLAYER ((STM1DM WITH WIDTH > 20.00) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK STM1DUMCK_1_2_STM1_7 {
@ Space between STM1DM metal line with one or both are 45 degree bent metal line is 0.22 (STM1.7)
#STM1.7----------------------------------
SETLAYER Z = ANGLE STM1DM == 45
OUTLAYER (EXT Z STM1DM < 0.22 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT Z STM1DM < 0.22 CORNER TO EDGE REGION) NOT INSIDE EXDRC
SETLAYER A = ANGLE STM1DM == 45
OUTLAYER (EXT A STM1 < 0.22 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT A STM1 < 0.22 CORNER TO EDGE REGION) NOT INSIDE EXDRC
SETLAYER B = ANGLE STM1 == 45
OUTLAYER (EXT B STM1DM < 0.22 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT B STM1DM < 0.22 CORNER TO EDGE REGION) NOT INSIDE EXDRC
}

RULECHECK STM1DUMCK_1_2_STM1_2c {
@ Space between two STM1s having parallel segment >=2um with one or both width >=2um is 0.40um (STM1.2c)
Mn_2b_DUM STM1ALL STM1DM 2 2 0.4
}
RULECHECK STM1DUMCK_1_2_STM1_2d {
@ Space between two STM1s having parallel segment >=2um with one or both width >=10um is 0.50um (STM1.2d)
Mn_2c_DUM STM1ALL STM1DM 2 10 0.5
}


RULECHECK STM1DUMCK_3 {
@ STM1DM  metal can not be interacted with STM1 metal design patterns.
OUTLAYER (STM1DM INTERACT STM1) NOT INSIDE EXDRC
}

RULECHECK STM1DUMCK_4 {
@ STM1DM  patterns are not allowed inside MARKF, MARKG and MARKS covered areas.
OUTLAYER (STM1DM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
}
}

if { ($STM1_STV1 == 0) && ($STM2_STV2 == 0) } {
if { $MTT2_UTV2 == 0 } {
RULECHECK TM2DUMCK_1_2_TM2_1 {
@ TM2DUM  width is 0.40 (TM2.1)
#TM2.1-------------------------------
OUTLAYER ((INT TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((INT TM2DUM < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_TM2_2a {
@ Space between two TM2DUMs or TM2s is 0.40 (TM2.2a)
#TM2.2a-------------------------------
#OUTLAYER (EXT TM2 TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#OUTLAYER (EXT TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2 TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2 TM2DUM < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2DUM < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_TM2_2b {
@ Space between two TM2s having parallel segment >=2um with one or both width >=2um is 0.50um (TM2.2b)
#TM2.2b---------------------------
Mn_2b_DUM TM2ALL TM2DUM 2 2 0.5
}

RULECHECK TM2DUMCK_1_2_TM2_3 {
@ TM2DUM area is 0.40 (TM2.3)
#TM2.3--------------------------------------------
OUTLAYER (AREA TM2DUM < 0.40) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_TM2_4 {
@ Dielectric area enclosed by TM2DUM  is 0.6 (TM2.4)
#TM2.4-------------------------------------
OUTLAYER (area ((HOLES TM2DUM INNER) NOT TM2DUM) < 0.6) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_TM2_5 {
@ Max TM2DUM width allowed is 30,Top metal bondpads can be waived.(TM2.5)
#TM2.5-------------------------------------
SETLAYER Y = TM2DUM WITH WIDTH > 30.00
OUTLAYER ((Y NOT INTERACT PA) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_3 {
@ TM2DUM  metal can not be interacted with TM2 metal design patterns.
OUTLAYER (TM2DUM INTERACT TM2) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_4 {
@ TM2DUM  patterns are not allowed inside MARKF, MARKG and MARKS covered areas.
OUTLAYER (TM2DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
}
}
}


if { ($STM1_STV1 == 1) && ($STM2_STV2 == 0) && ($top_metal == 2) } {
if { $MTT2_UTV2 == 0 } { 
RULECHECK TM2DUMCK_1_2_TM2_1 {
@ TM2DUM  width is 0.40 (TM2.1)
#TM2.1-------------------------------
OUTLAYER ((INT TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY)NOT INSIDE EXDRC
OUTLAYER ((INT TM2DUM < 0.40 ABUT<89 SINGULAR REGION) AND INDMY)NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_TM2_2a {
@ Space between two TM2DUMs or TM2s is 0.40 (TM2.2a)
#TM2.2a-------------------------------
#OUTLAYER (EXT TM2 TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#OUTLAYER (EXT TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2 TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2 TM2DUM < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2DUM < 0.40 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2DUM < 0.40 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_TM2_2b {
@ Space between two TM2s having parallel segment >=2um with one or both width >=2um is 0.50um (TM2.2b)
#TM2.2b---------------------------
Mn_2b_DUM TM2ALL TM2DUM 2 2 0.5
}

RULECHECK TM2DUMCK_1_2_TM2_3 {
@ TM2DUM area is 0.40 (TM2.3)
#TM2.3--------------------------------------------
OUTLAYER (AREA TM2DUM < 0.40) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_TM2_4 {
@ Dielectric area enclosed by TM2DUM  is 0.6 (TM2.4)
#TM2.4-------------------------------------
OUTLAYER (area ((HOLES TM2DUM INNER) NOT TM2DUM) < 0.6) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_TM2_5 {
@ Max TM2DUM width allowed is 30,Top metal bondpads can be waived.(TM2.5)
#TM2.5-------------------------------------
SETLAYER Y = TM2DUM WITH WIDTH > 30.00
OUTLAYER ((Y NOT INTERACT PA) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_3 {
@ TM2DUM  metal can not be interacted with TM2 metal design patterns.
OUTLAYER (TM2DUM INTERACT TM2) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_4 {
@ TM2DUM  patterns are not allowed inside MARKF, MARKG and MARKS covered areas.
OUTLAYER (TM2DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
}
}
}

if { $MTT2_UTV2 == 1 } {
RULECHECK TM2DUMCK_1_2_MTT2_1 {
@ TM2DUM width  is 1.50 (MTT2.1)
#MTT2.1------------------------------------------
OUTLAYER ((INT TM2DUM < 1.50 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((INT TM2DUM < 1.50 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_MTT2_2a {
@ Min space between TM2DUM is 1.50 (MTT2.2a)
#MTT2.2a--------------------------------------------
#OUTLAYER (EXT TM2 TM2DUM < 1.50 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#OUTLAYER (EXT TM2DUM < 1.50 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2 TM2DUM < 1.50 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2 TM2DUM < 1.50 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2DUM < 1.50 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT TM2DUM < 1.50 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_MTT2_2b {
@ Space between two TM2s or TM2DUMs having parallel segment larger than 2um with one or both width >=16um is 2.0 (MTT2.2b)
#MTT2.2b----------------------------
Mn_2c_DUM TM2ALL TM2DUM 2.001 16 2
}

RULECHECK TM2DUMCK_1_2_MTT2_5 {
@ Space between an inductor TM2DUM and other TM2DUM is 30 (MTT2.5)
#MTT2.5----------------------------------------------------
OUTLAYER (EXT (TM2DUM AND INDMY) (TM2DUM NOT INDMY) < 30 OPPOSITE REGION) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_MTT2_6 {
@ Min Metal area TM2DUM is 6.00 (MTT2.6)
@ DRC checking allows 0.0004um2 tolerance in INDMY region.
#MTT2.6-----------------------------------------
SETLAYER TM2DUM_1 = TM2DUM NOT INTERACT INDMY
SETLAYER TM2DUM_2 = TM2DUM INTERACT INDMY
OUTLAYER (AREA TM2DUM_1 < 6.00) NOT INSIDE EXDRC
OUTLAYER (AREA TM2DUM_2 < 6.00 - 0.0004 ) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_1_2_MTT2_7 {
@ Dielectric area enclosed by TM2DUM is 6.0 (MTT2.7)
@ DRC checking allows 0.0004um2 tolerance in INDMY region.
#MTT2.7-------------------------------------
  SETLAYER X = (HOLES TM2DUM INNER) NOT TM2DUM
  SETLAYER X1 = X NOT INTERACT INDMY
  SETLAYER X2 = X INTERACT INDMY
  OUTLAYER (AREA X1 < 6.0) NOT INSIDE EXDRC
  OUTLAYER (AREA X2 < 6.0- 0.0004) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_3 {
@ TM2DUM  metal can not be interacted with TM2 metal design patterns.
OUTLAYER (TM2DUM INTERACT TM2) NOT INSIDE EXDRC
}

RULECHECK TM2DUMCK_4 {
@ TM2DUM  patterns are not allowed inside MARKF, MARKG and MARKS covered areas.
OUTLAYER (TM2DUM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
}
}

if { $STM2_STV2 == 1 } {
RULECHECK STM2DUMCK_1_2_STM2_1 {
@ STM2DM width is 0.20 (STM2.1)
#STM2.1-------------------------------------
OUTLAYER ((INT STM2DM < 0.20 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((INT STM2DM < 0.20 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK STM2DUMCK_1_2_STM2_2a {
@ Space between two STM2s or STM2DM is 0.20 (STM2.2a)
#STM2.2a----------------------------------------------
#OUTLAYER (EXT STM2 STM2DM < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
#OUTLAYER (EXT STM2DM < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER ((EXT STM2 STM2DM < 0.20 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT STM2 STM2DM < 0.20 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT STM2DM < 0.20 ABUT<90 SINGULAR REGION) NOT INDMY) NOT INSIDE EXDRC
OUTLAYER ((EXT STM2DM < 0.20 ABUT<89 SINGULAR REGION) AND INDMY) NOT INSIDE EXDRC
}

RULECHECK STM2DUMCK_1_2_STM2_2b {
@ Space between two STM2s or STM2DM having parallel segment >=0.4um with one or both width >=0.4um is 0.25um (STM2.2b)
#STM2.2b--------------------------------
Mn_2b_DUM STM2ALL STM2DM 0.4 0.4 0.25
}

RULECHECK STM2DUMCK_1_2_STM2_3 {
@ STM2DM area is 0.12 (STM2.3)
#STM2.3-------------------------------------------
OUTLAYER (AREA STM2DM < 0.12) NOT INSIDE EXDRC
}

RULECHECK STM2DUMCK_1_2_STM2_4 {
@ Dielectric area enclosed by STM2DM is 0.26 (STM2.4)
#STM2.4-------------------------------
SETLAYER X = (HOLES STM2DM INNER) NOT STM2DM
OUTLAYER (AREA X < 0.26) NOT INSIDE EXDRC
}

RULECHECK STM2DUMCK_1_2_STM2_5 {
@ STM2DM Max. width allowed is 30. Top metal bondpads can be waived(STM2.5)
#STM2.5-----------------------------------
SETLAYER Y = STM2DM WITH WIDTH > 30.00
OUTLAYER ((Y NOT INTERACT PA) NOT INDMY) NOT INSIDE EXDRC
}

RULECHECK STM2DUMCK_1_2_STM2_6 {
@ Space between STM2DM metal line with one or both are 45 degree bent metal line is 0.22 (STM2.6)
#STM2.6------------------------------------------------
SETLAYER Z = ANGLE STM2DM == 45
OUTLAYER (EXT Z STM2DM < 0.22 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT Z STM2DM < 0.22 CORNER TO EDGE REGION) NOT INSIDE EXDRC
SETLAYER A = ANGLE STM2DM == 45
OUTLAYER (EXT A STM2 < 0.22 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT A STM2 < 0.22 CORNER TO EDGE REGION) NOT INSIDE EXDRC
SETLAYER B = ANGLE STM2 == 45
OUTLAYER (EXT B STM2DM < 0.22 REGION) NOT INSIDE EXDRC
OUTLAYER (EXT B STM2DM < 0.22 CORNER TO EDGE REGION) NOT INSIDE EXDRC
}

RULECHECK STM2DUMCK_1_2_STM2_2c {
@ Space between two STM2s or STM2DM having parallel segment >=2um with one or both width >=2um is 0.40um (STM2.2c)
Mn_2b_DUM STM2ALL STM2DM 2 2 0.4
}
RULECHECK STM2DUMCK_1_2_STM2_2d {
@ Space between two STM2s or STM2DM having parallel segment >=2um with one or both width >=10um is 0.50um (STM2.2d)
Mn_2c_DUM STM2ALL STM2DM 2 10 0.5
}

RULECHECK STM2DUMCK_3 {
@ STM2DM  metal can not be interacted with STM2 metal design patterns.
OUTLAYER (STM2DM INTERACT STM2) NOT INSIDE EXDRC
}

RULECHECK STM2DUMCK_4 {
@ STM2DM  patterns are not allowed inside MARKF, MARKG and MARKS covered areas.
OUTLAYER (STM2DM AND ((MARKF OR MARKG) OR MARKS)) NOT INSIDE EXDRC
}
}

if { [string equal $ESD_CHECK YES] == 1 } {

#//==================================
#// ESD design and layout guideline
#//==================================


SETLAYER ESD = ESD1 AND ESDIO2

SETLAYER ENACT = NACT AND ESDIO2
SETLAYER EPACT = PACT AND ESDIO2
SETLAYER ENTAP = ENACT AND NW
SETLAYER EPTAP = EPACT NOT NW

SETLAYER EGATE = (AA AND GT) AND ESDIO2
SETLAYER ENGATE = EGATE AND ENACT
SETLAYER EPGATE = EGATE AND EPACT
SETLAYER EGATEHV = (EGATE NOT DG) AND TG                 //2.5V or 3.3V
SETLAYER EGATEMV = (EGATE AND DG) NOT TG                 //1.8V
SETLAYER EGATELV = EGATE NOT DG                          //1.2V
SETLAYER EGATE_CASCODED = (EGATE AND ESDIO2) AND ESD5V   //high voltage tolerant I/O using Cascoded 2.5V/3.3V NMOS

SETLAYER EGATE_CASCODED_OVLAP = EGATE_CASCODED CUT ESAB
SETLAYER EGATE_CASCODED_INSID = EGATE_CASCODED INSIDE ESAB

SETLAYER EGATE_W = EGATE COIN EDGE GT
SETLAYER EGATE_L = EGATE COIN EDGE AA

SETLAYER EGATE_POLY = GT ENCLOSE EGATE
SETLAYER ENGATE_POLY = GT ENCLOSE ENGATE
SETLAYER EPGATE_POLY = GT ENCLOSE EPGATE

SETLAYER ECT = CT AND ESDIO2
SETLAYER ESAB = SAB AND ESDIO2
SETLAYER ESAB_HO = HOLES ESAB INNER EMPTY
SETLAYER ECT_S = ECT OUTSIDE ESAB_HO
SETLAYER ECT_D = ECT INSIDE ESAB_HO

SETLAYER ENMOS = ENACT ENCLOSE EGATE
SETLAYER EPMOS = EPACT ENCLOSE EGATE
SETLAYER ENMOS_SD = ENMOS NOT EGATE
SETLAYER EPMOS_SD = EPMOS NOT EGATE

SETLAYER ENMOS_S = ENMOS_SD ENCLOSE ECT_S
SETLAYER ENMOS_D = ENMOS_SD ENCLOSE ECT_D
SETLAYER EPMOS_S = EPMOS_SD ENCLOSE ECT_S
SETLAYER EPMOS_D = EPMOS_SD ENCLOSE ECT_D
SETLAYER EMOS_D = ENMOS_D OR EPMOS_D
SETLAYER EMOS_S = ENMOS_S OR EPMOS_S


SETLAYER ENGUARDRING = HOLES ENTAP INNER EMPTY
SETLAYER EPGUARDRING = HOLES EPTAP INNER EMPTY
SETLAYER ENGUARDHOLE_2 = (HOLES ENTAP INNER) ENCLOSE EPGUARDRING
SETLAYER EPGUARDHOLE_2 = (HOLES EPTAP INNER) ENCLOSE ENGUARDRING

SETLAYER NESDCLP_NOSAB = (NACT AND ESDIO2) NOT INTERACT SAB
SETLAYER NESDCLP_SAB = (NACT AND ESDIO2) INTERACT SAB
SETLAYER PESDCLP_NOSAB = (PACT AND ESDIO2) NOT INTERACT SAB
SETLAYER PESDCLP_SAB = (PACT AND ESDIO2) INTERACT SAB

SETLAYER ENGATE_NOSAB = GATE AND NESDCLP_NOSAB
SETLAYER ENGATE_SAB = GATE AND NESDCLP_SAB
SETLAYER EPGATE_NOSAB = GATE AND PESDCLP_NOSAB
SETLAYER EPGATE_SAB = GATE AND PESDCLP_SAB
SETLAYER EGATE_NOSAB = ENGATE_NOSAB OR EPGATE_NOSAB
SETLAYER EGATE_SAB = ENGATE_SAB OR EPGATE_SAB

SETLAYER ESD3C_1 = EXPAND EDGE ((EGATE NOT EGATE_CASCODED) INSIDE EDGE AA) INSIDE BY 0.001
SETLAYER ESD3C_2 = EXPAND EDGE ((EGATE_CASCODED NOT INSIDE SAB) INSIDE EDGE AA) INSIDE BY 0.001
SETLAYER ESD3C = ESD3C_1 OR ESD3C_2

LAYER MAP 998 DATATYPE 1234 5432
LAYER EMPTY1 5432
SETLAYER ENGATE_D_EMPTY = EMPTY1 OR (ESDIO2 AND ENMOS_D)
SETLAYER EPGATE_D_EMPTY = EMPTY1 OR (ESDIO2 AND EPMOS_D)
SETLAYER ESD3C_EMPTY    = EMPTY1 OR ESD3C
SETLAYER ECT_EMPTY      = EMPTY1 OR ECT

#CONNECT EGATE_POLY_EMPTY ESD3C_EMPTY
#CONNECT EGATE_POLY_EMPTY EM1_EMPTY BY ECT_EMPTY
CONNECT ENGATE_D_EMPTY ESD3C_EMPTY
CONNECT EPGATE_D_EMPTY ESD3C_EMPTY
CONNECT ENGATE_D_EMPTY EM1i_EMPTY BY ECT_EMPTY
CONNECT EPGATE_D_EMPTY EM1i_EMPTY BY ECT_EMPTY 

#Below connection is only for ESD_3_G; Both poly connected by GT and M1 are considered as "Finger"
foreach metal_via $v_m_list_for_connect {
  SETLAYER E${metal_via}_EMPTY = EMPTY1 OR $metal_via
}

for { set i 0 } { $i < [expr [llength $v_m_list_for_connect] -2] } { incr i 2 } {
  CONNECT E[lindex $v_m_list_for_connect $i]_EMPTY E[lindex $v_m_list_for_connect [expr $i +2]]_EMPTY BY E[lindex $v_m_list_for_connect [expr $i +1]]_EMPTY
}

SETLAYER EPA_EMPTY     = EMPTY1 OR PAi
SETLAYER ERDL_EMPTY    = EMPTY1 OR RDLi
SETLAYER ERDLVIA_EMPTY = EMPTY1 OR RDLVIAi
SETLAYER EALPA_EMPTY   = EMPTY1 OR ALPAi
SETLAYER EMD_EMPTY     = EMPTY1 OR MDi
SETLAYER ERDLPA2_EMPTY = EMPTY1 OR RDLPA2i
if { [string equal $STM2_STV2 0] == 1 } {
CONNECT ETM2i_EMPTY EPA_EMPTY
CONNECT ETM2i_EMPTY ERDL_EMPTY BY ERDLVIA_EMPTY
}
if { [string equal $STM2_STV2 1] == 1 } {
CONNECT ESTM2i_EMPTY EPA_EMPTY
CONNECT ESTM2i_EMPTY ERDL_EMPTY BY ERDLVIA_EMPTY
}
CONNECT ERDL_EMPTY ERDLPA2_EMPTY
CONNECT EPA_EMPTY EALPA_EMPTY
CONNECT ERDL_EMPTY EALPA_EMPTY
CONNECT EALPA_EMPTY EMD_EMPTY





RULECHECK ESD_2_G {
@ Unit finger width (F) of NMOS and PMOS for ESD protection device (Fig.2). >= 15 and <= 45
 OUTLAYER (LENGTH EGATE_W < 15) NOT INSIDE EDGE EXDRC
 OUTLAYER (LENGTH EGATE_W > 45) NOT INSIDE EDGE EXDRC
}

#RULECHECK ESD_3_G {
#@ ESD.3G is defined for total channel width of ESD N/PMOS. The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity can be formed by all metal, via, ALPA, PA and MD but not broken by resistors. SAB is used for drain recognition in DRC runset.
#@ Channel width (W) of NMOS and PMOS for ESD protection device (Channel width=Finger width x Finger No.) >= 360
#   OUTLAYER (NET AREA RATIO EGATE_POLY_EMPTY ESD3C_EMPTY \[AREA(ESD3C_EMPTY)/0.002\] < 360) NOT INSIDE EXDRC
#}

RULECHECK ESD_3a_G {
@ ESD.3G is defined for total channel width of ESD N/PMOS. The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity can be formed by all metal, via, ALPA, PA and MD but not broken by resistors. SAB is used for drain recognition in DRC runset.
@ Channel width (W) of NMOS and PMOS for ESD protection device (Channel width=Finger width x Finger No.) >= 360
   SETLAYER X = NET AREA RATIO ENGATE_D_EMPTY ESD3C_EMPTY \[AREA(ESD3C_EMPTY)/0.001\] < 360
   OUTLAYER ((X INTERACT ENGATE) NOT INTERACT EGATE_NOSAB) NOT INSIDE EXDRC
}

RULECHECK ESD_3b_G {
@ ESD.3G is defined for total channel width of ESD N/PMOS. The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity can be formed by all metal, via, ALPA, PA and MD but not broken by resistors. SAB is used for drain recognition in DRC runset.
@ Channel width (W) of NMOS and PMOS for ESD protection device (Channel width=Finger width x Finger No.) >= 360
   SETLAYER X = NET AREA RATIO EPGATE_D_EMPTY ESD3C_EMPTY \[AREA(ESD3C_EMPTY)/0.001\] < 360
   OUTLAYER ((X INTERACT EPGATE) NOT INTERACT EGATE_NOSAB) NOT INSIDE EXDRC
}

if { $IO == 1833 } {
RULECHECK ESD_4a_G {
@ Channel length of 3.3V I/O N/PMOS for protection device. >= 0.38um
 SETLAYER X = EGATEHV COIN EDGE EGATE_L
 OUTLAYER (LENGTH X < 0.38) NOT INSIDE EDGE EXDRC
}
}

if { $IO == 1825 } {
RULECHECK ESD_4b_G {
@ Channel length of 2.5V I/O N/PMOS for protection device. >= 0.28um
 SETLAYER X = EGATEHV COIN EDGE EGATE_L
 OUTLAYER (LENGTH X < 0.28) NOT INSIDE EDGE EXDRC
}
}

RULECHECK ESD_4c_G {
@ Channel length of 1.8V I/O N/PMOS for protection device. >= 0.2um
 SETLAYER X = EGATEMV COIN EDGE EGATE_L
 OUTLAYER (LENGTH X < 0.2) NOT INSIDE EDGE EXDRC
}

RULECHECK ESD_4d_G {
@ Channel length of 1.0V or 1.2V N/PMOS for protection device. >= 0.13um
 SETLAYER X = EGATELV COIN EDGE EGATE_L
 OUTLAYER (LENGTH X < 0.13) NOT INSIDE EDGE EXDRC
}

RULECHECK ESD_5_G {
@ Space from poly edge to CT edge on source side (SCP) for NMOS and PMOS (Fig. 4 and Fig.6). >= 0.25um
 OUTLAYER (EXT EGATE_W ECT_S < 0.25 ABUT< 90 REGION) NOT INSIDE EXDRC
}

RULECHECK ESD_6_G {
@ Space from poly edge to CT edge on drain side (DCP) (Fig. 4 and Fig.6). >= 1.7um
 OUTLAYER (EXT EGATE_W ECT_D < 1.7 ABUT< 90 REGION) NOT INSIDE EDGE EXDRC
}

RULECHECK ESD_7_G {
@ SAB should block on drain side of NMOS and PMOS (contact region should be kept silicided.)
@ SAB drawn on source side is not necessary.
 OUTLAYER (EGATE NOT INTERACT ESAB) NOT INSIDE EXDRC
 OUTLAYER (ECT AND ESAB) NOT INSIDE EXDRC
 OUTLAYER (EMOS_S AND ESAB) NOT INSIDE EXDRC
}
			
RULECHECK ESD_8_G {
@ Width of SAB on the drain side (A) for 1.0/1.2/1.8/2.5/3.3V NMOS and PMOS, note: A does not include the overlap of SAB area and GT(Fig. 4 and Fig.6). >= 1.5um
 OUTLAYER (EXT ESAB_HO EGATE_W < 1.5 ABUT < 90 REGION) NOT INSIDE EXDRC
}

RULECHECK ESD_9_G {
@ The width of SAB hole(B) for silicide CT area (Fig. 4 and Fig.6). <= 1um
 OUTLAYER (WITH WIDTH ESAB_HO > 1) NOT INSIDE EXDRC
}

RULECHECK ESD_10_G {
@ ESD protection devices should be surrounded by guard ring, this guard ring also can be designed as the pickup of the ESD device. (Fig.2)
 OUTLAYER (NOT EPGATE ENGUARDRING) NOT INSIDE EXDRC
 OUTLAYER (NOT ENGATE EPGUARDRING) NOT INSIDE EXDRC
}

RULECHECK ESD_14a_G {
@ The overlap (Sd) of SAB and poly for 1.8V/2.5V/3.3V I/O ESD N/PMOS (Fig. 4). >= 0.05um
 OUTLAYER (INT EGATEHV ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
 OUTLAYER (INT EGATEMV ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK ESD_14b_G {
@ The overlap (Sd) of the SAB and poly for 1.0V or 1.2V I/O ESD N/PMOS. >= 0.02um
 OUTLAYER (INT EGATELV ESAB < 0.02 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK ESD_15_G {
@ For high voltage tolerant I/O using Cascoded 2.5V/3.3V NMOS, ESD implant is required. (refer to Fig.5& 6)
 OUTLAYER (((AA OR GT) INTERACT EGATE_CASCODED) NOT ESD1) NOT INSIDE EXDRC
 OUTLAYER (ESD5V NOT ESD) NOT INSIDE EXDRC
}
			
RULECHECK ESD_16_G {
@ The space (S) between active poly gate and inactive poly gate of Cascoded NMOS should be (Fig.6). <= 0.6um
OUTLAYER (EXT EGATE_CASCODED_OVLAP EGATE_CASCODED_INSID > 0.6 <10 ABUT <90 OPPOSITE REGION EXCLUDE SHIELDED) NOT INSIDE EXDRC
}

RULECHECK ESD_17_G {
@ For high voltage tolerant I/O designed by 2.5V/3.3V NMOS, SAB should cover all top poly gates and extend to overlap the second poly gate by(Fig. 6). >= 0.05um
 SETLAYER X = EGATE_CASCODED INTERACT ESAB
 OUTLAYER (INT X ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT INSIDE EXDRC
 OUTLAYER (EGATE_CASCODED OUTSIDE ESAB) NOT INSIDE EXDRC
}
}
#//============================
#//  ESD1 implant layer rules
#//============================


RULECHECK ESD1_1 {
@ Minimum width of an ESD implant region is 0.5um
OUTLAYER (INT ESD1 < 0.50 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK ESD1_2 {
@ Minimum space between two ESD implant region is 0.5um
OUTLAYER (EXT ESD1 < 0.50 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

RULECHECK ESD1_3 {
@ Minimum area of ESD1 is 1 square um 
OUTLAYER (AREA ESD1 < 1) NOT INSIDE EXDRC
}

RULECHECK ESD1_4 {
@ Minimum enclosed area of ESD1 is  1 square um
OUTLAYER (AREA ((HOLES ESD1 INNER) NOT ESD1) < 1) NOT INSIDE EXDRC
}


RULECHECK ESD1_5 {
@ Minimum CT on AA (excluding pickup AA) enclosure by ESD1 is 0.2um
SETLAYER X = CT AND NON_PICKAA
OUTLAYER (ENC X ESD1 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}

    if { [string equal $Recommended_rules_OTHER YES] == 1 } {

RULECHECK ESD1_5a_R {
@ The Minimum recommended CT on AA (excluding pickup AA) enclosure by ESD1 is 0.5um
@ NOTICE: It is a recommended rule.
SETLAYER X = CT AND NON_PICKAA
OUTLAYER (ENC X ESD1 < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}

if { [string equal $Latch_Up_CHECK YES] == 1 } {

#//========================================
#//  Latch-Up Prevention Layout Guidelines
#//========================================

SETLAYER POWER_PAD = VSSMK1 OR VDDMK1 
SETLAYER ALL_RES =  (AA ENCLOSE (AA_resistor OR NW_resistor)) OR (GT ENCLOSE GT_resistor) 

SETLAYER all_pad_vdd_M1 = WITH TEXT M1 ?VDD? M1_TEXT
SETLAYER all_pad_vss_M1 = WITH TEXT M1 ?VSS? M1_TEXT
SETLAYER all_pad_vcc_M1 = WITH TEXT M1 ?VCC? M1_TEXT
SETLAYER all_pad_gnd_M1 = WITH TEXT M1 ?GND? M1_TEXT
SETLAYER all_pad_vdd_M2 = WITH TEXT M2 ?VDD? M2_TEXT
SETLAYER all_pad_vss_M2 = WITH TEXT M2 ?VSS? M2_TEXT
SETLAYER all_pad_vcc_M2 = WITH TEXT M2 ?VCC? M2_TEXT
SETLAYER all_pad_gnd_M2 = WITH TEXT M2 ?GND? M2_TEXT
SETLAYER all_pad_vdd_M3 = WITH TEXT M3 ?VDD? M3_TEXT
SETLAYER all_pad_vss_M3 = WITH TEXT M3 ?VSS? M3_TEXT
SETLAYER all_pad_vcc_M3 = WITH TEXT M3 ?VCC? M3_TEXT
SETLAYER all_pad_gnd_M3 = WITH TEXT M3 ?GND? M3_TEXT
SETLAYER all_pad_vdd_M4 = WITH TEXT M4 ?VDD? M4_TEXT
SETLAYER all_pad_vss_M4 = WITH TEXT M4 ?VSS? M4_TEXT
SETLAYER all_pad_vcc_M4 = WITH TEXT M4 ?VCC? M4_TEXT
SETLAYER all_pad_gnd_M4 = WITH TEXT M4 ?GND? M4_TEXT
SETLAYER all_pad_vdd_M5 = WITH TEXT M5 ?VDD? M5_TEXT
SETLAYER all_pad_vss_M5 = WITH TEXT M5 ?VSS? M5_TEXT
SETLAYER all_pad_vcc_M5 = WITH TEXT M5 ?VCC? M5_TEXT
SETLAYER all_pad_gnd_M5 = WITH TEXT M5 ?GND? M5_TEXT
SETLAYER all_pad_vdd_M6 = WITH TEXT M6 ?VDD? M6_TEXT
SETLAYER all_pad_vss_M6 = WITH TEXT M6 ?VSS? M6_TEXT
SETLAYER all_pad_vcc_M6 = WITH TEXT M6 ?VCC? M6_TEXT
SETLAYER all_pad_gnd_M6 = WITH TEXT M6 ?GND? M6_TEXT
SETLAYER all_pad_vdd_M7 = WITH TEXT M7 ?VDD? M7_TEXT
SETLAYER all_pad_vss_M7 = WITH TEXT M7 ?VSS? M7_TEXT
SETLAYER all_pad_vcc_M7 = WITH TEXT M7 ?VCC? M7_TEXT
SETLAYER all_pad_gnd_M7 = WITH TEXT M7 ?GND? M7_TEXT
SETLAYER all_pad_vdd_M8 = WITH TEXT M8 ?VDD? M8_TEXT
SETLAYER all_pad_vss_M8 = WITH TEXT M8 ?VSS? M8_TEXT
SETLAYER all_pad_vcc_M8 = WITH TEXT M8 ?VCC? M8_TEXT
SETLAYER all_pad_gnd_M8 = WITH TEXT M8 ?GND? M8_TEXT
SETLAYER all_pad_vdd_TM1 = WITH TEXT TM1 ?VDD? TM1_TEXT
SETLAYER all_pad_vss_TM1 = WITH TEXT TM1 ?VSS? TM1_TEXT
SETLAYER all_pad_vcc_TM1 = WITH TEXT TM1 ?VCC? TM1_TEXT
SETLAYER all_pad_gnd_TM1 = WITH TEXT TM1 ?GND? TM1_TEXT
SETLAYER all_pad_vdd_TM2 = WITH TEXT TM2 ?VDD? TM2_TEXT
SETLAYER all_pad_vss_TM2 = WITH TEXT TM2 ?VSS? TM2_TEXT
SETLAYER all_pad_vcc_TM2 = WITH TEXT TM2 ?VCC? TM2_TEXT
SETLAYER all_pad_gnd_TM2 = WITH TEXT TM2 ?GND? TM2_TEXT
SETLAYER all_pad_vdd_STM1 = WITH TEXT STM1 ?VDD? STM1_TEXT
SETLAYER all_pad_vss_STM1 = WITH TEXT STM1 ?VSS? STM1_TEXT
SETLAYER all_pad_vcc_STM1 = WITH TEXT STM1 ?VCC? STM1_TEXT
SETLAYER all_pad_gnd_STM1 = WITH TEXT STM1 ?GND? STM1_TEXT
SETLAYER all_pad_vdd_STM2 = WITH TEXT STM2 ?VDD? STM2_TEXT
SETLAYER all_pad_vss_STM2 = WITH TEXT STM2 ?VSS? STM2_TEXT
SETLAYER all_pad_vcc_STM2 = WITH TEXT STM2 ?VCC? STM2_TEXT
SETLAYER all_pad_gnd_STM2 = WITH TEXT STM2 ?GND? STM2_TEXT
SETLAYER all_pad_vdd_PA = WITH TEXT PA ?VDD? PA_TEXT
SETLAYER all_pad_vss_PA = WITH TEXT PA ?VSS? PA_TEXT
SETLAYER all_pad_vcc_PA = WITH TEXT PA ?VCC? PA_TEXT
SETLAYER all_pad_gnd_PA = WITH TEXT PA ?GND? PA_TEXT
SETLAYER all_pad_vdd_ALPA = WITH TEXT ALPA ?VDD? ALPATXT
SETLAYER all_pad_vss_ALPA = WITH TEXT ALPA ?VSS? ALPATXT
SETLAYER all_pad_vcc_ALPA = WITH TEXT ALPA ?VCC? ALPATXT
SETLAYER all_pad_gnd_ALPA = WITH TEXT ALPA ?GND? ALPATXT

SETLAYER all_pad_TXT_M1 = OR all_pad_vdd_M1 all_pad_vss_M1 all_pad_vcc_M1 all_pad_gnd_M1
SETLAYER all_pad_TXT_M2 = OR all_pad_vdd_M2 all_pad_vss_M2 all_pad_vcc_M2 all_pad_gnd_M2
SETLAYER all_pad_TXT_M3 = OR all_pad_vdd_M3 all_pad_vss_M3 all_pad_vcc_M3 all_pad_gnd_M3
SETLAYER all_pad_TXT_M4 = OR all_pad_vdd_M4 all_pad_vss_M4 all_pad_vcc_M4 all_pad_gnd_M4
SETLAYER all_pad_TXT_M5 = OR all_pad_vdd_M5 all_pad_vss_M5 all_pad_vcc_M5 all_pad_gnd_M5
SETLAYER all_pad_TXT_M6 = OR all_pad_vdd_M6 all_pad_vss_M6 all_pad_vcc_M6 all_pad_gnd_M6
SETLAYER all_pad_TXT_M7 = OR all_pad_vdd_M7 all_pad_vss_M7 all_pad_vcc_M7 all_pad_gnd_M7
SETLAYER all_pad_TXT_M8 = OR all_pad_vdd_M8 all_pad_vss_M8 all_pad_vcc_M8 all_pad_gnd_M8
SETLAYER all_pad_TXT_TM1 = OR all_pad_vdd_TM1 all_pad_vss_TM1 all_pad_vcc_TM1 all_pad_gnd_TM1
SETLAYER all_pad_TXT_TM2 = OR all_pad_vdd_TM2 all_pad_vss_TM2 all_pad_vcc_TM2 all_pad_gnd_TM2
SETLAYER all_pad_TXT_STM1 = OR all_pad_vdd_STM1 all_pad_vss_STM1 all_pad_vcc_STM1 all_pad_gnd_STM1
SETLAYER all_pad_TXT_STM2 = OR all_pad_vdd_STM2 all_pad_vss_STM2 all_pad_vcc_STM2 all_pad_gnd_STM2
SETLAYER all_pad_TXT_PA = OR all_pad_vdd_PA all_pad_vss_PA all_pad_vcc_PA all_pad_gnd_PA
SETLAYER all_pad_TXT_ALPA = OR all_pad_vdd_ALPA all_pad_vss_ALPA all_pad_vcc_ALPA all_pad_gnd_ALPA

SETLAYER all_pad_TXT = OR all_pad_TXT_M1 all_pad_TXT_M2 all_pad_TXT_M3 all_pad_TXT_M4 all_pad_TXT_M5 all_pad_TXT_M6 all_pad_TXT_M7 all_pad_TXT_M8 all_pad_TXT_TM1 all_pad_TXT_TM2 all_pad_TXT_STM1 all_pad_TXT_STM2 all_pad_TXT_PA all_pad_TXT_ALPA

SETLAYER NACT_0   = (SN AND AA) NOT GT  
SETLAYER PACT_0   = (SP AND AA) NOT GT  

SETLAYER CT_1     = EMPTY5 OR CT
SETLAYER MD_1     = EMPTY5 OR (MD NOT POWER_PAD)
SETLAYER RDL_1    = EMPTY5 OR RDL
SETLAYER RDLVIA_1 = EMPTY5 OR RDLVIAi
SETLAYER RDLPA2_1 = EMPTY5 OR RDLPA2i

if { $DEFINE_PAD_BY_TEXT == 1 } {
SETLAYER  ALPA_1 = EMPTY5 OR (ALPA NOT all_pad_TXT_ALPA)
SETLAYER  PA_1   = EMPTY5 OR (PA NOT all_pad_TXT_PA)
#foreach metal_via $v_m_list_for_connect {
#  SETLAYER  ${metal_via}_EMPTY5 = EMPTY5 OR (${metal_via} NOT all_pad_TXT)
#}


SETLAYER M1i_EMPTY5 = EMPTY5 OR (M1i NOT all_pad_TXT_M1)
set metal_list { M2 M3 M4 M5 M6 M7 M8 }
foreach metal_layer $metal_list {
  set tmp CHECK_$metal_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
SETLAYER ${metal_layer}i_EMPTY5 = EMPTY5 OR (${metal_layer}i NOT all_pad_TXT_${metal_layer})
}
}


SETLAYER V1_EMPTY5 = EMPTY5 OR V1
set via_list { V2 V3 V4 V5 V6 V7 }
foreach via_layer $via_list {
  set tmp CHECK_$via_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
SETLAYER ${via_layer}_EMPTY5 = EMPTY5 OR ${via_layer}

}
}

if { ($STM1_STV1 == 0) && ($STM2_STV2 == 0) && ($top_metal == 2) } {
SETLAYER TM1i_EMPTY5 = EMPTY5 OR (TM1i NOT all_pad_TXT_TM1)
SETLAYER TM2i_EMPTY5 = EMPTY5 OR (TM2i NOT all_pad_TXT_TM2)
SETLAYER TV1i_EMPTY5 = EMPTY5 OR TV1i 
SETLAYER TV2i_EMPTY5 = EMPTY5 OR TV2i 
}

if { ($STM1_STV1 == 1) && ($STM2_STV2 == 1) && ($top_metal == 2) } {
SETLAYER STM1i_EMPTY5 = EMPTY5 OR (STM1i NOT all_pad_TXT_STM1)
SETLAYER STM2i_EMPTY5 = EMPTY5 OR (STM2i NOT all_pad_TXT_STM2)
SETLAYER STV1i_EMPTY5 = EMPTY5 OR STV1i 
SETLAYER STV2i_EMPTY5 = EMPTY5 OR STV2i 
}

if { ($STM1_STV1 == 1) && ($STM2_STV2 == 0) && ($top_metal == 2) } {
SETLAYER STM1i_EMPTY5 = EMPTY5 OR (STM1i NOT all_pad_TXT_STM1)
SETLAYER TM2i_EMPTY5 = EMPTY5 OR (TM2i NOT all_pad_TXT_TM2)
SETLAYER STV1i_EMPTY5 = EMPTY5 OR STV1i 
SETLAYER TV2i_EMPTY5 = EMPTY5 OR TV2i 
}

if { ($STM1_STV1 == 0) && ($STM2_STV2 == 0) && ($top_metal == 1) } {
SETLAYER TM2i_EMPTY5 = EMPTY5 OR (TM2i NOT all_pad_TXT_TM2)
SETLAYER TV2i_EMPTY5 = EMPTY5 OR TV2i 
}


if { ($STM1_STV1 == 0) && ($STM2_STV2 == 1) && ($top_metal == 1) } {
SETLAYER STM2i_EMPTY5 = EMPTY5 OR (STM2i NOT all_pad_TXT_STM2)
SETLAYER STV2i_EMPTY5 = EMPTY5 OR STV2i 
}
}


if { $DEFINE_PAD_BY_TEXT == 0 } {
SETLAYER  ALPA_1 = EMPTY5 OR ALPAi
SETLAYER  PA_1   = EMPTY5 OR PAi
foreach metal_via $v_m_list_for_connect {
  SETLAYER  ${metal_via}_EMPTY5 = EMPTY5 OR ${metal_via}
}
}


if { $CONNECT_ALL_RESISTOR == 0 } {
SETLAYER  NACT_1 = EMPTY5 OR (NACT_0 NOT ALL_RES) 
SETLAYER  PACT_1 = EMPTY5 OR (PACT_0 NOT ALL_RES) 
SETLAYER  GT_1  =  EMPTY5 OR (GT_raw NOT GT_resistor)
}


if { $CONNECT_ALL_RESISTOR == 1 } {
SETLAYER  NACT_1 = EMPTY5 OR NACT_0  
SETLAYER  PACT_1 = EMPTY5 OR PACT_0  
SETLAYER  GT_1   = EMPTY5 OR GT_raw 
}

for { set i 0 } { $i < [expr [llength $v_m_list_for_connect] -2] } { incr i 2 } {
  CONNECT [lindex $v_m_list_for_connect $i]_EMPTY5 [lindex $v_m_list_for_connect [expr $i +2]]_EMPTY5 BY \
          [lindex $v_m_list_for_connect [expr $i +1]]_EMPTY5
}

CONNECT M1i_EMPTY5 GT_1 NACT_1 PACT_1  BY CT_1

if { [string equal $STM2_STV2 0] == 1 } {
CONNECT TM2i_EMPTY5 PA_1
CONNECT TM2i_EMPTY5 RDL_1 BY RDLVIA_1
}
if { [string equal $STM2_STV2 1] == 1 } {
CONNECT STM2i_EMPTY5 PA_1
CONNECT STM2i_EMPTY5 RDL_1 BY RDLVIA_1
}
CONNECT RDL_1 RDLPA2_1
CONNECT PA_1 ALPA_1
CONNECT RDL_1 ALPA_1
CONNECT ALPA_1 MD_1

SETLAYER NMOS_PAD = NMOS INTERACT (NET AREA RATIO NACT_1  MD_1 > 0) 
SETLAYER PMOS_PAD = PMOS INTERACT (NET AREA RATIO PACT_1  MD_1 > 0) 


SETLAYER NAA_PAD = NET AREA RATIO NACT_1  MD_1 > 0 
SETLAYER PAA_PAD = NET AREA RATIO PACT_1  MD_1 > 0 

SETLAYER PMOS1 = PACT ENCLOSE GATE
SETLAYER NMOS1 = NACT ENCLOSE GATE
SETLAYER NGUARDRING = HOLES NTAP INNER
SETLAYER PGUARDRING = HOLES PTAP INNER
SETLAYER NGUARDHOLE_2 = (HOLES NTAP INNER) ENCLOSE PGUARDRING
SETLAYER PGUARDHOLE_2 = (HOLES PTAP INNER) ENCLOSE NGUARDRING

SETLAYER GATEHV = GATE AND TG 
SETLAYER NGATEHV = NGATE AND TG
SETLAYER PGATEHV = PGATE AND TG
SETLAYER GATEMV = GATE AND DG                          //1.8V or 1.5V
SETLAYER GATELV = GATE NOT INSIDE (DG OR TG)   
RULECHECK LU_1_G {
@ Guard ring should be used to surround AA injector or a group of AA injectors which are connected to an I/O pad.
@ N+ injector must be surrounded by a P+ guard-ring.
@ P+ injector must be surrounded by a N+ guard-ring.
 OUTLAYER (((NAA_PAD TOUCH GT) NOT PGUARDRING) NOT INSIDE (LUWMK1 OR MARKS)) NOT INSIDE EXDRC
 OUTLAYER (((PAA_PAD TOUCH GT) NOT NGUARDRING) NOT INSIDE (LUWMK1 OR MARKS)) NOT INSIDE EXDRC
}
		
RULECHECK LU_2_G {
@ Guard-ring width for AA injector connected to an I/O pad >= 0.12um.
OUTLAYER (INT ((DONUT NTAP) TOUCH ((HOLES NTAP INNER) ENCLOSE PAA_PAD)) < 0.12 ABUT<90 SINGULAR REGION) NOT INSIDE (OR MARKS LUWMK1 EXDRC)
OUTLAYER (INT ((DONUT PTAP) TOUCH ((HOLES PTAP INNER) ENCLOSE NAA_PAD)) < 0.12 ABUT<90 SINGULAR REGION) NOT INSIDE (OR MARKS LUWMK1 EXDRC)
}

if { [string equal $LU_3_CHECK FAST] == 1 } {
RULECHECK LU_3a_G {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig. 7.3.14-1)
@ For core N/PMOS AA connected to an I/O pad
@ Spacing between NMOS and PMOS	>= 2 µm
 SETLAYER  X = (NMOS_PAD ENCLOSE GATELV) NOT MARKS
 SETLAYER  Y = (PMOS_PAD ENCLOSE GATELV) NOT MARKS
 SETLAYER  M = (NMOS ENCLOSE GATELV) NOT MARKS
 SETLAYER  N = (PMOS ENCLOSE GATELV) NOT MARKS
 SETLAYER  Z1 = SIZE X BY 1.036 BEVEL 3
 SETLAYER  Z2 = SIZE N BY 1.036 BEVEL 3
 OUTLAYER  (Z1 AND Z2) NOT INSIDE (OR LUWMK1 EXDRC)   
 SETLAYER   Z3 = SIZE M BY 1.036 BEVEL 3
 SETLAYER   Z4 = SIZE Y BY 1.036 BEVEL 3
 OUTLAYER  (Z3 AND Z4) NOT INSIDE (OR LUWMK1 EXDRC)
}			
RULECHECK LU_3b_G {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig.1).
@ For 1.8V N/PMOS AA connected to an I/O pad
@ Spacing between 1.8V NMOS and 1.8V/Core PMOS and Spacing between 1.8V PMOS and 1.8V/Core NMOS. >= 2.3um
 SETLAYER X = NMOS_PAD ENCLOSE GATEMV
 SETLAYER Y = PMOS_PAD ENCLOSE GATEMV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEMV)
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEMV)
 #OUTLAYER (EXT M Y < 2.3 ABUT<90 SINGULAR REGION) NOT MARKS
 #OUTLAYER (EXT X  N < 2.3 ABUT<90 SINGULAR REGION) NOT MARKS
  SETLAYER Z1 = SIZE X BY 1.191 BEVEL 3
  SETLAYER Z2 = SIZE N BY 1.191 BEVEL 3
  OUTLAYER ((Z1 AND Z2) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
  SETLAYER Z3 = SIZE M BY 1.191 BEVEL 3
  SETLAYER Z4 = SIZE Y BY 1.191 BEVEL 3
  OUTLAYER ((Z3 AND Z4) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
}

RULECHECK LU_3c_G {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig.1).
@ For 2.5V N/PMOS AA connected to an I/O pad
@ Spacing between 2.5V NMOS and 2.5V/Core PMOS and Spacing between 2.5V PMOS and 2.5V/Core NMOS. >= 3.2um
 SETLAYER X = NMOS_PAD ENCLOSE GATEHV
 SETLAYER Y = PMOS_PAD ENCLOSE GATEHV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEHV )
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEHV)
 #OUTLAYER ((EXT M Y < 3.2 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE EXDRC
 #OUTLAYER ((EXT X N < 3.2 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE EXDRC
 SETLAYER Z1 = SIZE X BY 1.657 BEVEL 3
 SETLAYER Z2 = SIZE N BY 1.657 BEVEL 3
 OUTLAYER ((Z1 AND Z2) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
 SETLAYER Z3 = SIZE M BY 1.657 BEVEL 3
 SETLAYER Z4 = SIZE Y BY 1.657 BEVEL 3
 OUTLAYER  ((Z3 AND Z4) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
}

RULECHECK LU_3d_G {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig.1).
@ For 3.3 V N/PMOS AA (2.5V overdrive) connected to an I/O pad
@ Spacing between 3.3V NMOS and 3.3V/Core PMOS and Spacing between 3.3V PMOS and 3.3V/Core NMOS.>= 5um.
 SETLAYER X = NMOS_PAD ENCLOSE (GATEHV AND OVERPL)
 SETLAYER Y = PMOS_PAD ENCLOSE (GATEHV AND OVERPL)
 SETLAYER M = NMOS ENCLOSE (GATELV OR (GATEHV AND OVERPL))
 SETLAYER N = PMOS ENCLOSE (GATELV OR (GATEHV AND OVERPL))
 #OUTLAYER ((EXT X N < 5 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE EXDRC
 #OUTLAYER ((EXT Y M < 5 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE EXDRC
 SETLAYER  Z1 = SIZE X BY 2.589 BEVEL 3
 SETLAYER  Z2 = SIZE N BY 2.589 BEVEL 3
 OUTLAYER  ((Z1 AND Z2) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
 SETLAYER  Z3 = SIZE M BY 2.589 BEVEL 3
 SETLAYER  Z4 = SIZE Y BY 2.589 BEVEL 3
 OUTLAYER  ((Z3 AND Z4) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
}
 
}
if { [string equal $LU_3_CHECK ACCURATE] == 1 } {
RULECHECK LU_3a_G {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig.1).
@ For core N/PMOS connected to an I/O pad
@ Spacing between NMOS and PMOS. >= 2um
 SETLAYER X = NMOS_PAD ENCLOSE GATELV
 SETLAYER Y = PMOS_PAD ENCLOSE GATELV
 SETLAYER M = NMOS ENCLOSE GATELV
 SETLAYER N = PMOS ENCLOSE GATELV
 OUTLAYER ((EXT X N < 2 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
 OUTLAYER ((EXT M Y < 2 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
}

RULECHECK LU_3b_G {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig.1).
@ For 1.8V N/PMOS AA connected to an I/O pad
@ Spacing between 1.8V NMOS and 1.8V/Core PMOS and Spacing between 1.8V PMOS and 1.8V/Core NMOS. >= 2.3um
 SETLAYER X = NMOS_PAD ENCLOSE GATEMV
 SETLAYER Y = PMOS_PAD ENCLOSE GATEMV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEMV)
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEMV)
 OUTLAYER ((EXT M Y < 2.3 ABUT<90 SINGULAR REGION) NOT MARKS ) NOT INSIDE (OR LUWMK1 EXDRC)
 OUTLAYER ((EXT X N < 2.3 ABUT<90 SINGULAR REGION) NOT MARKS ) NOT INSIDE (OR LUWMK1 EXDRC)
}

RULECHECK LU_3c_G {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig.1).
@ For 2.5V N/PMOS AA connected to an I/O pad
@ Spacing between 2.5V NMOS and 2.5V/Core PMOS and Spacing between 2.5V PMOS and 2.5V/Core NMOS. >= 3.2um
 SETLAYER X = NMOS_PAD ENCLOSE GATEHV
 SETLAYER Y = PMOS_PAD ENCLOSE GATEHV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEHV )
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEHV)
 OUTLAYER ((EXT M Y < 3.2 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
 OUTLAYER ((EXT X N < 3.2 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
}

RULECHECK LU_3d_G {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig.1).
@ For 3.3 V N/PMOS AA (2.5V overdrive) connected to an I/O pad
@ Spacing between 3.3V NMOS and 3.3V/Core PMOS and Spacing between 3.3V PMOS and 3.3V/Core NMOS >= 5.0um.
 SETLAYER X = NMOS_PAD ENCLOSE (GATEHV AND OVERPL)
 SETLAYER Y = PMOS_PAD ENCLOSE (GATEHV AND OVERPL)
 SETLAYER M = NMOS ENCLOSE (GATELV OR (GATEHV AND OVERPL))
 SETLAYER N = PMOS ENCLOSE (GATELV OR (GATEHV AND OVERPL))
 OUTLAYER ((EXT X N < 5 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)
 OUTLAYER ((EXT Y M < 5 ABUT<90 SINGULAR REGION) NOT MARKS) NOT INSIDE (OR LUWMK1 EXDRC)

}

}
RULECHECK LU_4_NTAP_G {
@ Space (S2) from any point within the Source/Drain region to the nearest pickup AA region inside the same well for I/O and internal circuits. (Fig.2). 
@ For native device, DRC check the pickup AA inside the PSUB butted PW area, and PW is still treated as connection by substrate even one NW ring inserted. <= 35um
 SETLAYER A = INT NTAP < 0.005 ABUT INTERSECTING ONLY REGION
 SETLAYER B = (NTAP INTERACT A) NOT A
 SETLAYER C = INT B < 0.001 ABUT INTERSECTING ONLY REGION
 SETLAYER D = (B INTERACT C) NOT C
 SETLAYER NW_MINUS_NTAP_0 = SIZE D BY 15 INSIDE OF NW STEP 0.38 TRUNCATE 0.1
 SETLAYER MAYBE_BAD_b = NW NOT NW_MINUS_NTAP_0
 SETLAYER NW_FILTER = NW INTERACT MAYBE_BAD_b
 SETLAYER NW_MINUS_NTAP_1 = NW_MINUS_NTAP_0 AND NW_FILTER
 SETLAYER NW_MINUS_NTAP = SIZE NW_MINUS_NTAP_1 BY 20 INSIDE OF NW_FILTER STEP 0.38 TRUNCATE 0.1
 SETLAYER X = PMOS1 AND NW_FILTER
 OUTLAYER ((OUTSIDE EDGE X NW_MINUS_NTAP) NOT INSIDE EDGE MARKS) NOT INSIDE EDGE EXDRC
}

RULECHECK LU_4_PTAP_G {
@ Space (S2) from any point within the Source/Drain region to the nearest pickup AA region inside the same well for I/O and internal circuits.(Fig. 7.3.14-2) 
@ For native device, DRC check the pickup AA inside the PSUB butted PW area, and PW is still treated as connection by substrate even one NW ring inserted. <= 35um
 SETLAYER A = INT PTAP < 0.005 ABUT INTERSECTING ONLY REGION
 SETLAYER B = (PTAP INTERACT A) NOT A
 SETLAYER C = INT B < 0.001 ABUT INTERSECTING ONLY REGION
 SETLAYER D = (B INTERACT C) NOT C
 SETLAYER PW_MINUS_PTAP_0 = SIZE D BY 15 INSIDE OF PW STEP 0.38 TRUNCATE 0.1
 SETLAYER MAYBE_BAD_b = PW NOT PW_MINUS_PTAP_0
 SETLAYER PW_FILTER = PW INTERACT MAYBE_BAD_b
 SETLAYER PW_MINUS_PTAP_1 = PW_MINUS_PTAP_0 AND PW_FILTER
 SETLAYER PW_MINUS_PTAP = SIZE PW_MINUS_PTAP_1 BY 20 INSIDE OF PW_FILTER STEP 0.38 TRUNCATE 0.1
 SETLAYER X = NMOS1 AND PW_FILTER
 OUTLAYER ((OUTSIDE EDGE X PW_MINUS_PTAP) NOT INSIDE EDGE MARKS) NOT INSIDE EDGE EXDRC
}
}


if { [string equal $CT_GT_G_CHECK YES] == 1 } {

RULECHECK MOM_4_G {
@ MOMDMY and MOMMKn  layers are must for MOM device

set MOMMK_list { MOMMK1, MOMMK2, MOMMK3, MOMMK4, MOMMK5, MOMMK6, MOMMK7, MOMMK8 }
set momcap_list { 12 13 14 15 16 17 18 23 24 25 26 27 28 34 35 36 37 38 45 46 47 48 56 57 58 67 68 78 }

foreach k $momcap_list {
SETLAYER  MOMMK1_${k} = MOMMK1 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK2_${k} = MOMMK2 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK3_${k} = MOMMK3 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK4_${k} = MOMMK4 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK5_${k} = MOMMK5 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK6_${k} = MOMMK6 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK7_${k} = MOMMK7 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK8_${k} = MOMMK8 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
}

foreach k $momcap_list {
SETLAYER  MOMMK1_${k}_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK2_${k}_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK3_${k}_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK4_${k}_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK5_${k}_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK6_${k}_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK7_${k}_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK8_${k}_no = MOMMK8 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
}

foreach k $momcap_list {
SETLAYER  MOMDMY_${k} = MOMDMY WITH TEXT \"momcap${k}\" MOMDMY
SETLAYER  MOMDMY_${k}_no = MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY
}

########## can't be marked with MOMMK1
  set momcap_list1 [lrange $momcap_list 7 end]
#RULECHECK T1 {
foreach k $momcap_list1 {
OUTLAYER  (MOMMK1 AND MOMMK1_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK2
  set momcap_list2 [lrange $momcap_list 13 end]
#RULECHECK T2 {
foreach k $momcap_list2 {
OUTLAYER  (MOMMK2 AND MOMMK2_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK3
  set momcap_list3 [lrange $momcap_list 18 end]
#RULECHECK T3 {
OUTLAYER  (MOMMK3 AND MOMMK3_12) NOT MARKS
foreach k $momcap_list3 {
OUTLAYER  (MOMMK3 AND MOMMK3_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK4
set momcap_list4 [lrange $momcap_list 22 end]
#RULECHECK T4 {
OUTLAYER  (MOMMK4 AND MOMMK4_12) NOT MARKS 
OUTLAYER  (MOMMK4 AND MOMMK4_13) NOT MARKS 
OUTLAYER  (MOMMK4 AND MOMMK4_23) NOT MARKS 
foreach k $momcap_list4 {
OUTLAYER  (MOMMK4 AND MOMMK4_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK5
set momcap_list5 [lrange $momcap_list 25 end]
#RULECHECK T5 {
OUTLAYER  (MOMMK5 AND MOMMK5_12) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_13) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_14) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_23) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_24) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_34) NOT MARKS 
foreach k $momcap_list5 {
OUTLAYER  (MOMMK5 AND MOMMK5_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK6
set momcap_list6 { 12 13 14 15 23 24 25 34 35 45 78 }
#RULECHECK T6 {
foreach k $momcap_list6 {
OUTLAYER  (MOMMK6 AND MOMMK6_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK7
set momcap_list7 { 12 13 14 15 16 23 24 25 26 34 35 36 45 46 56 }
#RULECHECK T7 {
foreach k $momcap_list7 {
OUTLAYER  (MOMMK7 AND MOMMK7_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK8
set momcap_list8 { 12 13 14 15 16 17 23 24 25 26 27 34 35 36 37 45 46 47 56 57 67 }
#RULECHECK T8 {
foreach k $momcap_list8 {
OUTLAYER  (MOMMK8 AND MOMMK8_${k}) NOT MARKS
}
#}
#############################################################################################


########## should be but not be marked with MOMMK1
#RULECHECK Y12 {
SETLAYER  X12 = (MOMDMY_12 INTERACT MOMMK1) INTERACT MOMMK2
OUTLAYER  (MOMDMY_12 NOT X12) NOT MARKS
#}

#RULECHECK Y13 {
SETLAYER  X13 = ((MOMDMY_13 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3
OUTLAYER  (MOMDMY_13 NOT X13) NOT MARKS
#}

#RULECHECK Y14 {
SETLAYER  X14 = (((MOMDMY_14 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4
OUTLAYER  (MOMDMY_14 NOT X14) NOT MARKS
#}

#RULECHECK Y15 {
SETLAYER  X15 = ((((MOMDMY_15 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5
OUTLAYER  (MOMDMY_15 NOT X15) NOT MARKS
#}

#RULECHECK Y16 {
SETLAYER  X16 = (((((MOMDMY_16 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_16 NOT X16) NOT MARKS
#}

#RULECHECK Y17 {
SETLAYER  X17 = ((((((MOMDMY_17 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_17 NOT X17) NOT MARKS
#}

#RULECHECK Y18 {
SETLAYER  X18 = (((((((MOMDMY_18 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_18 NOT X18) NOT MARKS
#}

#RULECHECK Y23 {
SETLAYER  X23 = (MOMDMY_23 INTERACT MOMMK2) INTERACT MOMMK3 
OUTLAYER  (MOMDMY_23 NOT X23) NOT MARKS
#}

#RULECHECK Y24 {
SETLAYER  X24 = ((MOMDMY_24 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4
OUTLAYER  (MOMDMY_24 NOT X24) NOT MARKS
#}

#RULECHECK Y25 {
SETLAYER  X25 = (((MOMDMY_25 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5
OUTLAYER  (MOMDMY_25 NOT X25) NOT MARKS
#}

#RULECHECK Y26 {
SETLAYER  X26 = ((((MOMDMY_26 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_26 NOT X26) NOT MARKS
#}

#RULECHECK Y27 {
SETLAYER  X27 = (((((MOMDMY_27 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_27 NOT X27) NOT MARKS
#}

#RULECHECK Y28 {
SETLAYER  X28 = ((((((MOMDMY_28 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_28 NOT X28) NOT MARKS
#}

#RULECHECK Y34 {
SETLAYER  X34 = (MOMDMY_34 INTERACT MOMMK3) INTERACT MOMMK4
OUTLAYER  (MOMDMY_34 NOT X34) NOT MARKS
#}

#RULECHECK Y35 {
SETLAYER  X35 = ((MOMDMY_35 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5
OUTLAYER  (MOMDMY_35 NOT X35) NOT MARKS
#}

#RULECHECK Y36 {
SETLAYER  X36 = (((MOMDMY_36 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_36 NOT X36) NOT MARKS
#}

#RULECHECK Y37 {
SETLAYER  X37 = ((((MOMDMY_37 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_37 NOT X37) NOT MARKS
#}

#RULECHECK Y38 {
SETLAYER  X38 = (((((MOMDMY_38 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_38 NOT X38) NOT MARKS
#}

#RULECHECK Y45 {
SETLAYER  X45 = (MOMDMY_45 INTERACT MOMMK4) INTERACT MOMMK5
OUTLAYER  (MOMDMY_45 NOT X45) NOT MARKS
#}

#RULECHECK Y46 {
SETLAYER  X46 = ((MOMDMY_46 INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_46 NOT X46) NOT MARKS
#}

#RULECHECK Y47 {
SETLAYER  X47 = (((MOMDMY_47 INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_47 NOT X47) NOT MARKS
#}

#RULECHECK Y48 {
SETLAYER  X48 = ((((MOMDMY_48 INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_48 NOT X48) NOT MARKS
#}

#RULECHECK Y56 {
SETLAYER  X56 = (MOMDMY_56 INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_56 NOT X56) NOT MARKS
#}

#RULECHECK Y57 {
SETLAYER  X57 = ((MOMDMY_57 INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_57 NOT X57) NOT MARKS
#}

#RULECHECK Y58 {
SETLAYER  X58 = (((MOMDMY_58 INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_58 NOT X58) NOT MARKS
#}

#RULECHECK Y67 {
SETLAYER  X67 = (MOMDMY_67 INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_67 NOT X67) NOT MARKS
#}

#RULECHECK Y68 {
SETLAYER  X68 = ((MOMDMY_68 INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_68 NOT X68) NOT MARKS
#}

#RULECHECK Y78 {
SETLAYER  X78 = (MOMDMY_78 INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_78 NOT X78) NOT MARKS
#}

######################################################################################

#########MOMDMY not with correspond text

SETLAYER  Z12 = ((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) NOT INTERACT (OR MOMMK3 MOMMK4 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z12 NOT WITH TEXT \"momcap12\" MOMDMY) NOT MARKS

SETLAYER  Z13 = (((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) NOT INTERACT (OR MOMMK4 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z13 NOT WITH TEXT \"momcap13\" MOMDMY) NOT MARKS 

SETLAYER  Z14 = ((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) NOT INTERACT (OR MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z14 NOT WITH TEXT \"momcap14\" MOMDMY) NOT MARKS 

SETLAYER  Z15 = (((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) NOT INTERACT (OR MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z15 NOT WITH TEXT \"momcap15\" MOMDMY) NOT MARKS  

SETLAYER  Z16 = ((((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK7 MOMMK8)
OUTLAYER  (Z16 NOT WITH TEXT \"momcap16\" MOMDMY) NOT MARKS

SETLAYER  Z17 = (((((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT MOMMK8
OUTLAYER  (Z17 NOT WITH TEXT \"momcap17\" MOMDMY) NOT MARKS

SETLAYER  Z18 = (((((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (Z18 NOT WITH TEXT \"momcap18\" MOMDMY) NOT MARKS

SETLAYER  Z23 = ((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) NOT INTERACT (OR MOMMK1 MOMMK4 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z23 NOT WITH TEXT \"momcap23\" MOMDMY) NOT MARKS

SETLAYER  Z24 = (((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) NOT INTERACT (OR MOMMK1 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z24 NOT WITH TEXT \"momcap24\" MOMDMY) NOT MARKS

SETLAYER  Z25 = ((((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) NOT INTERACT (OR MOMMK1 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z25 NOT WITH TEXT \"momcap25\" MOMDMY) NOT MARKS

SETLAYER  Z26 = (((((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK1 MOMMK7 MOMMK8)
OUTLAYER  (Z26 NOT WITH TEXT \"momcap26\" MOMDMY) NOT MARKS

SETLAYER  Z27 = ((((((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK8)
OUTLAYER  (Z27 NOT WITH TEXT \"momcap27\" MOMDMY) NOT MARKS

SETLAYER  Z28 = (((((((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT MOMMK1
OUTLAYER  (Z28 NOT WITH TEXT \"momcap28\" MOMDMY) NOT MARKS

SETLAYER  Z34 = ((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z34 NOT WITH TEXT \"momcap34\" MOMDMY) NOT MARKS

SETLAYER  Z35 = (((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z35 NOT WITH TEXT \"momcap35\" MOMDMY) NOT MARKS

SETLAYER  Z36 = ((((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK7 MOMMK8)
OUTLAYER  (Z36 NOT WITH TEXT \"momcap36\" MOMDMY) NOT MARKS

SETLAYER  Z37 = (((((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK8)
OUTLAYER  (Z37 NOT WITH TEXT \"momcap37\" MOMDMY) NOT MARKS

SETLAYER  Z38 = ((((((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2)
OUTLAYER  (Z38 NOT WITH TEXT \"momcap38\" MOMDMY) NOT MARKS

SETLAYER  Z45 = ((MOMDMY INTERACT MOMMK4) INTERACT MOMMK5) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z45 NOT WITH TEXT \"momcap45\" MOMDMY) NOT MARKS

SETLAYER  Z46 = (((MOMDMY INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK7 MOMMK8)
OUTLAYER  (Z46 NOT WITH TEXT \"momcap46\" MOMDMY) NOT MARKS

SETLAYER  Z47 = ((((MOMDMY INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK8)
OUTLAYER  (Z47 NOT WITH TEXT \"momcap47\" MOMDMY) NOT MARKS

SETLAYER  Z48 = (((((MOMDMY INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3)
OUTLAYER  (Z48 NOT WITH TEXT \"momcap48\" MOMDMY) NOT MARKS

SETLAYER  Z56 = ((MOMDMY INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK7 MOMMK8)
OUTLAYER  (Z56 NOT WITH TEXT \"momcap56\" MOMDMY) NOT MARKS

SETLAYER  Z57 = (((MOMDMY INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK8)
OUTLAYER  (Z57 NOT WITH TEXT \"momcap57\" MOMDMY) NOT MARKS

SETLAYER  Z58 = ((((MOMDMY INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4)
OUTLAYER  (Z58 NOT WITH TEXT \"momcap58\" MOMDMY) NOT MARKS

SETLAYER  Z67 = ((MOMDMY INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK5 MOMMK8)
OUTLAYER  (Z67 NOT WITH TEXT \"momcap67\" MOMDMY) NOT MARKS

SETLAYER  Z68 = (((MOMDMY INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK5)
OUTLAYER  (Z68 NOT WITH TEXT \"momcap68\" MOMDMY) NOT MARKS

SETLAYER  Z78 = ((MOMDMY INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK5 MOMMK6)
OUTLAYER  (Z78 NOT WITH TEXT \"momcap78\" MOMDMY) NOT MARKS
}
}




if { [string equal $MOM_CHECK YES] ==1 } {
#//===================================================
#//  MOM design rules
#//===================================================
GROUP GMOM MOM_?

RULECHECK MOM_5_G {
@ It is not allowed:
@ 1)	V1 in MOMMK1 
@ 2)	Vn/Vn-1 in MOMMKn (n=2~8), whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1/STV1 or TV2/STV2.
for {set i 1} { $i < [expr [llength $v_j] +1 ] } {incr i 1} {
OUTLAYER (V${i} AND MOMMK${i}) NOT INSIDE EXDRC
OUTLAYER (V${i} AND MOMMK[expr ${i} +1]) NOT INSIDE EXDRC
set top_inner_mk MOMMK[expr ${i} +1]
}
set topvia [lindex $top_v_m_list 0]
OUTLAYER ($topvia AND $top_inner_mk) NOT INSIDE EXDRC
}

RULECHECK MOM_6_G {
@ The space between (Mn AND MOMMKn AND MOMDMY) and Vn /Vn-1 (n=1~8) outside of MOMDMY, whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2 >= 0.11um.
for {set i 1} { $i < [expr [llength $v_j] +1 ] } {incr i 1} {
OUTLAYER (EXT (V${i} OUTSIDE MOMDMY) ((M${i} AND MOMMK${i}) AND MOMDMY) < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
OUTLAYER (EXT (V${i} OUTSIDE MOMDMY) ((M[expr ${i} +1] AND MOMMK[expr ${i} +1]) AND MOMDMY) < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
set top_inner_mk MOMMK[expr ${i} +1]
set top_inner_metal M[expr ${i} +1]
}
set topvia [lindex $top_v_m_list 0]
OUTLAYER (EXT ($topvia OUTSIDE MOMDMY) (($top_inner_metal AND $top_inner_mk) AND MOMDMY) < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE EXDRC
}
}


if { [string equal $DFM_Priority1 YES] ==1 } {
VERBATIM {

//============================
//  DFM RULE Check
//============================



DMACRO DFM4 LOWMT HIGHMT VIA {
A_1 = LOWMT AND HIGHMT
W_LOWMT = LOWMT WITH WIDTH >= 0.5
W_HIGHMT = HIGHMT WITH WIDTH >= 0.5
A = ( A_1 INTERACT W_LOWMT ) OR (A_1 INTERACT W_HIGHMT )
B = A INTERACT VIA == 1
B1 = B TOUCH ( W_LOWMT NOT B ) == 2
B2 = B TOUCH ( W_HIGHMT NOT B ) == 2
B3 = B NOT (B1 OR B2 )
B4 = SIZE B3 BY 2
BALL = ((( B4 AND W_LOWMT ) OR (B4  AND W_HIGHMT ) ) ENCLOSE B3) OR ( B1 OR B2 )
LOWMT_1 = LOWMT INTERACT B
HIGHMT_1 = HIGHMT INTERACT B
LOWMT_INT = INT LOWMT_1 < 15 OPPOSITE EXCLUDE SHIELDED
HIGHMT_INT = INT HIGHMT_1 < 15 OPPOSITE EXCLUDE SHIELDED
LOWMT_2 = DFM PROPERTY LOWMT_INT BALL OVERLAP ABUT ALSO MULTI [WIDTH = MIN(EW(LOWMT_INT))]
HIGHMT_2 = DFM PROPERTY HIGHMT_INT BALL OVERLAP ABUT ALSO MULTI [WIDTH = MIN(EW(HIGHMT_INT))]
ERR1 = DFM PROPERTY BALL LOWMT_2 HIGHMT_2 OVERLAP ABUT ALSO MULTI [ratio = property(LOWMT_2,WIDTH)/property(HIGHMT_2,WIDTH)]>=5
ERR2 = DFM PROPERTY BALL LOWMT_2 HIGHMT_2 OVERLAP ABUT ALSO MULTI [ratio = property(HIGHMT_2,WIDTH)/property(LOWMT_2,WIDTH)]>=5
(B INTERACT (ERR1 OR ERR2)) NOT INSIDE EXDFM
}

DMACRO DFM4_EXDFM LOWMT HIGHMT VIA {
A_1 = LOWMT AND HIGHMT
W_LOWMT = LOWMT WITH WIDTH >= 0.5
W_HIGHMT = HIGHMT WITH WIDTH >= 0.5
A = ( A_1 INTERACT W_LOWMT ) OR (A_1 INTERACT W_HIGHMT )
B = A INTERACT VIA == 1
B1 = B TOUCH ( W_LOWMT NOT B ) == 2
B2 = B TOUCH ( W_HIGHMT NOT B ) == 2
B3 = B NOT (B1 OR B2 )
B4 = SIZE B3 BY 2
BALL = ((( B4 AND W_LOWMT ) OR (B4  AND W_HIGHMT ) ) ENCLOSE B3) OR ( B1 OR B2 )
LOWMT_1 = LOWMT INTERACT B
HIGHMT_1 = HIGHMT INTERACT B
LOWMT_INT = INT LOWMT_1 < 15 OPPOSITE EXCLUDE SHIELDED
HIGHMT_INT = INT HIGHMT_1 < 15 OPPOSITE EXCLUDE SHIELDED
LOWMT_2 = DFM PROPERTY LOWMT_INT BALL OVERLAP ABUT ALSO MULTI [WIDTH = MIN(EW(LOWMT_INT))]
HIGHMT_2 = DFM PROPERTY HIGHMT_INT BALL OVERLAP ABUT ALSO MULTI [WIDTH = MIN(EW(HIGHMT_INT))]
ERR1 = DFM PROPERTY BALL LOWMT_2 HIGHMT_2 OVERLAP ABUT ALSO MULTI [ratio = property(LOWMT_2,WIDTH)/property(HIGHMT_2,WIDTH)]>=5
ERR2 = DFM PROPERTY BALL LOWMT_2 HIGHMT_2 OVERLAP ABUT ALSO MULTI [ratio = property(HIGHMT_2,WIDTH)/property(LOWMT_2,WIDTH)]>=5
(B INTERACT (ERR1 OR ERR2)) NOT INSIDE EXDFM
}


DFM_1a_2a {
@ Recommended spacing of L-shape (poly to AA, or AA to poly) of the same MOS with channel width >=0.16 is >= 0.07.
 AA_OR_GT = AA OR GT
 X = CONVEX EDGE AA_OR_GT ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.07
 Y = EXPAND EDGE X INSIDE BY 0.001 EXTEND BY 0.001
 NARROW_GATE = INT AAEIGT < 0.16 REGION
 WIDE_GATE = GATE NOT NARROW_GATE
 (Y INTERACT WIDE_GATE) NOT INSIDE EXDFM
}
DFM_1b_2b {
@ Recommended spacing of L-shape (poly to AA, or AA to poly) of the same MOS with channel width < 0.16 is >= 0.1.
 AA_OR_GT = AA OR GT
 X = CONVEX EDGE AA_OR_GT ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.1
 Y = EXPAND EDGE X INSIDE BY 0.001
 NARROW_GATE = INT AAEIGT < 0.16 REGION
 (Y TOUCH NARROW_GATE) NOT INSIDE EXDFM
}

DFM_4_V1 {
@ Insert one V1 if single V1 and (W1 >= 5W2, or W2 >= 5W1).
 CMACRO DFM4_EXDFM M1 M2 V1
}
DFM_4_V2 {
@ Insert one V2 if single V2 and (W2 >= 5W3, or W3 >= 5W2).
 CMACRO DFM4 M2 M3 V2
}
}

if { [expr $total_metal - $top_metal ] >= 4 } { 
VERBATIM {
DFM_4_V3 {
@ Insert one V3 if single V3 and (W3 >= 5W4, or W4 >= 5W3).
CMACRO DFM4 M3 M4 V3
}
}

if { [expr $total_metal - $top_metal ] >= 5 } {
VERBATIM {
DFM_4_V4 {
@ Insert one V4 if single V4 and (W4 >= 5W5, or W5 >= 5W4).
 CMACRO DFM4 M4 M5 V4
}
}

if { [expr $total_metal - $top_metal ] >= 6 } {
VERBATIM {
DFM_4_V5 {
@ Insert one V5 if single V5 and (W5 >= 5W6, or W6 >= 5W5).
 CMACRO DFM4 M5 M6 V5
}
}

if { [expr $total_metal - $top_metal ] >= 7 } {
VERBATIM {
DFM_4_V6 {
@ Insert one V6 if single V6 and (W6 >= 5W7, or W7 >= 5W6).
 CMACRO DFM4 M6 M7 V6
}
}

if { [expr $total_metal - $top_metal ] >= 8 } {
VERBATIM {
DFM_4_V7 {
@ Insert one V7 if single V7 and (W7 >= 5W8, or W8 >= 5W7).
 CMACRO DFM4 M7 M8 V7
}
}
}
}
}
}
}


VERBATIM {
DFM_5_M1 {
@ Maximum parallel run length of parallel metal(M1) lines with minimum spacing is 25
@ Designer can waive the violations if design passes sign-off level signal integrity check
@ DRC doesn't check MOMDMY covered MOM region.
   MINM1_para = EXT M1_dfm == 0.09 OPPOSITE REGION PARA ONLY
   X = LENGTH MINM1_para > 25
   ((M1_dfm WITH EDGE X) NOT MOMDMY) NOT INSIDE EXDFM
}
DFM_5_M2 {
@ Maximum parallel run length of parallel metal(M2) lines with minimum spacing is 25
@ Designer can waive the violations if design passes sign-off level signal integrity check
@ DRC doesn't check MOMDMY covered MOM region.
   MINM2_para = EXT M2_dfm == 0.10 OPPOSITE REGION PARA ONLY
   X = LENGTH MINM2_para > 25
   ((M2_dfm WITH EDGE X) NOT MOMDMY) NOT INSIDE EXDFM
}

DFM_5_M3 {
@ Maximum parallel run length of parallel metal(M3) lines with minimum spacing is 25
@ Designer can waive the violations if design passes sign-off level signal integrity check
@ DRC doesn't check MOMDMY covered MOM region.
   MINM3_para = EXT M3 == 0.10 OPPOSITE REGION PARA ONLY
   X = LENGTH MINM3_para > 25
   ((M3 WITH EDGE X) NOT MOMDMY) NOT INSIDE EXDFM
}
}


if { [expr $total_metal - $top_metal ] >= 4 } { 
VERBATIM {
DFM_5_M4 {
@ Maximum parallel run length of parallel metal(M4) lines with minimum spacing is 25
@ Designer can waive the violations if design passes sign-off level signal integrity check
@ DRC doesn't check MOMDMY covered MOM region.
   MINM4_para = EXT M4 == 0.10 OPPOSITE REGION PARA ONLY
   X = LENGTH MINM4_para > 25
   ((M4 WITH EDGE X) NOT MOMDMY) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 5 } { 
VERBATIM {
DFM_5_M5 {
@ Maximum parallel run length of parallel metal(M5) lines with minimum spacing is 25
@ Designer can waive the violations if design passes sign-off level signal integrity check
@ DRC doesn't check MOMDMY covered MOM region.
   MINM5_para = EXT M5 == 0.10 OPPOSITE REGION PARA ONLY
   X = LENGTH MINM5_para > 25
   ((M5 WITH EDGE X) NOT MOMDMY) NOT INSIDE EXDFM
}
}


if { [expr $total_metal - $top_metal ] >= 6 } { 
VERBATIM {
DFM_5_M6 {
@ Maximum parallel run length of parallel metal(M6) lines with minimum spacing is 25
@ Designer can waive the violations if design passes sign-off level signal integrity check
@ DRC doesn't check MOMDMY covered MOM region.
   MINM6_para = EXT M6 == 0.10 OPPOSITE REGION PARA ONLY
   X = LENGTH MINM6_para > 25
   ((M6 WITH EDGE X) NOT MOMDMY) NOT INSIDE EXDFM
}
}



if { [expr $total_metal - $top_metal ] >= 7 } { 
VERBATIM {
DFM_5_M7 {
@ Maximum parallel run length of parallel metal(M7) lines with minimum spacing is 25
@ Designer can waive the violations if design passes sign-off level signal integrity check
@ DRC doesn't check MOMDMY covered MOM region.
   MINM7_para = EXT M7 == 0.10 OPPOSITE REGION PARA ONLY
   X = LENGTH MINM7_para > 25
   ((M7 WITH EDGE X) NOT MOMDMY) NOT INSIDE EXDFM
}
}


if { [expr $total_metal - $top_metal ] >= 8 } { 
VERBATIM {
DFM_5_M8 {
@ Maximum parallel run length of parallel metal(M8) lines with minimum spacing is 25
@ Designer can waive the violations if design passes sign-off level signal integrity check
@ DRC doesn't check MOMDMY covered MOM region.
   MINM8_para = EXT M8 == 0.10 OPPOSITE REGION PARA ONLY
   X = LENGTH MINM8_para > 25
   ((M8 WITH EDGE X) NOT MOMDMY) NOT INSIDE EXDFM
}
}
}
}
}
}
}

VERBATIM {
DFM_19a {
@ Min. AA pattern density is 30%
   (DENSITY AA_all < 0.30 WINDOW 200 STEP 100 BACKUP PRINT density_report_DFM19a.log) NOT INSIDE EXDFM
}
DFM_19b {
@ Max. AA pattern density is 70%
   (DENSITY AA_all > 0.70 WINDOW 200 STEP 100 BACKUP PRINT density_report_DFM19b.log) NOT INSIDE EXDFM
}
DFM_20a {
@ Min. GT pattern density is 15%
   (DENSITY GT_all < 0.15 WINDOW 200 STEP 100 BACKUP PRINT density_report_DFM20a.log) NOT INSIDE EXDFM
}
DFM_20b {
@ Max. GT pattern density is 65%
   (DENSITY GT_all > 0.65 WINDOW 200 STEP 100 BACKUP PRINT density_report_DFM20b.log) NOT INSIDE EXDFM
}
DFM_21 {
@ For parallel long NW (length >50um), must make one or both NW width >=1.07um or NW space >=1.07um.
   X1 = EXT NW_dfm < 1.07 OPPOSITE REGION PARA ONLY
   X2 = LENGTH X1 > 50
   X3 = EXPAND EDGE X2 OUTSIDE BY 1.07
   X4 = X3 NOT INTERACT (X3 NOT NW_dfm)
   X5 = INT X2 < 1.07 REGION
   (X5 NOT INTERACT X4) NOT INSIDE EXDFM
}
DFM_104 {
@ M1 enclosure of CT when M1 enclosure on one or both perpendicular directions < 0.035um is 0.035
  X = RECTANGLE ENC (CT NOT TOUCH M1) M1 ABUT<90 OUTSIDE ALSO
  GOOD 0 0.035 OPPOSITE 0 0.035 OPPOSITE
  (X NOT INSIDE INST) NOT INSIDE EXDFM
  ((CT NOT M1) NOT INSIDE INST) NOT INSIDE EXDFM
}
}
}

if { [string equal $DFM_except_Priority1 YES] ==1 } {
VERBATIM {
DFM_6 {
@ Single CT enclosure by M1 is 0.005
  M1AA=(M1_dfm AND AA) INTERACT CT == 1
  M1GT=(M1_dfm AND GT) INTERACT CT == 1
  (ENC CT_dfm M1AA < 0.005 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
  (ENC CT_dfm M1GT < 0.005 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}
DFM_9_V2 {
@ DFM9_V2
@ Single Vn enclosure by Mn is 0.025
   X = (M2_dfm AND SV2_metal) COIN EDGE M2
   (ENC V2_dfm X < 0.025 ABUT <90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 4 } { 
VERBATIM {
DFM_9_V3 {
@ DFM9_V3
@ Single Vn enclosure by Mn is 0.025
   X = (M3 AND SV3_metal) COIN EDGE M3
   (ENC V3 X < 0.025 ABUT <90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 5 } {
VERBATIM {
DFM_9_V4 {
@ DFM9_V4
@ Single Vn enclosure by Mn is 0.025
   X = (M4 AND SV4_metal) COIN EDGE M4
   (ENC V4 X < 0.025 ABUT <90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 6 } {
VERBATIM {
DFM_9_V5 {
@ DFM9_V5
@ Single Vn enclosure by Mn is 0.025
   X = (M5 AND SV5_metal) COIN EDGE M5
   (ENC V5 X < 0.025 ABUT <90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 7 } {
VERBATIM {
DFM_9_V6 {
@ DFM9_V6
@ Single Vn enclosure by Mn is 0.025
   X = (M6 AND SV6_metal) COIN EDGE M6
   (ENC V6 X < 0.025 ABUT <90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 8 } {
VERBATIM {
DFM_9_V7 {
@ DFM9_V7
@ Single Vn enclosure by Mn is 0.025
   X = (M7 AND SV7_metal) COIN EDGE M7
   (ENC V7 X < 0.025 ABUT <90 REGION) NOT INSIDE EXDFM
}
}
}
}
}
}
}

VERBATIM {
DFM_10_V1 {
@ DFM10_V1
@ Mn line end outside of Vn is 0.04
   V1M1LE = CONVEX EDGE M1_dfm ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V1_dfm V1M1LE < 0.04 OPPOSITE REGION) NOT INSIDE EXDFM
}
DFM_10_V2 {
@ DFM10_V2
@ Mn line end outside of Vn is 0.04
   V2M2LE = CONVEX EDGE M2_dfm ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V2_dfm V2M2LE < 0.04 OPPOSITE REGION) NOT INSIDE EXDFM
}
}


if { [expr $total_metal - $top_metal ] >= 4 } { 
VERBATIM {
DFM_10_V3 {
@ DFM10_V3
@ Mn line end outside of Vn is 0.04
   V3M3LE = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V3 V3M3LE  < 0.04 OPPOSITE REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 5 } {
VERBATIM {
DFM_10_V4 {
@ DFM10_V4
@ Mn line end outside of Vn is 0.04
   V4M4LE = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V4 V4M4LE < 0.04 OPPOSITE REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 6 } {
VERBATIM {
DFM_10_V5 {
@ DFM10_V5
@ Mn line end outside of Vn is 0.04
   V5M5LE = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V5 V5M5LE  < 0.04 OPPOSITE REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 7 } {
VERBATIM {
DFM_10_V6 {
@ DFM10_V6
@ Mn line end outside of Vn is 0.04
   V6M6LE = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V6 V6M6LE < 0.04 OPPOSITE REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 8 } {
VERBATIM {
DFM_10_V7 {
@ DFM10_V7
@ Mn line end outside of Vn is 0.04
   V7M7LE = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V7 V7M7LE < 0.04 OPPOSITE REGION) NOT INSIDE EXDFM
}
}
}
}
}
}
}

VERBATIM {
DFM_11_V1 {
@ DFM11_V1
@ Single Vn enclosure by Mn+1 is 0.025
   X = (M2_dfm AND SV1_metal) COIN EDGE M2
   (ENC V1_dfm X < 0.025 ABUT<90 REGION) NOT INSIDE EXDFM
}
DFM_11_V2 {
@ DFM11_V2
@ Single Vn enclosure by Mn+1 is 0.025
   X = (M3 AND SV2_metal) COIN EDGE M3
   (ENC V2_dfm X < 0.025 ABUT<90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 4 } { 
VERBATIM {
DFM_11_V3 {
@ DFM11_V3
@ Single Vn enclosure by Mn+1 is 0.025
   X = (M4 AND SV3_metal) COIN EDGE M4
   (ENC V3 X < 0.025 ABUT<90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 5 } {
VERBATIM {
DFM_11_V4 {
@ DFM11_V4
@ Single Vn enclosure by Mn+1 is 0.025
   X = (M5 AND SV4_metal) COIN EDGE M5
   (ENC V4 X < 0.025 ABUT<90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 6 } {
VERBATIM {
DFM_11_V5 {
@ DFM11_V5
@ Single Vn enclosure by Mn+1 is 0.025
   X = (M6 AND SV5_metal) COIN EDGE M6
   (ENC V5 X < 0.025 ABUT<90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 7 } {
VERBATIM {
DFM_11_V6 {
@ DFM11_V6
@ Single Vn enclosure by Mn+1 is 0.025
   X = (M7 AND SV6_metal) COIN EDGE M7
   (ENC V6 X < 0.025 ABUT<90 REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 8 } {
VERBATIM {
DFM_11_V7 {
@ DFM11_V7
@ Single Vn enclosure by Mn+1 is 0.025
   X = (M8 AND SV7_metal) COIN EDGE M8
   (ENC V7 X < 0.025 ABUT<90 REGION) NOT INSIDE EXDFM
}
}
}
}
}
}
}

VERBATIM {
DFM_12_V1 {
@ DFM12_V1
@ Mn+1 line end extension outside of Vn is 0.03
   V1M2LE = CONVEX EDGE M2_dfm ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V1_dfm V1M2LE < 0.03 OPPOSITE REGION) NOT INSIDE EXDFM
}
DFM_12_V2 {
@ DFM12_V2
@ Mn+1 line end extension outside of Vn is 0.03
   V2M3LE = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V2_dfm V2M3LE < 0.03 OPPOSITE REGION) NOT INSIDE EXDFM
}
}


if { [expr $total_metal - $top_metal ] >= 4 } { 
VERBATIM {
DFM_12_V3 {
@ DFM12_V3
@ Mn+1 line end extension outside of Vn is 0.03
   V3M4LE = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V3 V3M4LE < 0.03 OPPOSITE REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 5 } {
VERBATIM {
DFM_12_V4 {
@ DFM12_V4
@ Mn+1 line end extension outside of Vn is 0.03
   V4M5LE = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V4 V4M5LE < 0.03 OPPOSITE REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 6 } {
VERBATIM {
DFM_12_V5 {
@ DFM12_V5
@ Mn+1 line end extension outside of Vn is 0.03
   V5M6LE = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V5 V5M6LE < 0.03 OPPOSITE REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 7 } {
VERBATIM {
DFM_12_V6 {
@ DFM12_V6
@ Mn+1 line end extension outside of Vn is 0.03
   V6M7LE = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V6 V6M7LE < 0.03 OPPOSITE REGION) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 8 } {
VERBATIM {
DFM_12_V7 {
@ DFM12_V7
@ Mn+1 line end extension outside of Vn is 0.03
   V7M8LE = CONVEX EDGE M8 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.18 LENGTH1 > 0.18 LENGTH2 > 0.18
   (ENC V7 V7M8LE < 0.03 OPPOSITE REGION) NOT INSIDE EXDFM
}
}
}
}
}
}
}

VERBATIM {
DFM_13_M1 {
@ DFM13_M1
@ Metal small jog/notch 50nm
   X = CONVEX EDGE M1_dfm ANGLE1 == 90 ANGLE2 == 270
   Y = INT X > 0.085 < 0.15 OPPOSITE REGION PARA ONLY
   Z = LENGTH Y < 0.09
   A = Y WITH EDGE Z
   B = CONVEX EDGE M1_dfm ANGLE1 == 90 ANGLE2 == 90
   (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
DFM_13_M2 {
@ DFM13_M2
@ Metal small jog/notch 50nm
   X = CONVEX EDGE M2_dfm ANGLE1 == 90 ANGLE2 == 270
   Y = INT X > 0.095 < 0.15 OPPOSITE REGION PARA ONLY
   Z = LENGTH Y < 0.10
   A = Y WITH EDGE Z
   B = CONVEX EDGE M2_dfm ANGLE1 == 90 ANGLE2 == 90
   (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
DFM_13_M3 {
@ DFM13_M3
@ Metal small jog/notch 50nm
   X = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 270
   Y = INT X > 0.095 < 0.15 OPPOSITE REGION PARA ONLY
   Z = LENGTH Y < 0.10
   A = Y WITH EDGE Z
   B = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90
   (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 4 } { 
VERBATIM {
DFM_13_M4 {
@ DFM13_M4
@ Metal small jog/notch 50nm
   X = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 270
   Y = INT X > 0.095 < 0.15 OPPOSITE REGION PARA ONLY
   Z = LENGTH Y < 0.10
   A = Y WITH EDGE Z
   B = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90
   (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
}


if { [expr $total_metal - $top_metal ] >= 5 } { 
VERBATIM {
DFM_13_M5 {
@ DFM13_M5
@ Metal small jog/notch 50nm
   X = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 270
   Y = INT X > 0.095 < 0.15 OPPOSITE REGION PARA ONLY
   Z = LENGTH Y < 0.10
   A = Y WITH EDGE Z
   B = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90
   (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 6 } { 
VERBATIM {
DFM_13_M6 {
@ DFM13_M6
@ Metal small jog/notch 50nm
   X = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 270
   Y = INT X > 0.095 < 0.15 OPPOSITE REGION PARA ONLY
   Z = LENGTH Y < 0.10
   A = Y WITH EDGE Z
   B = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 90
   (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 7 } { 
VERBATIM {
DFM_13_M7 {
@ DFM13_M7
@ Metal small jog/notch 50nm
   X = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 270
   Y = INT X > 0.095 < 0.15 OPPOSITE REGION PARA ONLY
   Z = LENGTH Y < 0.10
   A = Y WITH EDGE Z
   B = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 90
   (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
}

if { [expr $total_metal - $top_metal ] >= 8 } { 
VERBATIM {
DFM_13_M8 {
@ DFM13_M8
@ Metal small jog/notch 50nm
   X = CONVEX EDGE M8 ANGLE1 == 90 ANGLE2 == 270
   Y = INT X > 0.095 < 0.15 OPPOSITE REGION PARA ONLY
   Z = LENGTH Y < 0.10
   A = Y WITH EDGE Z
   B = CONVEX EDGE M8 ANGLE1 == 90 ANGLE2 == 90
   (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
}
}
}
}
}
}

if { ($STM1_STV1 == 0) && ($STM2_STV2 == 0) && ($top_metal == 2) } {
RULECHECK DFM_13_TM1 {
@ DFM13_TM1
@ Metal small jog/notch 50nm
  SETLAYER X = CONVEX EDGE TM1 ANGLE1 == 90 ANGLE2 == 270
  SETLAYER Y = INT X > 0.395 < 0.45 OPPOSITE REGION PARA ONLY
  SETLAYER Z = LENGTH Y < 0.40
  SETLAYER A = Y WITH EDGE Z
  SETLAYER B = CONVEX EDGE TM1 ANGLE1 == 90 ANGLE2 == 90
  OUTLAYER (A NOT WITH EDGE B) NOT INSIDE EXDFM
}
}

VERBATIM {
/*
DFM15 {
@ DFM15
   A = CONVEX EDGE M1_dfm ANGLE1 == 90 ANGLE2 == 90 LENGTH1 >= 0.1 < 0.12 LENGTH2 >= 0.1 < 0.12 WITH LENGTH < 0.16
   A1 = EXPAND EDGE A INSIDE BY 0.001
   B = CONVEX EDGE M1_dfm ANGLE1 == 90 ANGLE2 == 270
   B2 = EXPAND EDGE B OUTSIDE BY 0.001
   (A1 INTERACT B2 == 2) NOT INSIDE EXDFM
}
*/

OUTERCORNER = EXT M1_dfm <= 0.002 ABUT == 90 INTERSECTING ONLY REGION
INNERCORNER = INT M1_dfm <= 0.002 ABUT == 90 INTERSECTING ONLY REGION
CORNERALL = INNERCORNER OR OUTERCORNER
LINEEND = CONVEX EDGE M1_dfm ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < 0.15
DFM_18 {
@ DFM18
   A = CONVEX EDGE M1_dfm ANGLE1 == 90 ANGLE2 == 90 LENGTH1 > 0.12 LENGTH2 > 0.21 WITH LENGTH >= 0.12 < 0.20
   B = INNERCORNER WITH EDGE A
   B_edge = B COIN EDGE M1_dfm
   C = M1_dfm TOUCH EDGE B_edge
   C1 = EXPAND EDGE C INSIDE BY 0.001
   C2 = C1 INTERACT INNERCORNER >= 2 <= 3
   C3 = C2 TOUCH OUTERCORNER >= 1 <= 2
   C3_edge = C3 COIN EDGE M1_dfm
   C4 = A TOUCH EDGE C3_edge
   C5 = EXPAND EDGE C4 INSIDE BY 0.001

   D  = CONVEX EDGE M1_dfm ANGLE1 == 270 ANGLE2 == 270 LENGTH1 > 0.12 LENGTH2 > 0.12 WITH LENGTH >= 0.12
   D1 = OUTERCORNER WITH EDGE D
   D1_edge = D1 COIN EDGE M1_dfm
   D2 = M1_dfm TOUCH EDGE D1_edge
   D3 = EXPAND EDGE D2 OUTSIDE BY 0.001
   D4 = D3 INTERACT OUTERCORNER == 2
   D5 = D4 TOUCH INNERCORNER == 2

   E1 = C5 TOUCH D5
   E2 = E1 OR D5
   E2_edge = E2 COIN EDGE M1_dfm
   E = M1_dfm TOUCH EDGE E2
  (EXT E (M1_dfm TOUCH EDGE B_edge)< 0.12 OPPOSITE REGION) NOT INSIDE EXDFM
}
/*
DFM22_TV1 {
@ Min space between TVs within array greater or equal to 3x3 is 0.54um;
@ Two via regions whose space is <= 0.56um are considered to be in the same array.
  X = SIZE TV1 BY 0.28 OVERUNDER
  Y = SIZE X BY 0.85 UNDEROVER
  Z = TV1 INSIDE Y
  (EXT Z < 0.54 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}
DFM22_TV2 {
@ Min space between TVs within array greater or equal to 3x3 is 0.54um;
@ Two via regions whose space is <= 0.56um are considered to be in the same array.
  X = SIZE TV2 BY 0.28 OVERUNDER
  Y = SIZE X BY 0.85 UNDEROVER
  Z = TV2 INSIDE Y
  (EXT Z < 0.54 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}*/
DFM_23 {
@ Space between 1.0/1.2V NWs at different net is 1um
  X = (EXT LVNW0 < 1 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES
  (X NOT INSIDE INST) NOT INSIDE EXDFM
 
  Y = EXT LVNW_RE LVNW < 1 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_24 {
@ Space between 1.0/1.2V NW and 1.8/2.5/3.3V NW is 1.2um
  X1 = EXT LVNW0 HVNW0 < 1.2  ABUT<90 SINGULAR REGION NOT CONNECTED
  (X1 NOT INSIDE INST) NOT INSIDE EXDFM

  X2 = EXT LVNW0 MVNW0 < 1.2  ABUT<90 SINGULAR REGION NOT CONNECTED
  (X2 NOT INSIDE INST) NOT INSIDE EXDFM

  X3 = EXT LVNW_RE MVNW < 1.2 REGION
  (X3 NOT INSIDE INST) NOT INSIDE EXDFM
  X4 = EXT LVNW_RE HVNW < 1.2 REGION
  (X4 NOT INSIDE INST) NOT INSIDE EXDFM
  X5 = EXT MVNW_RE LVNW < 1.2 REGION
  (X5 NOT INSIDE INST) NOT INSIDE EXDFM
  X6 = EXT HVNW_RE LVNW < 1.2 REGION
  (X6 NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_25 {
@ Space between 1.8/2.5/3.3V NW at different nets. (LDMOS is excluded for this rule check). >= 1.2um
  X1 = (EXT MVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES
  (X1 NOT INSIDE (INST OR LDBK)) NOT INSIDE EXDFM
  X2 = (EXT HVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES
  (X2 NOT INSIDE (INST OR LDBK)) NOT INSIDE EXDFM
  X3 = EXT MVNW0 HVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED
  (X3 NOT INSIDE (INST OR LDBK)) NOT INSIDE EXDFM

  X4 = EXT MVNW_RE MVNW < 1.2 REGION
  (X4 NOT INSIDE (INST OR LDBK)) NOT INSIDE EXDFM
  X5 = EXT HVNW_RE HVNW < 1.2 REGION
  (X5 NOT INSIDE (INST OR LDBK)) NOT INSIDE EXDFM
  X6 = EXT MVNW_RE HVNW < 1.2 REGION
  (X6 NOT INSIDE (INST OR LDBK)) NOT INSIDE EXDFM
  X7 = EXT HVNW_RE MVNW < 1.2 REGION
  (X7 NOT INSIDE (INST OR LDBK)) NOT INSIDE EXDFM
}
DFM_26a {
@ Channel width for 1.0/1.2V NMOS/PMOS transistors >= 0.12um.
  Y = LENGTH GATE_M_W < 0.12
  ((EXPAND EDGE Y INSIDE BY 0.001) NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_26b {
@ Channel width for 1.8/2.5/3.3V NMOS/PMOS transistors >= 0.4um.
  X = GATE AND DGTG
  Y = GT COIN EDGE X
  Z = LENGTH Y < 0.4
  ((EXPAND EDGE Z INSIDE BY 0.001) NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_27a {
@ Space between AAs that are on the same well >= 0.11um.
  (EXT AA < 0.11 ABUT<90 SINGULAR REGION ) NOT INSIDE EXDFM
}
DFM_27b {
@ Space between AAs with one or both AA width greater than 0.15um that are on the same wel >= 0.13um.
  X = AA WITH WIDTH > 0.15
  (EXT X AA < 0.13 SINGULAR REGION) NOT INSIDE EXDFM
}
DFM_28 {
@ N+AA enclosure by NW >= 0.16um.
  ((ENC NACT (NW NOT INTERACT RESNW) < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_29 {
@ Space between NW and N+AA >= 0.16um.
  ((EXT (NW NOT INTERACT RESNW) (NACT INSIDE PW) < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_30 {
@ P+AA enclosure by NW >= 0.16um.
  ((ENC PACT NW < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_31 {
@ Space between NW to P+AA inside PW >= 0.16um.
  X = EXT NW (((PACT NOT NW) NOT PSUB) NOT LDBK) < 0.16 ABUT<90 SINGULAR REGION
  (X NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_32 {
@ AA area (in um2) >= 0.054
   ((AREA AA < 0.054) NOT INSIDE INST) NOT INSIDE EXDFM
}
DFM_33 {
@ NW width >= 0.47um.
  (INT NW < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}
DFM_34 {
@ Space between 1.0/1.2V NWs at same potential >= 0.47um.
  ((EXT LVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE NW_RES) NOT INSIDE EXDFM
}
DFM_35 {
@ Space between 1.0/1.2V NWs at different potential. >= 1 um
  ((EXT LVNW0 < 1 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE NW_RES) NOT INSIDE EXDFM
   (EXT LVNW_RE LVNW < 1 REGION) NOT INSIDE EXDFM
}
DFM_36 {
@ Space between 1.0/1.2V NW and 1.8/2.5/3.3V NW >= 1.2 um
(EXT LVNW0 HVNW0 < 1.2  ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE EXDFM
(EXT LVNW0 MVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE EXDFM
(EXT LVNW_RE MVNW < 1.2  REGION) NOT INSIDE EXDFM
(EXT LVNW_RE HVNW < 1.2  REGION) NOT INSIDE EXDFM
(EXT MVNW_RE LVNW < 1.2 REGION) NOT INSIDE EXDFM
(EXT HVNW_RE LVNW < 1.2 REGION) NOT INSIDE EXDFM
}

DFM_37 {
@ Space between 1.8/2.5/3.3V NWs >= 1.2 um
((EXT MVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE EXDFM
((EXT HVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE EXDFM
(EXT MVNW0 HVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE EXDFM

(EXT MVNW_RE MVNW < 1.2 REGION) NOT INSIDE EXDFM
(EXT HVNW_RE HVNW < 1.2 REGION) NOT INSIDE EXDFM
(EXT MVNW_RE HVNW < 1.2 REGION) NOT INSIDE EXDFM
(EXT HVNW_RE MVNW < 1.2 REGION) NOT INSIDE EXDFM
}

DFM_38 {
@ NW area (um2) >= 1.2 um
 (AREA NW < 1.2) NOT INSIDE EXDFM
}

DFM_39 {
@ PSUB width >= 0.47 um
 (INT PSUB < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}
}
if { $IO == 1825 } {
RULECHECK DFM_40a {
@ 2.5V (or overdrive to 3.3V) NMOS channel length >= 1.2 um
SETLAYER X = PBGT INSIDE EDGE (PBAA INTERACT TG)
OUTLAYER (INT X < 1.2 ABUT<90 REGION) NOT INSIDE EXDFM
}
}
if { $IO == 1833 } {
RULECHECK DFM_40b {
@ 3.3V NMOS channel length >= 1.5 um
SETLAYER X = PBGT INSIDE EDGE (PBAA INTERACT TG)
OUTLAYER (INT X < 1.5 ABUT<90 REGION) NOT INSIDE EXDFM
}
}

VERBATIM {
DFM_41 {
@ Space between PSUBs with same potential >= 0.47 um
 (EXT PSUB < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_42 {
@ MOS AA enclosure by PSUB = 0.26 um
 X = SIZE (PBMOS NOT INTERACT CAPBP) BY 0.26
 Y = PSUB INTERACT PBMOS
 Z = NMOS INTERACT CAPBP
 ((XOR X Y) NOT INTERACT Z) NOT INSIDE EXDFM
}

DFM_43 {
@ Extension of native NMOS poly gate outside of AA >= 0.35 um
//X = PBAA INSIDE EDGE PBGT
((ENC PBAA PBGT < 0.35 ABUT<90 REGION OPPOSITE) NOT INSIDE INDMY) NOT INSIDE EXDFM
}

DFM_44 {
@ VTNH extension outside of MOS AA along gate poly length direction. >= 0.16 um
 GATE_VTNH4_E = GATE COIN EDGE GT

  GATE_VTNH4_E_V = ANGLE GATE_VTNH4_E == 90
  GATE_VTNH4_B_V = EXPAND EDGE GATE_VTNH4_E_V INSIDE BY 0.001
  MOS_AA_H = AA ENCLOSE GATE_VTNH4_B_V
  MOS_AA_H_E = ANGLE MOS_AA_H == 0
  ((ENC MOS_AA_H_E VTNH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM

  GATE_VTNH4_E_H = ANGLE GATE_VTNH4_E == 0
  GATE_VTNH4_B_H = EXPAND EDGE GATE_VTNH4_E_H INSIDE BY 0.001
  MOS_AA_V = AA ENCLOSE GATE_VTNH4_B_H
  MOS_AA_V_E = ANGLE MOS_AA_V == 90
  ((ENC MOS_AA_V_E VTNH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_45 {
@ Space between VTNH and MOS AA of other device along other device's gate poly length direction >= 0.16 um
 GATE_VTNH5_E = GATE COIN EDGE GT

  GATE_VTNH5_E_V = ANGLE GATE_VTNH5_E == 90
  GATE_VTNH5_B_V = EXPAND EDGE GATE_VTNH5_E_V INSIDE BY 0.001
  MOS_AA_H = AA ENCLOSE GATE_VTNH5_B_V
  MOS_AA_H_E = ANGLE MOS_AA_H == 0
  ((EXT MOS_AA_H_E VTNH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM

  GATE_VTNH5_E_H = ANGLE GATE_VTNH5_E == 0
  GATE_VTNH5_B_H = EXPAND EDGE GATE_VTNH5_E_H INSIDE BY 0.001
  MOS_AA_V = AA ENCLOSE GATE_VTNH5_B_H
  MOS_AA_V_E = ANGLE MOS_AA_V == 90
  ((EXT MOS_AA_V_E VTNH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM

//FOR LDMOS
  GATE_VTNH5_E_LD = GT_LDMOS COIN EDGE GT

  GATE_VTNH5_E_V_LD = ANGLE GATE_VTNH5_E_LD == 90
  GATE_VTNH5_B_V_LD = EXPAND EDGE GATE_VTNH5_E_V_LD INSIDE BY 0.001
  MOS_AA_H_LD = (AA ENCLOSE GATE_VTNH5_B_V_LD) OR (AA INTERACT (STIDMY INTERACT (AA ENCLOSE GATE_VTNH5_B_V_LD)))
  MOS_AA_H_E_LD = ANGLE MOS_AA_H_LD == 0
  ((EXT MOS_AA_H_E_LD VTNH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM

  GATE_VTNH5_E_H_LD = ANGLE GATE_VTNH5_E_LD == 0
  GATE_VTNH5_B_H_LD = EXPAND EDGE GATE_VTNH5_E_H_LD INSIDE BY 0.001
  MOS_AA_V_LD = (AA ENCLOSE GATE_VTNH5_B_H_LD) OR (AA INTERACT (STIDMY INTERACT (AA ENCLOSE GATE_VTNH5_B_H_LD)))
  MOS_AA_V_E_LD = ANGLE MOS_AA_V_LD == 90
  ((EXT MOS_AA_V_E_LD VTNH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_46 {
@ VTNH area >= 0.27 um 
 X = AREA VTNH < 0.27
 (X NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_47 {
@ VTPH extension outside of MOS AA along gate poly length direction. >= 0.16 um
 GATE_VTPH4_E = GATE COIN EDGE GT

  GATE_VTPH4_E_V = ANGLE GATE_VTPH4_E == 90
  GATE_VTPH4_B_V = EXPAND EDGE GATE_VTPH4_E_V INSIDE BY 0.001
  MOS_AA_H = AA ENCLOSE GATE_VTPH4_B_V
  MOS_AA_H_E = ANGLE MOS_AA_H == 0
  ((ENC MOS_AA_H_E VTPH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM

  GATE_VTPH4_E_H = ANGLE GATE_VTPH4_E == 0
  GATE_VTPH4_B_H = EXPAND EDGE GATE_VTPH4_E_H INSIDE BY 0.001
  MOS_AA_V = AA ENCLOSE GATE_VTPH4_B_H
  MOS_AA_V_E = ANGLE MOS_AA_V == 90
  ((ENC MOS_AA_V_E VTPH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_48 {
@ Space between VTPH and MOS AA of other device along other device's gate poly length direction >= 0.16 um
  GATE_VTPH5_E = GATE COIN EDGE GT

  GATE_VTPH5_E_V = ANGLE GATE_VTPH5_E == 90
  GATE_VTPH5_B_V = EXPAND EDGE GATE_VTPH5_E_V INSIDE BY 0.001
  MOS_AA_H = AA ENCLOSE GATE_VTPH5_B_V
  MOS_AA_H_E = ANGLE MOS_AA_H == 0
  ((EXT MOS_AA_H_E VTPH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM

  GATE_VTPH5_E_H = ANGLE GATE_VTPH5_E == 0
  GATE_VTPH5_B_H = EXPAND EDGE GATE_VTPH5_E_H INSIDE BY 0.001
  MOS_AA_V = AA ENCLOSE GATE_VTPH5_B_H
  MOS_AA_V_E = ANGLE MOS_AA_V == 90
  ((EXT MOS_AA_V_E VTPH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM

//FOR LDMOS
  GATE_VTPH5_E_LD = GT_LDMOS COIN EDGE GT

  GATE_VTPH5_E_V_LD = ANGLE GATE_VTPH5_E_LD == 90
  GATE_VTPH5_B_V_LD = EXPAND EDGE GATE_VTPH5_E_V_LD INSIDE BY 0.001
  MOS_AA_H_LD = (AA ENCLOSE GATE_VTPH5_B_V_LD) OR (AA INTERACT (STIDMY INTERACT (AA ENCLOSE GATE_VTPH5_B_V_LD)))
  MOS_AA_H_E_LD = ANGLE MOS_AA_H_LD == 0
  ((EXT MOS_AA_H_E_LD VTPH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM

  GATE_VTPH5_E_H_LD = ANGLE GATE_VTPH5_E_LD == 0
  GATE_VTPH5_B_H_LD = EXPAND EDGE GATE_VTPH5_E_H_LD INSIDE BY 0.001
  MOS_AA_V_LD = (AA ENCLOSE GATE_VTPH5_B_H_LD) OR (AA INTERACT (STIDMY INTERACT (AA ENCLOSE GATE_VTPH5_B_H_LD)))
  MOS_AA_V_E_LD = ANGLE MOS_AA_V_LD == 90
  ((EXT MOS_AA_V_E_LD VTPH < 0.16 ABUT < 90 REGION) NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_49 {
@ VTPH area >= 0.27 um
  X = AREA VTPH < 0.27
  (X NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_50 {
@ LVN extension outside of MOS AA along gate poly length direction. >= 0.16 um
  GATE_LVN4_E = GATE COIN EDGE GT

  GATE_LVN4_E_V = ANGLE GATE_LVN4_E == 90
  GATE_LVN4_B_V = EXPAND EDGE GATE_LVN4_E_V INSIDE BY 0.001
  MOS_AA_H = AA ENCLOSE GATE_LVN4_B_V
  MOS_AA_H_E = ANGLE MOS_AA_H == 0
  (ENC MOS_AA_H_E LVN < 0.16 ABUT < 90 REGION) NOT INSIDE EXDFM

  GATE_LVN4_E_H = ANGLE GATE_LVN4_E == 0
  GATE_LVN4_B_H = EXPAND EDGE GATE_LVN4_E_H INSIDE BY 0.001
  MOS_AA_V = AA ENCLOSE GATE_LVN4_B_H
  MOS_AA_V_E = ANGLE MOS_AA_V == 90
  (ENC MOS_AA_V_E LVN < 0.16 ABUT < 90 REGION) NOT INSIDE EXDFM
}

DFM_51 {
@ Space between LVN and MOS AA of other device along other device's gate poly length direction >= 0.16 um
  GATE_LVN5_E = GATE COIN EDGE GT

  GATE_LVN5_E_V = ANGLE GATE_LVN5_E == 90
  GATE_LVN5_B_V = EXPAND EDGE GATE_LVN5_E_V INSIDE BY 0.001
  MOS_AA_H = AA ENCLOSE GATE_LVN5_B_V
  MOS_AA_H_E = ANGLE MOS_AA_H == 0
  (EXT MOS_AA_H_E LVN < 0.16 ABUT < 90 REGION) NOT INSIDE EXDFM

  GATE_LVN5_E_H = ANGLE GATE_LVN5_E == 0
  GATE_LVN5_B_H = EXPAND EDGE GATE_LVN5_E_H INSIDE BY 0.001
  MOS_AA_V = AA ENCLOSE GATE_LVN5_B_H
  MOS_AA_V_E = ANGLE MOS_AA_V == 90
  (EXT MOS_AA_V_E LVN < 0.16 ABUT < 90 REGION ) NOT INSIDE EXDFM 

//FOR LDMOS
  GATE_LVN5_E_LD = GT_LDMOS COIN EDGE GT

  GATE_LVN5_E_V_LD = ANGLE GATE_LVN5_E_LD == 90
  GATE_LVN5_B_V_LD = EXPAND EDGE GATE_LVN5_E_V_LD INSIDE BY 0.001
  MOS_AA_H_LD = (AA ENCLOSE GATE_LVN5_B_V_LD) OR (AA INTERACT (STIDMY INTERACT (AA ENCLOSE GATE_LVN5_B_V_LD)))
  MOS_AA_H_E_LD = ANGLE MOS_AA_H_LD == 0
  (EXT MOS_AA_H_E_LD LVN < 0.16 ABUT < 90 REGION) NOT INSIDE EXDFM

  GATE_LVN5_E_H_LD = ANGLE GATE_LVN5_E_LD == 0
  GATE_LVN5_B_H_LD = EXPAND EDGE GATE_LVN5_E_H_LD INSIDE BY 0.001
  MOS_AA_V_LD = (AA ENCLOSE GATE_LVN5_B_H_LD) OR (AA INTERACT (STIDMY INTERACT (AA ENCLOSE GATE_LVN5_B_H_LD)))
  MOS_AA_V_E_LD = ANGLE MOS_AA_V_LD == 90
  (EXT MOS_AA_V_E_LD LVN < 0.16 ABUT < 90 REGION) NOT INSIDE EXDFM
}

DFM_52 {
@ LVN area >= 0.27 um
 (AREA LVN < 0.27) NOT INSIDE EXDFM
}

DFM_53 {
@ Space between DG and MOS AA >= 0.27 um
 (EXT DG MOS < 0.27 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
 (EXT DG AA_LDMOS < 0.27 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_54 {
@ Space between DG and transistor gate poly (1.2/2.5/3.3) along source/drain direction. >= 0.27 um
 X = (GATE_M OR GATE_T) INSIDE EDGE AA
 (EXT DG X < 0.27 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDFM
}

DFM_56 {
@ Space between TG and MOS AA >= 0.27 um
 (EXT TG MOS < 0.27 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_57 {
@ Space between TG and 1.2/1.8V transistor gate poly along source/drain direction. >= 0.27 um
 X = (GT NOT TG) INSIDE EDGE AA
 (EXT TG X < 0.27 ABUT<90 REGION INSIDE ALSO) NOT INSIDE EXDFM
}

DFM_59a {
@ Space between GTs in core device region >= 0.13 um
 X = (EXT GT < 0.13 ABUT<90 SINGULAR REGION) NOT INSIDE DGTG
 (X NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDFM
}

DFM_59b {
@ Space between GTs when one or both GT width > 0.09um in core device region >= 0.15 um
 X = GT WITH WIDTH > 0.09
 Y = (EXT GT X < 0.15 SINGULAR REGION) NOT INSIDE DGTG
 (Y NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDFM
}

DFM_59c {
@ Space between GTs in IO device region >= 0.25 um
 X = (EXT GT < 0.25 ABUT<90 SINGULAR REGION) INSIDE DG
 (X NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDFM
}


DFM_60 {
@ Space between AA and GT on field oxide >= 0.1um when channel width < 0.15um.
GT_check = GT WITH EDGE (LENGTH GATE_W < 0.15)
X = EXT AA GT_check < 0.1 ABUT<90 SINGULAR REGION
((X NOT INSIDE (AA OR AADUM)) NOT INSIDE (INST OR INDMY)) NOT INSIDE EXDFM
}


DFM_61 {
@ Extension of AA outside of GT (not include dummy AA and dummy Poly) >= 0.18 um
X = ENC GT (AA NOT COIN EDGE STIDMY) < 0.18 ABUT<90 REGION OPPOSITE
((X NOT INSIDE INST) NOT INSIDE INDMY) NOT INSIDE EXDFM
}


DFM_62 {
@ Min. GT island area >= 0.042 um
  (AREA GT < 0.042) NOT INSIDE EXDFM
}

DFM_63 {
@ LDMOS gate length >= 0.48 um
  (INT LDNGATE < 0.48 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
  (INT LDPGATE < 0.48 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_64 {
@ STI width for LDMOS transistor drain side field plate >= 0.11 um
  (INT STIDMY < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
  (STIDMY ENCLOSE (SIZE STIDMY BY -0.11/2)) NOT INSIDE EXDFM
}

DFM_65 {
@ Overlap of NW and LDNMOS gate >= 0.2 um
  (INT NW LDNGATE < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
  ((LDNGATE AND NW) ENCLOSE (SIZE (LDNGATE AND NW) BY -0.10)) NOT INSIDE EXDFM
}

DFM_66 {
@ Overlap of PW and LDPMOS gate >= 0.2 um
  (ENC NW LDPGATE < 0.20 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
  ((LDPGATE NOT NW) ENCLOSE (SIZE (LDPGATE NOT NW) BY -0.10)) NOT INSIDE EXDFM
}

DFM_67 {
@ GT to STI drain side field plate overlap >= 0 um
  (GT AND STIDMY) NOT INSIDE EXDFM
  ((STIDMY AND LDBK) NOT TOUCH GT) NOT INSIDE EXDFM
}

DFM_68 {
@ Dummy layer STIDMY is required for LDMOS transistor field plate area. 
@ STIDMY enclosure LDMOS drain side filed plate >= 0 um.
  X = STIDMY AND LDAA
  Y = STIDMY NOT TOUCH (LDAA NOT GT)
  (X OR Y) NOT INSIDE EXDFM
}

DFM_69 {
@ Space between SN and P+ AA inside NW >= 0.13 um
  X = (PACT NOT PTAP) NOT TOUCH EDGE SN
  Y = EXT SN X < 0.13 ABUT<90 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_70 {
@ SN extension outside of Poly gate for NMOS along source/drain direction. >= 0.32 um
  X = GATE_W INSIDE EDGE SN
  Y = ENC X SN < 0.32 ABUT<90 OPPOSITE REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_71 {
@ Space between SN and poly gate for PMOS along source/drain direction. >= 0.32 um
  X = GATE_W INSIDE EDGE SP
  Y = EXT X SN < 0.32 ABUT<90 OPPOSITE REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_72 {
@ SN extension outside of NMOS AA along gate poly length direction, if the distance to the related poly is larger than 0.20um >= 0.13 um
  X = NMOS TOUCH EDGE AAEIGT
  Y = ENC X SN < 0.13 ABUT<90 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_73 {
@ SN and AA overlap >= 0.13 um
  (INT SN AA < 0.13 ABUT >0 <90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_74 {
@ SN area (um2) >= 0.122 um
  (AREA SN < 0.122) NOT INSIDE EXDFM
}

DFM_75 {
@ Space between SP and N+ AA inside P well >= 0.13 um
  X = (NACT NOT NTAP) NOT TOUCH EDGE SP
  Y = EXT SP X < 0.13 ABUT<90 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_76 {
@ Space between SP and N-channel poly gate along source/drain direction. >= 0.32 um
  X = GT INSIDE EDGE NACT
  Y = EXT SP X < 0.32 ABUT<90 REGION OPPOSITE
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_77 {
@ SP extension outside of PMOS poly gate along source/drain direction.>= 0.32 um
  X = GATE_W INSIDE EDGE SP
  Y = ENC X SP < 0.32 ABUT<90 OPPOSITE REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_78 {
@ SP extension outside of PMOS AA along gate poly length direction, if the distance to the related poly is larger than 0.20µm >= 0.13 um
  X = PMOS TOUCH EDGE AAEIGT
  Y = ENC X SP < 0.13 ABUT<90 REGION
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_79 {
@ SP and AA overlap >= 0.13 um
  (INT SP (AA NOT TOUCH EDGE SP) < 0.13 ABUT<90 REGION) NOT INSIDE EXDFM
}

DFM_80 {
@ SP area (um2) >= 0.122 um
  (AREA SP < 0.122) NOT INSIDE EXDFM
}

DFM_81 {
@ SAB width >= 0.43 um
  (INT SAB < 0.43 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_82 {
@ Space between SABs >= 0.43 um
  (EXT SAB < 0.43 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_83 {
@ Extension of related AA outside of SAB >= 0.22 um
  (ENC SAB AA < 0.22 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_84 {
@ Space between SAB and AA >= 0.22 um
  (EXT SAB AA < 0.22 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_85 {
@ Space between SAB and GT on AA >= 0.38 um
  (EXT SAB GATE < 0.38 ABUT<90 REGION) NOT INSIDE EXDFM
  ((AND SAB GATE) NOT ESDIO2) NOT INSIDE EXDFM
}

DFM_86 {
@ Extension of SAB outside of poly on field oxide >= 0.22 um
  (ENC (GT NOT (AA OR AADUM)) SAB < 0.22 ABUT<90 REGION) NOT INSIDE EXDFM
}

DFM_87 {
@ Space between SAB and CT >= 0.22 um
  (EXT SAB CT < 0.22 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_88a {
@ Extension of SAB outside of AA >= 0.22 um
  (ENC AA SAB < 0.22 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_88b {
@ Extension of SAB outside of AA when AA width>10um >= 0.3 um
  AA_check = AA WITH WIDTH > 10
  (ENC AA_check SAB < 0.3 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_89 {
@ SAB area (um2) >= 1 um
  (AREA SAB < 1.0) NOT INSIDE EXDFM
}

DFM_90 {
@ Space between SAB and poly on field oxide. >= 0.3 um
  (EXT SAB INTERGT < 0.3 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_91 {
@ Space between two contacts in case contact array is larger or equal to 4x4. Two contact regions whose space is <= 0.15µm are considered to be in the same array. >=0.14 um
  X = SIZE CT BY 0.075 OVERUNDER
  Y = SIZE X BY 0.340 UNDEROVER
  Z = CT INSIDE Y
  (EXT Z < 0.14 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_92 {
@ Space between AA and contact on poly >= 0.07 um
  (EXT CT AA < 0.07 ABUT<90 SINGULAR REGION) NOT INSIDE EXDFM
}

DFM_93a {
@ Space between poly and contact on AA for 1.0V/1.2V >= 0.055 um
  X = EXT GATE_M ACT_CT < 0.055 ABUT<90 SINGULAR REGION 
  (X NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_93b {
@ Space between poly and contact on AA for 1.8/2.5/3.3V >= 0.11 um
  X1 = EXT GATE_D (ACT_CT AND DG) < 0.11 ABUT<90 SINGULAR REGION
  X2 = EXT GATE_T (ACT_CT AND TG) < 0.11 ABUT<90 SINGULAR REGION
  X = X1 OR X2
  (X NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_94 {
@ CT enclosure by AA for CT landed on AA >= 0.06 um
  X = CTN INTERACT AA
  Y = ENC X AA < 0.06 ABUT<90 SINGULAR REGION OUTSIDE ALSO
  (Y NOT INSIDE INST) NOT INSIDE EXDFM
}

DFM_95 {
@ M1 enclosure of CT when the M1 length along CT >= 0.3um is >= 0.035 um
  X = M1 WITH EDGE (LENGTH M1 >= 0.3)
  (ENC (CTN INTERACT X) X < 0.035 ABUT<90 REGION OUTSIDE ALSO) NOT INSIDE EXDFM
}
}

if { [string equal $DFM_Priority1 YES] ==1 } {
RULECHECK DFM_96 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M1ALL 0.501 0.201 0.111
}

RULECHECK DFM_97 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.5um >0.13um
 Mn_2b M1ALL 0.501 0.501 0.131
}


#foreach metal_layer $metal_list {
#RULECHECK DFM_98_${metal_layer} {
#@ Space between two Mns having parallel segment >0.5um with one or both Mn width>0.2um >0.11um
# Mn_2b ${metal_layer}ALL 0.501 0.201 0.111
#}
#}

#RULECHECK DFM_98_M1 {
#@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
#  Mn_2b M1ALL 0.501 0.201 0.111
#}

RULECHECK DFM_98_M2 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M2ALL 0.501 0.201 0.111
}

RULECHECK DFM_98_M3 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M3ALL 0.501 0.201 0.111
}

if { [expr $total_metal - $top_metal ] >= 4 } {
RULECHECK DFM_98_M4 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M4ALL 0.501 0.201 0.111
}

if { [expr $total_metal - $top_metal ] >= 5 } {
RULECHECK DFM_98_M5 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M5ALL 0.501 0.201 0.111
}

if { [expr $total_metal - $top_metal ] >= 6 } { 
RULECHECK DFM_98_M6 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M6ALL 0.501 0.201 0.111
}

if { [expr $total_metal - $top_metal ] >= 7 } {
RULECHECK DFM_98_M7 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M7ALL 0.501 0.201 0.111
}

if { [expr $total_metal - $top_metal ] >= 8 } {
RULECHECK DFM_98_M8 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M8ALL 0.501 0.201 0.111
}
}
}
}
}
}

#foreach metal_layer $metal_list {
#RULECHECK DFM_99_${metal_layer} {
#@ Space between two ${metal_layer} having parallel segment >0.5um with one or both Mn width>0.5um >0.13um
# Mn_2b ${metal_layer}ALL 0.501 0.501 0.131
#}
#}

#RULECHECK DFM_99_M1 {
#@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
#  Mn_2b M1ALL 0.501 0.501 0.131
#}

RULECHECK DFM_99_M2 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M2ALL 0.501 0.501 0.131
}

RULECHECK DFM_99_M3 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M3ALL 0.501 0.501 0.131
}

if { [expr $total_metal - $top_metal ] >= 4 } {
RULECHECK DFM_99_M4 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M4ALL 0.501 0.501 0.131
}

if { [expr $total_metal - $top_metal ] >= 5 } {
RULECHECK DFM_99_M5 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M5ALL 0.501 0.501 0.131
}

if { [expr $total_metal - $top_metal ] >= 6 } {
RULECHECK DFM_99_M6 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M6ALL 0.501 0.501 0.131
}

if { [expr $total_metal - $top_metal ] >= 7 } { 
RULECHECK DFM_99_M7 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M7ALL 0.501 0.501 0.131
}

if { [expr $total_metal - $top_metal ] >= 8 } { 
RULECHECK DFM_99_M8 {
@ Space between two M1s having parallel segment >0.5um with one or both M1 width>0.2um >0.11um
  Mn_2b M8ALL 0.501 0.501 0.131
}
}
}
}
}
}
}

set via_list { V2 V3 V4 V5 V6 V7 }
foreach via_layer $via_list {
  set tmp CHECK_$via_layer
  set tmp_v [set $tmp]
  if { $tmp_v == 1 } {
  set number [string index $via_layer 1]
  set bottom_metal M$number
  set up_metal M[expr $number +1]
RULECHECK DFM_100_${via_layer} {
@ ${via_layer} enclosure by ${bottom_metal} or ${up_metal} if ${bottom_metal} or ${up_metal} length along via >= 0.3um is 0.035um.
SETLAYER X1 = ${bottom_metal} WITH EDGE (LENGTH ${bottom_metal} >= 0.3)
SETLAYER X2 = ${up_metal} WITH EDGE (LENGTH ${up_metal} >= 0.3)
OUTLAYER (ENC (${via_layer} INTERACT X1) X1 < 0.035 ABUT<90 REGION OUTSIDE ALSO) NOT INSIDE EXDFM
OUTLAYER (ENC (${via_layer} INTERACT X2) X2 < 0.035 ABUT<90 REGION OUTSIDE ALSO) NOT INSIDE EXDFM
}
}
}

foreach via_layer $v_j_layer {
  set number [string index $via_layer 1]
  set up_metal M[expr $number +1]

SETLAYER ${via_layer}_DFM103 = EMPTY4 OR ${via_layer}i
SETLAYER ${up_metal}_DFM103 = EMPTY4 OR ${up_metal}i
CONNECT  ${up_metal}_DFM103 ${via_layer}_DFM103 

RULECHECK DFM_103_${via_layer} {
@ Space between ${via_layer} and unconnected ${up_metal}(two metal lines are perpendicular to one another) >= 0.12
OUTLAYER (EXT ${up_metal}_DFM103 ${via_layer}_DFM103 < 0.12 ABUT<90 REGION OPPOSITE MEASURE ALL NOT CONNECTED) NOT INSIDE EXDFM
}
}

VERBATIM {
DFM_101 {
@ Maximum parallel metal line width allowed without slot >= 4 um
 M1_CHECK = M1 NOT INTERACT M1SLOT
 (M1_CHECK WITH WIDTH > 4) NOT INSIDE EXDFM
}
}
}
