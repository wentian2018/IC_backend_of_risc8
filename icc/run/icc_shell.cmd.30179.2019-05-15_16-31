#@ # 
#@ # Running icc_shell Version K-2015.06 for linux64 -- May 22, 2015
#@ # Date:   Wed May 15 16:31:41 2019
#@ # Run by: zhouwt@helium3
#@ 

#@ # -- Starting source .synopsys_dc.setup

#@ set_app_var search_path "$search_path ../../rtl  ../../ref1/db ../../ref1/tlup ../scripts"
#@ set_app_var target_library "io_max.db  ram16x128_max.db  ram32x64_max.db  ram4x32_max.db  ram8x64_max.db  sc_max.db  sc_pg_max.db  special_max.db                         io_min.db  ram16x128_min.db  ram32x64_min.db  ram4x32_min.db  ram8x64_min.db  sc_min.db  sc_pg_min.db  special_min.db"
#@ set_app_var link_library "* $target_library dw_foundation.sldb"
#@ 
#@ set synthetic_library "dw_foundation.sldb"
#@ 
#@ source ../../ref1/icc_settings.tcl
#@ # -- Starting source ../../ref1/icc_settings.tcl

#@ # This file needs to be sourced from within the .synopsys_dc.setup file
#@ # 
#@ puts "\n### Executing common setup file 'ref/icc_settings.tcl' ..."
#@ 
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ # Other setup
#@ #   - This could go into the .synopsys_dc.setup file in your home 
#@ #     directory, so it is available no matter where the tool is launched
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ 
#@ # Load useful functions
#@ source /home/zhouwt/risc8/ref1/tools/procs.tcl
#@ # -- Starting source /home/zhouwt/risc8/ref1/tools/procs.tcl

#@ # Synopsys Customer Education Services
#@ # IC Compiler Workshop series
#@ #
#@ # Tcl procedures to simplify life...
#@ 
#@ puts "\#\#\# Processing procs.tcl..."
#@ 
#@ create_command_group CES_procs
#@ 
#@ # Get command results/reports in separate graphical tk window
#@ # This expects view.tk to be in the path, which is the other half
#@ # of this procedure!
#@ # Examples: view man compile,  view report_timing -max_paths 20
#@ #======================================================  
#@ proc view {args} {
#@ 	if {$args == ""} { puts "view: Please provide a command."; return }
#@ 	set tmpfile tmpfile[pid][expr int(rand()*10000)]
#@ 	redirect $tmpfile {uplevel $args}
#@ 	# Without redirect, exec echos the PID of the new process to the screen
#@     #	redirect /dev/null {exec ../ref/tools/view.tk $tmpfile "$args" &}
#@ #  per Amin, 2/16/10
#@     redirect /dev/null {exec ../ref/tools/view.tk $tmpfile "$args" true &}
#@ }
#@ define_proc_attributes view 	-info "Display output of any command in a separate Tk window." 	-command_group CES_procs 	-define_args {
#@ 		{args "Command with arguments" args}
#@ 	}
#@ 
#@ 
#@ proc report_placement_blockages {} {
#@ 	foreach_in_collection item [get_placement_blockages -quiet] {
#@ 		puts "Name:   [get_attribute $item name]"
#@ 		puts "  Type: [get_attribute $item type]"
#@ 		puts "  bbox: [get_attribute $item bbox]\n"
#@ 	}
#@ }
#@ define_proc_attributes report_placement_blockages 	-info "Display a summary of all placement blockages in the design" 	-command_group CES_procs
#@ 
#@ proc report_route_guides {} {
#@ 	suppress_message ATTR-3
#@ 	foreach_in_collection item [get_route_guides -quiet] {
#@ 		puts "Name:   [get_attribute $item name]"
#@ 		puts "  switch_preferred_direction: [get_attribute $item switch_preferred_direction]"
#@ 		puts "  no_preroute_layers:         [get_attribute $item no_preroute_layers]"
#@ 		puts "  no_signal_layers:           [get_attribute $item no_signal_layers]"
#@ 		puts "  bbox:                       [get_attribute $item bbox]"
#@ 	}
#@ 	unsuppress_message ATTR-3
#@ }
#@ define_proc_attributes report_route_guides 	-info "Display a summary of all route guides in the design" 	-command_group CES_procs
#@ 
#@ 
#@ proc async_domain {args} {
#@ 	parse_proc_arguments -args $args procargs
#@ 	set clk1 $procargs(clock1)
#@ 	set clk2 $procargs(clock2)
#@     set_false_path -from [get_clocks $clk1] -to [get_clocks $clk2]
#@     set_false_path -from [get_clocks $clk2] -to [get_clocks $clk1]
#@ }
#@ define_proc_attributes async_domain 	-info "set false paths between 2 clocks in both directions" 	-command_group CES_procs 	-define_args {
#@ 		{clock1 "First clock name" clock1}
#@ 		{clock2 "Second clock name" clock2}
#@ 	}
#@ 
#@ # Generates statistics on the current session:
#@ #   hostname
#@ #   uname -a
#@ #   date
#@ #   location of current exec
#@ proc host_stats {} {
#@ 	uplevel {
#@ 	puts "##### Session information:"
#@ 	puts "hostname:  [exec hostname]"
#@ 	puts "uname -a:  [exec uname -a]"
#@ 	puts "date:      [date]"
#@ 	puts "bin path:  $bin_path"
#@ 	puts "##### End session information\n"
#@ 	}
#@ }
#@ define_proc_attributes host_stats 	-info "Display statistics of the current host (server)" 	-command_group CES_procs
#@ 
#@ 
#@ # Generates timing, constraint and qor reports in the "reports/" directory
#@ # under the current dir.
#@ proc gen_reports {args} {
#@ 
#@ 	# Defaults:
#@ 	set procargs(-verbose) false
#@ 	set procargs(-dir) "./reports"
#@ 
#@ 	parse_proc_arguments -args $args procargs
#@ 	set verbose $procargs(-verbose)
#@ 	set prefix $procargs(-prefix)
#@ 	set dir $procargs(-dir)
#@ 
#@ 	file mkdir $dir
#@ 	update_timing
#@ 	if ($verbose) { puts "##### Writing $dir/$prefix.constraint" }
#@ 	redirect $dir/$prefix.constraint {report_constraint -nosplit -all} 
#@ 	if ($verbose) { puts "##### Writing $dir/$prefix.timing" }
#@ 	redirect $dir/$prefix.timing {report_timing -nosplit}
#@ 	if ($verbose) { puts "##### Writing $dir/$prefix.min.timing" }
#@ 	redirect $dir/$prefix.min.timing {report_timing -delay min -nosplit}
#@ 	if ($verbose) { puts "##### Writing $dir/$prefix.qor" }
#@ 	redirect $dir/$prefix.qor {report_qor}
#@ }
#@ 
#@ define_proc_attributes gen_reports 	-info "Generates min/max timing, constraint and qor reports" 	-command_group CES_procs 	-define_args {
#@ 		{-prefix "Prefix for report files" "<name>" string required}
#@ 		{-verbose "Be verbose!" "" boolean optional}
#@ 		{-dir "Destination directory. Default: ./reports" "dest_dir" string optional}
#@ 	}
#@ 
#@ 
#@ proc reset_timer {timer_name} {
#@     global $timer_name
#@     redirect /dev/null {set $timer_name [clock seconds]}
#@ }
#@ define_proc_attributes reset_timer 	-info "Resets a named timer" 	-command_group CES_procs 	-define_args {
#@ 		{timer_name "Name of timer" timer_name}
#@ 	}
#@ 
#@ proc report_timer {timer_name message} {
#@     upvar $timer_name time
#@ 
#@     set mins [expr ([clock seconds] - $time) / 60]
#@     set secs [expr ([clock seconds] - $time) % 60]
#@     echo [format "####----#### Runtime: %3d:%02d minutes for \"$message\"" $mins $secs]
#@ }
#@ define_proc_attributes report_timer 	-info "report the elapsed time of a named timer" 	-command_group CES_procs 	-define_args {
#@ 		{timer_name "Name of timer" timer_name}
#@ 		{message "message to display with the value of the timer" message}
#@ 	}
#@ 
#@ 
#@ proc measure_time {args} {
#@     set time [clock seconds]
#@ 	set command [join $args]
#@     echo "##### Started timer for command \"$command\""
#@     uplevel $args
#@     set mins [expr ([clock seconds] - $time) / 60]
#@     set secs [expr ([clock seconds] - $time) % 60]
#@     echo [format "####----#### Runtime: %3d:%02d minutes for command \"$command\"" $mins $secs]
#@ }
#@ define_proc_attributes measure_time 	-info "Run a command while measuring the time it takes" 	-command_group CES_procs 	-define_args {
#@ 		{script "Tcl-commands to time (and run)" args}
#@ 	}
#@ 
#@ proc gui {} {
#@ 	uplevel {
#@ 		if {$in_gui_session == false} {
#@ 			gui_start
#@ 		} else {
#@ 			gui_stop
#@ 			echo "... or just 'gui'"
#@ 		}
#@ 	}
#@ }
#@ define_proc_attributes gui 	-info "Start or stop the GUI" 	-command_group CES_procs
#@ 
#@ proc vman {cmd} {
#@ 	if {$::in_gui_session == false} {
#@ 		view man $cmd
#@ 	} else {
#@ 		gui_show_man_page $cmd
#@ 	}
#@ }
#@ define_proc_attributes vman 	-info "Display a man page using the GUI man reader or Tcl/TK." 	-dont_abbrev 	-command_group CES_procs 	-define_args {
#@ 		{cmd "command-name" cmd}
#@ 	}
#@ 
#@ 
#@ 
#@ #
#@ # Always Ask
#@ # This useful procedure is on solvnet, Doc Id  012959
#@ #
#@ proc aa {args} {
#@ 
#@    parse_proc_arguments -args $args results
#@ 
#@    echo "*********  Commands **********"
#@    help *$results(pattern)*
#@ 
#@    echo "********* Variables **********"
#@    uplevel "printvar *$results(pattern)*"
#@ 
#@    if {[info exists results(-verbose)]} {
#@       echo "********* -help *************"
#@       apropos *$results(pattern)*
#@    }
#@ }; # end proc
#@ 
#@ define_proc_attributes aa -info "always ask - Searches Synopsys help for both commands and variables" 	-command_group CES_procs 	-define_args {
#@ 		{pattern "Pattern to search for" pattern string required}
#@ 		{-verbose "Search -help as well" "" boolean optional}
#@ 	}
#@ 
#@ # Idea for a quick power ring proc...
#@ 
#@ proc ring_it {args} {
#@ 	# Defaults:
#@ 	set procargs(-cells) ""
#@ 	set procargs(-nets) "VDD VSS"
#@ 	set procargs(-location) "5"
#@ 	set procargs(-horiz_layer) "METAL3"
#@ 	set procargs(-vert_layer) "METAL2"
#@ 	set procargs(-width) "4"
#@ 	set procargs(-full) "false"
#@ 
#@ 	parse_proc_arguments -args $args procargs
#@ 	set cells $procargs(-cells)
#@ 	set nets  $procargs(-nets)
#@ 	set location $procargs(-location)
#@ 	set horiz_layer $procargs(-horiz_layer)
#@ 	set vert_layer $procargs(-vert_layer)
#@ 	set width $procargs(-width)
#@ 	set full $procargs(-full)
#@ 
#@ 
#@ 	if {$cells == ""} {
#@ 		puts "ERROR:  no cells specified!"
#@ 		return
#@ 	}
#@ 
#@ #-location {1 2 3 4 5 6 7 8 9} matrix 1= bottom left, 2 bottom middle, ..., 9 is top right.
#@ #create connections to core ring based on location - we assume that if any number but 5 (default) is given,
#@ #we will create connections to the ring around the core! (-extend_xy)
#@ 
#@ 
#@ 	switch $location {
#@ 		1 { set extend "-extend_tl -extend_rl"; set skip "-skip_left_side -skip_bottom_side" }
#@ 		2 { set extend "-extend_ll -extend_rl"; set skip "-skip_bottom_side" }
#@ 		3 { set extend "-extend_th -extend_ll"; set skip "-skip_right_side -skip_bottom_side" }
#@ 		4 { set extend "-extend_tl -extend_bl"; set skip "-skip_left_side" }
#@ 		5 { set extend ""; set skip "" }
#@ 		6 { set extend "-extend_bh -extend_th"; set skip "-skip_right_side" }
#@ 		7 { set extend "-extend_rh -extend_bl"; set skip "-skip_top_side -skip_left_side" }
#@ 		8 { set extend "-extend_lh -extend_rh"; set skip "-skip_top_side" }
#@ 		9 { set extend "-extend_lh -extend_bh"; set skip "-skip_top_side -skip_right_side" }
#@ 		default { set extend ""; set skip "" }
#@ 	}
#@ 
#@ 	if {$full} {
#@ 		set skip "";
#@ 		switch $location {
#@ 			1 { set extend "$extend -extend_bl -extend_ll" }
#@ 			2 {  }
#@ 			3 { set extend "$extend -extend_rl -extend_bh" }
#@ 			4 {  }
#@ 			5 {  }
#@ 			6 {  }
#@ 			7 { set extend "$extend -extend_tl -extend_lh" }
#@ 			8 {  }
#@ 			9 { set extend "$extend -extend_rh -extend_th" }
#@ 			default {  }
#@ 		}
#@ 	}
#@ 
#@ 	puts "Using $horiz_layer for horizontal ring sections."
#@ 	puts "Using $vert_layer for vertical ring sections."
#@ 	puts "Routing power nets $nets."
#@ 	puts "Ring width: $width"
#@ 
#@ 	eval create_rectangular_rings -nets {$nets} -around specified_as_group -cells $cells $extend -left_segment_layer $vert_layer -right_segment_layer $vert_layer -top_segment_layer $horiz_layer -bottom_segment_layer $horiz_layer $skip -left_segment_width $width -right_segment_width $width -bottom_segment_width $width -top_segment_width $width
#@ 
#@ }
#@ 
#@ 
#@ define_proc_attributes ring_it 	-info "Creates a simple power ring around macros" 	-command_group CES_procs 	-define_args {
#@ 		{-cells "Macro cells to create ring around" "<cells>" string required}
#@ 		{-nets "names of power/ground nets. Default: VDD VSS" "<pgnets>" string optional}
#@ 		{-location "location of macro, 1-9. 1 is lower left, 9 upper right corner. Default: 5" "<1-9>" string optional}
#@ 		{-horiz_layer "Layer to use for horizontal ring sections. Default: METAL3" "string" string optional}
#@ 		{-vert_layer "Layer to use for vertical ring sections. Default: METAL2" "string" string optional}
#@ 		{-width "Width of ring. Default: 4" "integer" string optional}
#@ 		{-full "Create a complete ring (we assume we'll re-use the core ring otherwise)" "" boolean optional}
#@ 	}
#@ 
#@ 
#@ 
#@ 
#@ # Display all customer procedures:
#@ echo "The following procedures are defined for use in this workshop."
#@ echo "They are NOT standard IC Compiler commands."
#@ help CES_procs
#@ # -- End source /home/zhouwt/risc8/ref1/tools/procs.tcl

#@ # Uncomment to disable tracking and reporting of when new variables are created
#@ # set sh_new_variable_message false
#@ # Command-line editing is on by default starting with ICC 2005.06-SP1
#@ # set sh_enable_line_editing true
#@ # emacs is the default line-editing mode. The other mode is "vi"
#@ # set sh_line_editing_mode emacs
#@ # Disable more-like page mode
#@ set enable_page_mode false
#@ 
#@ # Don't want to see CMD-041 when creating new variables
#@ set sh_new_variable_message false
#@ 
#@ # Some aliases to make use of view nicer (defined in tools/procs.tcl)
#@ alias v view
#@ alias rt  "report_timing -nosplit"
#@ alias rtm "report_timing -nosplit -delay min"
#@ alias rc  "report_constraint -all_violators -nosplit"
#@ alias rq report_qor
#@ 
#@ 
#@ # Increase history buffer
#@ history keep 100
#@ alias h history
#@ 
#@ # Ease of use...
#@ alias _ measure_time
#@ 
#@ # Enable logging of commands and everything by date/shell
#@ set timestamp [clock format [clock scan now] -format "%Y-%m-%d_%H-%M"]
#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/msgcat/msgcat.tcl

#@ # msgcat.tcl --
#@ #
#@ #	This file defines various procedures which implement a
#@ #	message catalog facility for Tcl programs.  It should be
#@ #	loaded with the command "package require msgcat".
#@ #
#@ # Copyright (c) 1998-2000 by Ajuba Solutions.
#@ # Copyright (c) 1998 by Mark Harrison.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ package require Tcl 8.5
#@ # When the version number changes, be sure to update the pkgIndex.tcl file,
#@ # and the installation directory in the Makefiles.
#@ package provide msgcat 1.4.5
#@ 
#@ namespace eval msgcat {
#@     namespace export mc mcload mclocale mcmax mcmset mcpreferences mcset 	    mcunknown
#@ 
#@     # Records the current locale as passed to mclocale
#@     variable Locale ""
#@ 
#@     # Records the list of locales to search
#@     variable Loclist {}
#@ 
#@     # Records the mapping between source strings and translated strings.  The
#@     # dict key is of the form "<locale> <namespace> <src>", where locale and
#@     # namespace should be themselves dict values and the value is
#@     # the translated string.
#@     variable Msgs [dict create]
#@ 
#@     # Map of language codes used in Windows registry to those of ISO-639
#@     if {[info sharedlibextension] eq ".dll"} {
#@ 	variable WinRegToISO639 [dict create  {*}{
#@ 	    01 ar 0401 ar_SA 0801 ar_IQ 0c01 ar_EG 1001 ar_LY 1401 ar_DZ
#@ 		  1801 ar_MA 1c01 ar_TN 2001 ar_OM 2401 ar_YE 2801 ar_SY
#@ 		  2c01 ar_JO 3001 ar_LB 3401 ar_KW 3801 ar_AE 3c01 ar_BH
#@ 		  4001 ar_QA
#@ 	    02 bg 0402 bg_BG
#@ 	    03 ca 0403 ca_ES
#@ 	    04 zh 0404 zh_TW 0804 zh_CN 0c04 zh_HK 1004 zh_SG 1404 zh_MO
#@ 	    05 cs 0405 cs_CZ
#@ 	    06 da 0406 da_DK
#@ 	    07 de 0407 de_DE 0807 de_CH 0c07 de_AT 1007 de_LU 1407 de_LI
#@ 	    08 el 0408 el_GR
#@ 	    09 en 0409 en_US 0809 en_GB 0c09 en_AU 1009 en_CA 1409 en_NZ
#@ 		  1809 en_IE 1c09 en_ZA 2009 en_JM 2409 en_GD 2809 en_BZ
#@ 		  2c09 en_TT 3009 en_ZW 3409 en_PH
#@ 	    0a es 040a es_ES 080a es_MX 0c0a es_ES@modern 100a es_GT 140a es_CR
#@ 		  180a es_PA 1c0a es_DO 200a es_VE 240a es_CO 280a es_PE
#@ 		  2c0a es_AR 300a es_EC 340a es_CL 380a es_UY 3c0a es_PY
#@ 		  400a es_BO 440a es_SV 480a es_HN 4c0a es_NI 500a es_PR
#@ 	    0b fi 040b fi_FI
#@ 	    0c fr 040c fr_FR 080c fr_BE 0c0c fr_CA 100c fr_CH 140c fr_LU
#@ 		  180c fr_MC
#@ 	    0d he 040d he_IL
#@ 	    0e hu 040e hu_HU
#@ 	    0f is 040f is_IS
#@ 	    10 it 0410 it_IT 0810 it_CH
#@ 	    11 ja 0411 ja_JP
#@ 	    12 ko 0412 ko_KR
#@ 	    13 nl 0413 nl_NL 0813 nl_BE
#@ 	    14 no 0414 no_NO 0814 nn_NO
#@ 	    15 pl 0415 pl_PL
#@ 	    16 pt 0416 pt_BR 0816 pt_PT
#@ 	    17 rm 0417 rm_CH
#@ 	    18 ro 0418 ro_RO 0818 ro_MO
#@ 	    19 ru 0819 ru_MO
#@ 	    1a hr 041a hr_HR 081a sr_YU 0c1a sr_YU@cyrillic
#@ 	    1b sk 041b sk_SK
#@ 	    1c sq 041c sq_AL
#@ 	    1d sv 041d sv_SE 081d sv_FI
#@ 	    1e th 041e th_TH
#@ 	    1f tr 041f tr_TR
#@ 	    20 ur 0420 ur_PK 0820 ur_IN
#@ 	    21 id 0421 id_ID
#@ 	    22 uk 0422 uk_UA
#@ 	    23 be 0423 be_BY
#@ 	    24 sl 0424 sl_SI
#@ 	    25 et 0425 et_EE
#@ 	    26 lv 0426 lv_LV
#@ 	    27 lt 0427 lt_LT
#@ 	    28 tg 0428 tg_TJ
#@ 	    29 fa 0429 fa_IR
#@ 	    2a vi 042a vi_VN
#@ 	    2b hy 042b hy_AM
#@ 	    2c az 042c az_AZ@latin 082c az_AZ@cyrillic
#@ 	    2d eu
#@ 	    2e wen 042e wen_DE
#@ 	    2f mk 042f mk_MK
#@ 	    30 bnt 0430 bnt_TZ
#@ 	    31 ts 0431 ts_ZA
#@ 	    32 tn
#@ 	    33 ven 0433 ven_ZA
#@ 	    34 xh 0434 xh_ZA
#@ 	    35 zu 0435 zu_ZA
#@ 	    36 af 0436 af_ZA
#@ 	    37 ka 0437 ka_GE
#@ 	    38 fo 0438 fo_FO
#@ 	    39 hi 0439 hi_IN
#@ 	    3a mt 043a mt_MT
#@ 	    3b se 043b se_NO
#@ 	    043c gd_UK 083c ga_IE
#@ 	    3d yi 043d yi_IL
#@ 	    3e ms 043e ms_MY 083e ms_BN
#@ 	    3f kk 043f kk_KZ
#@ 	    40 ky 0440 ky_KG
#@ 	    41 sw 0441 sw_KE
#@ 	    42 tk 0442 tk_TM
#@ 	    43 uz 0443 uz_UZ@latin 0843 uz_UZ@cyrillic
#@ 	    44 tt 0444 tt_RU
#@ 	    45 bn 0445 bn_IN
#@ 	    46 pa 0446 pa_IN
#@ 	    47 gu 0447 gu_IN
#@ 	    48 or 0448 or_IN
#@ 	    49 ta
#@ 	    4a te 044a te_IN
#@ 	    4b kn 044b kn_IN
#@ 	    4c ml 044c ml_IN
#@ 	    4d as 044d as_IN
#@ 	    4e mr 044e mr_IN
#@ 	    4f sa 044f sa_IN
#@ 	    50 mn
#@ 	    51 bo 0451 bo_CN
#@ 	    52 cy 0452 cy_GB
#@ 	    53 km 0453 km_KH
#@ 	    54 lo 0454 lo_LA
#@ 	    55 my 0455 my_MM
#@ 	    56 gl 0456 gl_ES
#@ 	    57 kok 0457 kok_IN
#@ 	    58 mni 0458 mni_IN
#@ 	    59 sd
#@ 	    5a syr 045a syr_TR
#@ 	    5b si 045b si_LK
#@ 	    5c chr 045c chr_US
#@ 	    5d iu 045d iu_CA
#@ 	    5e am 045e am_ET
#@ 	    5f ber 045f ber_MA
#@ 	    60 ks 0460 ks_PK 0860 ks_IN
#@ 	    61 ne 0461 ne_NP 0861 ne_IN
#@ 	    62 fy 0462 fy_NL
#@ 	    63 ps
#@ 	    64 tl 0464 tl_PH
#@ 	    65 div 0465 div_MV
#@ 	    66 bin 0466 bin_NG
#@ 	    67 ful 0467 ful_NG
#@ 	    68 ha 0468 ha_NG
#@ 	    69 nic 0469 nic_NG
#@ 	    6a yo 046a yo_NG
#@ 	    70 ibo 0470 ibo_NG
#@ 	    71 kau 0471 kau_NG
#@ 	    72 om 0472 om_ET
#@ 	    73 ti 0473 ti_ET
#@ 	    74 gn 0474 gn_PY
#@ 	    75 cpe 0475 cpe_US
#@ 	    76 la 0476 la_VA
#@ 	    77 so 0477 so_SO
#@ 	    78 sit 0478 sit_CN
#@ 	    79 pap 0479 pap_AN
#@ 	}]
#@     }
#@ }
#@ 
#@ # msgcat::mc --
#@ #
#@ #	Find the translation for the given string based on the current
#@ #	locale setting. Check the local namespace first, then look in each
#@ #	parent namespace until the source is found.  If additional args are
#@ #	specified, use the format command to work them into the traslated
#@ #	string.
#@ #
#@ # Arguments:
#@ #	src	The string to translate.
#@ #	args	Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated string.  Propagates errors thrown by the
#@ #	format command.
#@ 
#@ proc msgcat::mc {src args} {
#@     # Check for the src in each namespace starting from the local and
#@     # ending in the global.
#@ 
#@     variable Msgs
#@     variable Loclist
#@     variable Locale
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     while {$ns != ""} {
#@ 	foreach loc $Loclist {
#@ 	    if {[dict exists $Msgs $loc $ns $src]} {
#@ 		if {[llength $args] == 0} {
#@ 		    return [dict get $Msgs $loc $ns $src]
#@ 		} else {
#@ 		    return [format [dict get $Msgs $loc $ns $src] {*}$args]
#@ 		}
#@ 	    }
#@ 	}
#@ 	set ns [namespace parent $ns]
#@     }
#@     # we have not found the translation
#@     return [uplevel 1 [list [namespace origin mcunknown] 	    $Locale $src {*}$args]]
#@ }
#@ 
#@ # msgcat::mclocale --
#@ #
#@ #	Query or set the current locale.
#@ #
#@ # Arguments:
#@ #	newLocale	(Optional) The new locale string. Locale strings
#@ #			should be composed of one or more sublocale parts
#@ #			separated by underscores (e.g. en_US).
#@ #
#@ # Results:
#@ #	Returns the current locale.
#@ 
#@ proc msgcat::mclocale {args} {
#@     variable Loclist
#@     variable Locale
#@     set len [llength $args]
#@ 
#@     if {$len > 1} {
#@ 	return -code error "wrong # args: should be		\"[lindex [info level 0] 0] ?newLocale?\""
#@     }
#@ 
#@     if {$len == 1} {
#@ 	set newLocale [lindex $args 0]
#@ 	if {$newLocale ne [file tail $newLocale]} {
#@ 	    return -code error "invalid newLocale value \"$newLocale\":		    could be path to unsafe code."
#@ 	}
#@ 	set Locale [string tolower $newLocale]
#@ 	set Loclist {}
#@ 	set word ""
#@ 	foreach part [split $Locale _] {
#@ 	    set word [string trim "${word}_${part}" _]
#@ 	    if {$word ne [lindex $Loclist 0]} {
#@ 		set Loclist [linsert $Loclist 0 $word]
#@ 	    }
#@ 	}
#@ 	lappend Loclist {}
#@ 	set Locale [lindex $Loclist 0]
#@     }
#@     return $Locale
#@ }
#@ 
#@ # msgcat::mcpreferences --
#@ #
#@ #	Fetch the list of locales used to look up strings, ordered from
#@ #	most preferred to least preferred.
#@ #
#@ # Arguments:
#@ #	None.
#@ #
#@ # Results:
#@ #	Returns an ordered list of the locales preferred by the user.
#@ 
#@ proc msgcat::mcpreferences {} {
#@     variable Loclist
#@     return $Loclist
#@ }
#@ 
#@ # msgcat::mcload --
#@ #
#@ #	Attempt to load message catalogs for each locale in the
#@ #	preference list from the specified directory.
#@ #
#@ # Arguments:
#@ #	langdir		The directory to search.
#@ #
#@ # Results:
#@ #	Returns the number of message catalogs that were loaded.
#@ 
#@ proc msgcat::mcload {langdir} {
#@     set x 0
#@     foreach p [mcpreferences] {
#@ 	if { $p eq {} } {
#@ 	    set p ROOT
#@ 	}
#@ 	set langfile [file join $langdir $p.msg]
#@ 	if {[file exists $langfile]} {
#@ 	    incr x
#@ 	    uplevel 1 [list ::source -encoding utf-8 $langfile]
#@ 	}
#@     }
#@     return $x
#@ }
#@ 
#@ # msgcat::mcset --
#@ #
#@ #	Set the translation for a given string in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	src		The source string.
#@ #	dest		(Optional) The translated string.  If omitted,
#@ #			the source string is used.
#@ #
#@ # Results:
#@ #	Returns the new locale.
#@ 
#@ proc msgcat::mcset {locale src {dest ""}} {
#@     variable Msgs
#@     if {[llength [info level 0]] == 3} { ;# dest not specified
#@ 	set dest $src
#@     }
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     set locale [string tolower $locale]
#@ 
#@     dict set Msgs $locale $ns $src $dest
#@     return $dest
#@ }
#@ 
#@ # msgcat::mcmset --
#@ #
#@ #	Set the translation for multiple strings in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	pairs		One or more src/dest pairs (must be even length)
#@ #
#@ # Results:
#@ #	Returns the number of pairs processed
#@ 
#@ proc msgcat::mcmset {locale pairs } {
#@     variable Msgs
#@ 
#@     set length [llength $pairs]
#@     if {$length % 2} {
#@ 	return -code error "bad translation list:		 should be \"[lindex [info level 0] 0] locale {src dest ...}\""
#@     }
#@ 
#@     set locale [string tolower $locale]
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     foreach {src dest} $pairs {
#@ 	dict set Msgs $locale $ns $src $dest
#@     }
#@ 
#@     return $length
#@ }
#@ 
#@ # msgcat::mcunknown --
#@ #
#@ #	This routine is called by msgcat::mc if a translation cannot
#@ #	be found for a string.  This routine is intended to be replaced
#@ #	by an application specific routine for error reporting
#@ #	purposes.  The default behavior is to return the source string.
#@ #	If additional args are specified, the format command will be used
#@ #	to work them into the traslated string.
#@ #
#@ # Arguments:
#@ #	locale		The current locale.
#@ #	src		The string to be translated.
#@ #	args		Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated value.
#@ 
#@ proc msgcat::mcunknown {locale src args} {
#@     if {[llength $args]} {
#@ 	return [format $src {*}$args]
#@     } else {
#@ 	return $src
#@     }
#@ }
#@ 
#@ # msgcat::mcmax --
#@ #
#@ #	Calculates the maximum length of the translated strings of the given
#@ #	list.
#@ #
#@ # Arguments:
#@ #	args	strings to translate.
#@ #
#@ # Results:
#@ #	Returns the length of the longest translated string.
#@ 
#@ proc msgcat::mcmax {args} {
#@     set max 0
#@     foreach string $args {
#@ 	set translated [uplevel 1 [list [namespace origin mc] $string]]
#@ 	set len [string length $translated]
#@ 	if {$len>$max} {
#@ 	    set max $len
#@ 	}
#@     }
#@     return $max
#@ }
#@ 
#@ # Convert the locale values stored in environment variables to a form
#@ # suitable for passing to [mclocale]
#@ proc msgcat::ConvertLocale {value} {
#@     # Assume $value is of form: $language[_$territory][.$codeset][@modifier]
#@     # Convert to form: $language[_$territory][_$modifier]
#@     #
#@     # Comment out expanded RE version -- bugs alleged
#@     # regexp -expanded {
#@     #	^		# Match all the way to the beginning
#@     #	([^_.@]*)	# Match "lanugage"; ends with _, ., or @
#@     #	(_([^.@]*))?	# Match (optional) "territory"; starts with _
#@     #	([.]([^@]*))?	# Match (optional) "codeset"; starts with .
#@     #	(@(.*))?	# Match (optional) "modifier"; starts with @
#@     #	$		# Match all the way to the end
#@     # } $value -> language _ territory _ codeset _ modifier
#@     if {![regexp {^([^_.@]+)(_([^.@]*))?([.]([^@]*))?(@(.*))?$} $value 	    -> language _ territory _ codeset _ modifier]} {
#@ 	return -code error "invalid locale '$value': empty language part"
#@     }
#@     set ret $language
#@     if {[string length $territory]} {
#@ 	append ret _$territory
#@     }
#@     if {[string length $modifier]} {
#@ 	append ret _$modifier
#@     }
#@     return $ret
#@ }
#@ 
#@ # Initialize the default locale
#@ proc msgcat::Init {} {
#@     global env
#@ 
#@     #
#@     # set default locale, try to get from environment
#@     #
#@     foreach varName {LC_ALL LC_MESSAGES LANG} {
#@ 	if {[info exists env($varName)] && ("" ne $env($varName))} {
#@ 	    if {![catch {
#@ 		mclocale [ConvertLocale $env($varName)]
#@ 	    }]} {
#@ 		return
#@ 	    }
#@ 	}
#@     }
#@     #
#@     # On Darwin, fallback to current CFLocale identifier if available.
#@     #
#@     if {[info exists ::tcl::mac::locale] && $::tcl::mac::locale ne ""} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $::tcl::mac::locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@     #
#@     # The rest of this routine is special processing for Windows or
#@     # Cygwin. All other platforms, get out now.
#@     #
#@     if {([info sharedlibextension] ne ".dll")
#@ 	    || [catch {package require registry}]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # On Windows or Cygwin, try to set locale depending on registry
#@     # settings, or fall back on locale of "C".
#@     #
#@ 
#@     # First check registry value LocalName present from Windows Vista
#@     # which contains the local string as RFC5646, composed of:
#@     # [a-z]{2,3} : language
#@     # -[a-z]{4}  : script (optional, translated by table Latn->latin)
#@     # -[a-z]{2}|[0-9]{3} : territory (optional, numerical region codes not used)
#@     # (-.*)* : variant, extension, private use (optional, not used)
#@     # Those are translated to local strings.
#@     # Examples: de-CH -> de_ch, sr-Latn-CS -> sr_cs@latin, es-419 -> es
#@     #
#@     set key {HKEY_CURRENT_USER\Control Panel\International}
#@     if {([registry values $key "LocaleName"] ne "")
#@ 	    && [regexp {^([a-z]{2,3})(?:-([a-z]{4}))?(?:-([a-z]{2}))?(?:-.+)?$}	    [string tolower [registry get $key "LocaleName"]] match locale	    script territory]} {
#@ 	if {"" ne $territory} {
#@ 	    append locale _ $territory
#@ 	}
#@ 	set modifierDict [dict create latn latin cyrl cyrillic]
#@ 	if {[dict exists $modifierDict $script]} {
#@ 	    append locale @ [dict get $modifierDict $script]
#@ 	}
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@ 
#@     # then check key locale which contains a numerical language ID
#@     if {[catch {
#@ 	set locale [registry get $key "locale"]
#@     }]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # Keep trying to match against smaller and smaller suffixes
#@     # of the registry value, since the latter hexadigits appear
#@     # to determine general language and earlier hexadigits determine
#@     # more precise information, such as territory.  For example,
#@     #     0409 - English - United States
#@     #     0809 - English - United Kingdom
#@     # Add more translations to the WinRegToISO639 array above.
#@     #
#@     variable WinRegToISO639
#@     set locale [string tolower $locale]
#@     while {[string length $locale]} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale [dict get $WinRegToISO639 $locale]]
#@ 	}]} {
#@ 	    return
#@ 	}
#@ 	set locale [string range $locale 1 end]
#@     }
#@     #
#@     # No translation known.  Fall back on "C" locale
#@     #
#@     mclocale C
#@ }
#@ msgcat::Init
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/msgcat/msgcat.tcl

#@ set sh_output_log_file "${synopsys_program_name}.log.[pid].$timestamp"
#@ set sh_command_log_file "${synopsys_program_name}.cmd.[pid].$timestamp"
#@ # -- End source ../../ref1/icc_settings.tcl

#@ 
#@ set hdlin_translate_off_skip_text "TRUE"
#@ set edifout_netlist_only "TRUE"
#@ set verilogout_no_tri true
#@ set plot_command {lpr -Plp}
#@ 
#@ set sh_enable_line_editing true
#@ set sh_line_editing_mode emacs
#@ history keep 100
#@ alias h history
#@ # -- End source .synopsys_dc.setup

source -echo -verbose /home/zhouwt/risc8/icc/run/../scripts/syn.tcl
#@ # -- Starting source /home/zhouwt/risc8/icc/run/../scripts/syn.tcl

#@ set design_name risc8
#@ ############Design Data#########################
#@ create_mw_lib  -technology ../../ref1/tech/cb13_6m.tf -mw_reference_library                           {../../ref1/mw_lib/ram16x128                            ../../ref1/mw_lib/io                            ../../ref1/mw_lib/ram4x32                            ../../ref1/mw_lib/ram8x64                            ../../ref1/mw_lib/special                            ../../ref1/mw_lib/sc                            ../../ref1/mw_lib/ram32x64 } -bus_naming_style {[%d]} -open risc8_icc
#@ 
#@ set_tlu_plus_files -max_tluplus ../../ref1/tlup/cb13_6m_max.tluplus                    -min_tluplus ../../ref1/tlup/cb13_6m_min.tluplus                    -tech2itf_map  ../../ref1/tlup/cb13_6m.map
#@ check_tlu_plus_files 
#@ read_verilog -verbose {../../dc/run/netlist/risc8.v}
#@ read_sdc  -version Latest "../../dc/run/netlist/risc8.sdc"
#@ # GUI Debug: Building dc from empty. -- Time: 4sec 774ms

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/syn/all_command_option_def.tcl

#@ define_proc_attributes all_physical_only_cells -info "Get the collection of physical only cells" -define_args {
#@ { -coordinates "coordinates of bounding box" "llx lly urx ury" string {optional}} 
#@ { -lib_cells "get cells related to these objects" "objects" list {optional}} 
#@ { -cell_name "list of cell name patterns and collections" "patterns" list {optional}} 
#@ { "" "Existing collection" "arguments" list {optional}} 
#@ }
#@ define_proc_attributes all_physical_only_nets  -info "Get the collection of physical only nets" -define_args {
#@ { "" "list of cell name patterns and collections" "arguments" list {optional}} 
#@ } 
#@ define_proc_attributes all_drc_violated_nets -info "Returns all DRC violated nets" -define_args { 
#@ { -max_capacitance "max Cap DRC violated nets" "" string {optional}} 
#@ { -max_transition "max transition time DRC violated nets" "" string {optional}} 
#@ { -max_fanout "max fanout DRC violated nets" "" string {optional}}
#@ { -threshold "Captures all values more than or equal to threshold" "threshold" string {optional}} 
#@ { -bound "Captures all values less than or equal to bound bound" "upper" string {optional}} 
#@ { "" "objects patterns OR collection" "arguments"  list {optional}} 
#@ }
#@ define_proc_attributes all_fanin -info "return pins or cells in transitive fanin" -define_args { 
#@ { -to "set of sink ports, pins, or nets" "sink_list" list {optional}} 
#@ { -startpoints_only  "return only the timing startpoints" "" string {optional}} 
#@ { -exclude_bboxes "black-boxes are not included in return-set" "" string {optional}} 
#@ { -break_on_bboxes  "traversal stops at black-boxes" "" string {optional}} 
#@ { -only_cells "only cells are included in the return-set" "" string {optional}} 
#@ { -flat "trace entire design instead of just current hierarchy" "" string {optional}} 
#@ { -levels "maximum number of levels of logic to traverse" "n" string {optional}} 
#@ { -trace_arcs "Type of network arcs to trace. Values: timing, all" "arc_type" string {optional}}
#@ }
#@ define_proc_attributes all_high_fanout -info "Returns all high fanout objects" -define_args { 
#@ { -nets "high fanout nets" "" string {optional}} 
#@ { -threshold "high fanout threshold: value>=0" "threshold" string {optional}} 
#@ { -through_buf_inv "treat buffers and inverters as transparent -check for transitive fanout" "" string {optional}} 
#@ { "" "objects patterns OR collection" "arguments" string {optional}} 
#@ }
#@ define_proc_attributes all_ideal_nets -info "Returns all ideal nets" -define_args { 
#@ { "" "objects patterns OR collection" "arguments" string {optional}} 
#@ }
#@ define_proc_attributes all_inputs -info "return input ports" -define_args { 
#@ { -clock "ports with input delay relative to clock" "clock" string {optional}} 
#@ { -edge_triggered "ports with non-level-sensitive input delay" "" string {optional}} 
#@ { -level_sensitive "ports with level-sensitive input delay" "" string {optional}} 
#@ }
#@ define_proc_attributes all_outputs -info "return output ports" -define_args { 
#@ { -clock "ports with output delay relative to clock" "clock" string {optional}} 
#@ { -edge_triggered "ports with non-level-sensitive output delay" "" string {optional}} 
#@ { -level_sensitive "ports with level-sensitive output delay" "" string {optional}} 
#@ }
#@ define_proc_attributes all_threestate -info "Returns all threestate objects" -define_args { 
#@ { -nets "threestate nets" "" string {optional}} 
#@ { "" "objects patterns OR collection" "arguments" string {optional}} 
#@ }
#@ define_proc_attributes all_dont_touch -info "Returns all dont touch objects" -define_args { 
#@ { -nets "Dont touch nets" "" string {optional}} 
#@ { -cells "Dont touch cells" "" string {optional}} 
#@ { "" "Dont touch patterns OR collections" "patterns" string {optional}} 
#@ }
#@ define_proc_attributes all_size_only_cells -info "Returns all size_only cells" -define_args { 
#@ { "" "Object patterns OD collections" "patterns" string {optional}} 
#@ }
#@ define_proc_attributes all_clocks -info "return all clocks in the current design"  
#@ define_proc_attributes all_designs -info "return all designs" 
#@ define_proc_attributes all_registers  -info "create a collection of register cells or pins" -define_args { 
#@ { -no_hierarchy "only search the top level of hierarchy" "" string {optional}} 
#@ {-rise_clock "return registers triggered by rise edge of this clock" "rise_clock" string {optional}}
#@ {-fall_clock "return registers triggered by rise edge of this clock" "fall_clock" string {optional}}
#@ { -clock "return registers of this clock" "clock" string {optional}} 
#@ { -cells "return cells - this is the default" "" string {optional}} 
#@ { -data_pins "return data_pins" "" string {optional}} 
#@ { -clock_pins "return clock_pins" "" string {optional}} 
#@ { -slave_clock_pins "return slave_clock_pin" "" string {optional}} 
#@ { -inverted_output "return FF's with inverted output phase" "" string {optional}} 
#@ { -output_pins "return output_pins" "" string {optional}} 
#@ { -level_sensitive "only consider level sensitive registers" "" string {optional}} 
#@ { -edge_triggered "only consider edge triggered register" "" string {optional}} 
#@ { -master_slave "only consider master/slave registers" "" string {optional}} 
#@ }
#@ define_proc_attributes all_critical_cells -info "return critical cells" -define_args { 
#@ { -slack_range "critical range to select cells:value>=0" "range_value" string {optional}} 
#@ }
#@ define_proc_attributes all_critical_pins -info "return critical pins" -define_args { 
#@ { -slack_range "critical range to select cells:value>=0" "range_value" string {optional}} 
#@ { -type "pintype: Values: endpoint, startpoint" "pin_type" string {optional}} 
#@ }
#@ define_proc_attributes get_magnet_cells -info "return magnet cells collection" -define_args {
#@ { -stop_by_sequential_cells "don't pull sequential cells" "" string {optional}} 
#@ { -exclude_buffers "skip through buffers in levels" "" string {optional}} 
#@ { -exclude_cells "list of excluded cells list" "" string {optional}}
#@ { -logical_level "number of logical levels to pull for placement" "integer" string {optional}} 
#@ { -stop_points "list of stop points where to stop magnetizing paths" "object_list" list {optional}} 
#@ { "" "a list of magnet objects" "magnet_objects" list {optional}} 
#@ }
#@ define_proc_attributes all_fanout -info "return pins or cells in transitive fanout" -define_args {
#@ {-clock_tree "return all clock tree components in design" "" string {optional}}
#@ {-from "set of source ports, pins, or nets" "source_list" list {optional}}
#@ {-endpoints_only "return only the timing endpoints" "" string {optional}}
#@ {-exclude_bboxes "black-boxes are not included in return-set" "" string {optional}}
#@ {-break_on_bboxes "traversal stops at black-boxes" "" string {optional}}
#@ {-only_cells "only cells are included in the return-set" "" string {optional}}
#@ {-flat "trace entire design instead of just current hierarchy" "" string {optional}}
#@ {-levels "maximum number of levels of logic to traverse" "n" string {optional}}
#@ {-trace_arcs "Type of network arcs to trace. Values: timing, all" "arc_type" string {optional}}
#@ }
#@ define_proc_attributes all_physical_only_ports -info " Get the collection of physical only ports" -define_args {
#@ {"" "list of cell name patterns and collections" "arguments" list {optional}}
#@ }
#@ define_proc_attributes get_matching_nets_for_pattern -info "Get matched nets for a certain net pattern" -define_args { 
#@ { -pattern "pattern id" "integer" string {optional}} 
#@ { -optimizable "Return all nets that can be optimized" "" string {optional}} 
#@ { -transition_lower_limit "nets with transition equal or greater than lower limit" "lower_limit" string {optional}} 
#@ { -transition_upper_limit "nets with transition less than upper limit" "upper_limit" string {optional}} 
#@ { -setup_slack_lower_limit "nets with slack equal or greater than lower limit" "lower_limit" string {optional}} 
#@ { -setup_slack_upper_limit "nets with slack less than upper limit" "upper_limit" string {optional}} 
#@ { -hold_slack_lower_limit "nets with hold slack equal or greater than lower limit" "lower_limit" string {optional}} 
#@ { -hold_slack_upper_limit "nets with hold slack less than upper limit" "upper_limit" string {optional}} 
#@ }
#@ # -- End source /opt/synopsys/icc-201506/auxx/syn/all_command_option_def.tcl

#@ 
#@ 
#@ source pad_cell_cons.tcl
#@ # -- Starting source pad_cell_cons.tcl

#@ # Create corners and P/G pads
#@ create_cell {cornerll cornerlr cornerul cornerur} pfrelr
#@ create_cell {vss1left vss1right vss1top vss1bottom} pv0i
#@ create_cell {vdd1left vdd1right vdd1top vdd1bottom} pvdi
#@ create_cell {vss2left vss2right vss2top vss2bottom} pv0a
#@ create_cell {vdd2left vdd2right vdd2top vdd2bottom} pvda
#@ 
#@ # Define corner pad locations
#@ set_pad_physical_constraints -pad_name "cornerul" -side 1
#@ set_pad_physical_constraints -pad_name "cornerur" -side 2
#@ set_pad_physical_constraints -pad_name "cornerlr" -side 3
#@ set_pad_physical_constraints -pad_name "cornerll" -side 4
#@ 
#@ # Define signal and PG  pad locations
#@ 
#@ # Left side
#@ set_pad_physical_constraints -pad_name "pad_iopad_0" -side 1 -order 1
#@ set_pad_physical_constraints -pad_name "pad_iopad_1" -side 1 -order 2
#@ set_pad_physical_constraints -pad_name "pad_iopad_2" -side 1 -order 3
#@ set_pad_physical_constraints -pad_name "pad_iopad_3" -side 1 -order 4
#@ set_pad_physical_constraints -pad_name "pad_iopad_4" -side 1 -order 5
#@ set_pad_physical_constraints -pad_name "pad_iopad_5" -side 1 -order 6
#@ set_pad_physical_constraints -pad_name "pad_iopad_6" -side 1 -order 7
#@ set_pad_physical_constraints -pad_name "pad_iopad_7" -side 1 -order 8
#@ set_pad_physical_constraints -pad_name "pad_iopad_8" -side 1 -order 9
#@ set_pad_physical_constraints -pad_name "vdd2left" -side 1 -order 10
#@ set_pad_physical_constraints -pad_name "vdd1left" -side 1 -order 11
#@ set_pad_physical_constraints -pad_name "vss1left" -side 1 -order 12
#@ set_pad_physical_constraints -pad_name "vss2left" -side 1 -order 13
#@ set_pad_physical_constraints -pad_name "pad_iopad_9" -side 1 -order 14
#@ set_pad_physical_constraints -pad_name "pad_iopad_10" -side 1 -order 15
#@ set_pad_physical_constraints -pad_name "pad_iopad_11" -side 1 -order 16
#@ set_pad_physical_constraints -pad_name "pad_iopad_12" -side 1 -order 17
#@ set_pad_physical_constraints -pad_name "pad_iopad_13" -side 1 -order 18
#@ set_pad_physical_constraints -pad_name "pad_iopad_14" -side 1 -order 19
#@ set_pad_physical_constraints -pad_name "pad_iopad_15" -side 1 -order 20
#@ set_pad_physical_constraints -pad_name "pclk_iopad" -side 1 -order 21
#@ set_pad_physical_constraints -pad_name "pll_bypass_iopad" -side 1 -order 22
#@ 
#@ # Top side
#@ set_pad_physical_constraints -pad_name "pc_be_iopad_0" -side 2 -order 1
#@ set_pad_physical_constraints -pad_name "pc_be_iopad_1" -side 2 -order 2
#@ set_pad_physical_constraints -pad_name "pc_be_iopad_2" -side 2 -order 3
#@ set_pad_physical_constraints -pad_name "pc_be_iopad_3" -side 2 -order 4
#@ set_pad_physical_constraints -pad_name "pdevsel_n_iopad" -side 2 -order 5
#@ set_pad_physical_constraints -pad_name "pframe_n_iopad" -side 2 -order 6
#@ set_pad_physical_constraints -pad_name "pgnt_n_iopad" -side 2 -order 7
#@ set_pad_physical_constraints -pad_name "pidsel_iopad" -side 2 -order 8
#@ set_pad_physical_constraints -pad_name "pirdy_n_iopad" -side 2 -order 9
#@ set_pad_physical_constraints -pad_name "vdd2top" -side 2 -order 10
#@ set_pad_physical_constraints -pad_name "vdd1top" -side 2 -order 11
#@ set_pad_physical_constraints -pad_name "vss1top" -side 2 -order 12
#@ set_pad_physical_constraints -pad_name "vss2top" -side 2 -order 13
#@ set_pad_physical_constraints -pad_name "ppar_iopad" -side 2 -order 14
#@ set_pad_physical_constraints -pad_name "pperr_n_iopad" -side 2 -order 15
#@ set_pad_physical_constraints -pad_name "preq_n_iopad" -side 2 -order 16
#@ set_pad_physical_constraints -pad_name "prst_n_iopad" -side 2 -order 17
#@ set_pad_physical_constraints -pad_name "pstop_n_iopad" -side 2 -order 18
#@ set_pad_physical_constraints -pad_name "pserr_n_iopad" -side 2 -order 19
#@ set_pad_physical_constraints -pad_name "ptrdy_n_iopad" -side 2 -order 20
#@ set_pad_physical_constraints -pad_name "sys_clk_iopad" -side 2 -order 21
#@ set_pad_physical_constraints -pad_name "sdr_clk_iopad" -side 2 -order 22
#@ 
#@ # Right side
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_0" -side 3 -order 1
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_1" -side 3 -order 2
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_2" -side 3 -order 3
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_3" -side 3 -order 4
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_4" -side 3 -order 5
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_5" -side 3 -order 6
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_6" -side 3 -order 7
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_7" -side 3 -order 8
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_8" -side 3 -order 9
#@ set_pad_physical_constraints -pad_name "vdd2right" -side 3 -order 10
#@ set_pad_physical_constraints -pad_name "vdd1right" -side 3 -order 11
#@ set_pad_physical_constraints -pad_name "vss1right" -side 3 -order 12
#@ set_pad_physical_constraints -pad_name "vss2right" -side 3 -order 13
#@ set_pad_physical_constraints -pad_name "sdram_A_iopad_9" -side 3 -order 14
#@ set_pad_physical_constraints -pad_name "sdram_BWS_iopad_0" -side 3 -order 15
#@ set_pad_physical_constraints -pad_name "sdram_BWS_iopad_1" -side 3 -order 16
#@ set_pad_physical_constraints -pad_name "sdram_LD_iopad" -side 3 -order 17
#@ set_pad_physical_constraints -pad_name "sdram_RW_iopad" -side 3 -order 18
#@ set_pad_physical_constraints -pad_name "powersave_iopad" -side 3 -order 19
#@ set_pad_physical_constraints -pad_name "scan_en_iopad" -side 3 -order 20
#@ set_pad_physical_constraints -pad_name "pm66en_iopad" -side 3 -order 21
#@ set_pad_physical_constraints -pad_name "test_mode_iopad" -side 3 -order 22
#@ 
#@ # Bottom side
#@ set_pad_physical_constraints -pad_name "sdram_CK_iopad" -side 4 -order 1
#@ set_pad_physical_constraints -pad_name "sdram_CKn_iopad" -side 4 -order 2
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_0" -side 4 -order 3
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_1" -side 4 -order 4
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_2" -side 4 -order 5
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_3" -side 4 -order 6
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_4" -side 4 -order 7
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_5" -side 4 -order 8
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_6" -side 4 -order 9
#@ set_pad_physical_constraints -pad_name "vdd2bottom" -side 4 -order 10
#@ set_pad_physical_constraints -pad_name "vdd1bottom" -side 4 -order 11
#@ set_pad_physical_constraints -pad_name "vss1bottom" -side 4 -order 12
#@ set_pad_physical_constraints -pad_name "vss2bottom" -side 4 -order 13
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_7" -side 4 -order 14
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_8" -side 4 -order 15
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_9" -side 4 -order 16
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_10" -side 4 -order 17
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_11" -side 4 -order 18
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_12" -side 4 -order 19
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_13" -side 4 -order 20
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_14" -side 4 -order 21
#@ set_pad_physical_constraints -pad_name "sdram_DQ_iopad_15" -side 4 -order 22
#@ # -- End source pad_cell_cons.tcl

#@ 
#@ create_floorplan -core_utilization 0.55 -left_io2core 80 -bottom_io2core 80 -right_io2core 80 -top_io2core 80
#@ insert_pad_filler -cell 
#@ 
#@ ####################Planning####################
#@ ### Keepout ###
#@ set_keepout_margin -type hard -all_macros -outer {20 20 20 20} 
#@ create_fp_placement 
#@ ########connect power and ground#######
#@ derive_pg_connection -power_net VDD  -power_pin VDD  -ground_net VSS  -ground_pin VSS
#@ derive_pg_connection -power_net VDD  -ground_net VSS -tie
#@ 
#@ ### Build rings around six groups of macros ###
#@ set_fp_rail_region_constraints  -polygon {{366 1304} {366 1680} {763 1680} {763 1304}}
#@ set_fp_rail_region_constraints  -polygon {{366 940} {366 1300} {625 1300} {625 940}}
#@ set_fp_rail_region_constraints  -polygon {{926 1193} {926 1807} {1454 1807} {1454 1193}}
#@ set_fp_rail_region_constraints  -polygon {{1436 1660} {1436 1794} {1807 1794} {1807 1660}}
#@ set_fp_rail_region_constraints  -polygon {{1500 1300} {1500 1663} {1807 1663} {1807 1300}}
#@ set_fp_rail_region_constraints  -polygon {{1366 366} {1366 776} {1794 776} {1794 366}}
#@ 
#@ 
#@ create_fp_group_block_ring  -nets  {VDD VSS}  -horizontal_ring_layer METAL5 -horizontal_ring_offset 0.78 -horizontal_ring_width 3 -vertical_ring_layer METAL4 -vertical_ring_offset 0.73 -vertical_ring_width 3 -horizontal_strap_layer METAL5 -horizontal_strap_width 3 -vertical_strap_layer METAL4 -vertical_strap_width 3
#@ create_fp_group_block_ring  -nets  {VDD VSS}  -horizontal_ring_layer METAL5 -horizontal_ring_offset 0.78 -horizontal_ring_width 3 -vertical_ring_layer METAL4 -vertical_ring_offset 0.73 -vertical_ring_width 3 -horizontal_strap_layer METAL5 -horizontal_strap_width 3 -vertical_strap_layer METAL4 -vertical_strap_width 3
#@ create_fp_group_block_ring  -nets  {VDD VSS}  -horizontal_ring_layer METAL5 -horizontal_ring_offset 0.78 -horizontal_ring_width 3 -vertical_ring_layer METAL4 -vertical_ring_offset 0.73 -vertical_ring_width 3 -horizontal_strap_layer METAL5 -horizontal_strap_width 3 -vertical_strap_layer METAL4 -vertical_strap_width 3
#@ create_fp_group_block_ring  -nets  {VDD VSS}  -horizontal_ring_layer METAL5 -horizontal_ring_offset 0.78 -horizontal_ring_width 3 -vertical_ring_layer METAL4 -vertical_ring_offset 0.73 -vertical_ring_width 3 -horizontal_strap_layer METAL5 -horizontal_strap_width 3 -vertical_strap_layer METAL4 -vertical_strap_width 3
#@ create_fp_group_block_ring  -nets  {VDD VSS}  -horizontal_ring_layer METAL5 -horizontal_ring_offset 0.78 -horizontal_ring_width 3 -vertical_ring_layer METAL4 -vertical_ring_offset 0.73 -vertical_ring_width 3 -horizontal_strap_layer METAL5 -horizontal_strap_width 3 -vertical_strap_layer METAL4 -vertical_strap_width 3
#@ create_fp_group_block_ring  -nets  {VDD VSS}  -horizontal_ring_layer METAL5 -horizontal_ring_offset 0.78 -horizontal_ring_width 3 -vertical_ring_layer METAL4 -vertical_ring_offset 0.73 -vertical_ring_width 3 -horizontal_strap_layer METAL5 -horizontal_strap_width 3 -vertical_strap_layer METAL4 -vertical_strap_width 3
#@ commit_fp_group_block_ring
#@ 
#@ set_fp_rail_region_constraints -remove
#@ 
#@ 
#@ ## Complete the power grid structure: Ring around individual PLL macro, vertical/horizontal straps, and core ring ##
#@ set_fp_rail_constraints -add_layer  -layer METAL5 -direction horizontal -max_strap 24 -min_strap 2 -min_width 2 -max_width 4 -spacing 0.6
#@ set_fp_rail_constraints -add_layer  -layer METAL4 -direction vertical -max_strap 24 -min_strap 2 -min_width 2 -max_width 4 -spacing 0.6
#@ set_fp_rail_constraints  -set_ring -horizontal_ring_layer { METAL3 } -vertical_ring_layer { METAL2 } -ring_max_width 12 -ring_min_width 10 -extend_strap core_ring
#@ 
#@ set_fp_block_ring_constraints -add -horizontal_layer METAL5 -horizontal_width 3 -horizontal_offset 0.600 -vertical_layer METAL4 -vertical_width 3 -vertical_offset 0.600 -block_type instance  -block {I_CLOCK_GEN/I_PLL_PCI} -net  {VDD VSS}
#@ set_fp_rail_constraints -set_global   -no_routing_over_hard_macros
#@ synthesize_fp_rail  -nets {VDD VSS} -voltage_supply 1.32 -synthesize_power_plan -power_budget 350 -pad_masters { pv0i pvdi }
#@ load_fp_rail_map -nets VDD -type IR -min 0.000000 -max 0.000000 -directory ./pna_output

#@ 
#@ commit_fp_rail
#@ create_power_straps  -direction vertical  -start_at 804.500 -nets VDD -layer METAL2 -width 10.000 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -keep_floating_wire_pieces -ignore_parallel_targets -define_parallel_targets_by_wire_directions -mark_as_ring

#@ create_power_straps  -direction vertical  -start_at 351.250 -nets VDD -layer METAL2 -width 10.000 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -keep_floating_wire_pieces -ignore_parallel_targets -define_parallel_targets_by_wire_directions -mark_as_ring

#@ create_power_straps  -direction horizontal  -start_at 351.250 -nets VDD -layer METAL3 -width 10.000 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -keep_floating_wire_pieces -ignore_parallel_targets -define_parallel_targets_by_wire_directions -mark_as_ring

#@ create_power_straps  -direction horizontal  -start_at 802.450 -nets VDD -layer METAL3 -width 10.000 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -keep_floating_wire_pieces -ignore_parallel_targets -define_parallel_targets_by_wire_directions -mark_as_ring

#@ create_power_straps  -direction vertical  -start_at 793.850 -nets VSS -layer METAL2 -width 10.000 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -keep_floating_wire_pieces -ignore_parallel_targets -define_parallel_targets_by_wire_directions -mark_as_ring

#@ create_power_straps  -direction vertical  -start_at 361.900 -nets VSS -layer METAL2 -width 10.000 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -keep_floating_wire_pieces -ignore_parallel_targets -define_parallel_targets_by_wire_directions -mark_as_ring

#@ create_power_straps  -direction horizontal  -start_at 361.910 -nets VSS -layer METAL3 -width 10.000 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -keep_floating_wire_pieces -ignore_parallel_targets -define_parallel_targets_by_wire_directions -mark_as_ring

#@ create_power_straps  -direction horizontal  -start_at 791.790 -nets VSS -layer METAL3 -width 10.000 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -keep_floating_wire_pieces -ignore_parallel_targets -define_parallel_targets_by_wire_directions -mark_as_ring

#@ create_power_straps  -direction vertical  -start_at 421.380 -nets VDD  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 473.390 -nets VDD  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 524.890 -nets VDD  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 576.390 -nets VDD  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 628.410 -nets VDD  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 679.910 -nets VDD  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 731.410 -nets VDD  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 807.450 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 423.980 -nets VSS  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 476.000 -nets VSS  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 527.500 -nets VSS  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 579.000 -nets VSS  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 631.010 -nets VSS  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 682.510 -nets VSS  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction vertical  -start_at 734.010 -nets VSS  -layer METAL4 -width 2.000 -pitch_within_group 51.650 -start_low_ends coordinate  -start_low_ends_coordinate 356.910 -start_high_ends coordinate  -start_high_ends_coordinate 796.790 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 421.230 -nets VDD  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 473.070 -nets VDD  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 524.100 -nets VDD  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 575.940 -nets VDD  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 626.970 -nets VDD  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 678.000 -nets VDD  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 729.840 -nets VDD  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 346.250 -start_high_ends coordinate  -start_high_ends_coordinate 809.500 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 423.830 -nets VSS  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 475.670 -nets VSS  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 526.700 -nets VSS  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 578.540 -nets VSS  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 629.570 -nets VSS  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 680.600 -nets VSS  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ create_power_straps  -direction horizontal  -start_at 732.440 -nets VSS  -layer METAL5 -width 2.000 -pitch_within_group 51.400 -start_low_ends coordinate  -start_low_ends_coordinate 356.900 -start_high_ends coordinate  -start_high_ends_coordinate 798.850 -extend_low_ends off -extend_high_ends off -num_placement_strap 1 -keep_floating_wire_pieces  -ignore_parallel_targets -define_parallel_targets_by_wire_directions 

#@ 
#@ preroute_instances  -ignore_macros -ignore_cover_cells -primary_routing_layer pin -extend_for_multiple_connections -extension_gap 20
#@ preroute_instances  -ignore_pads -ignore_cover_cells -primary_routing_layer pin
#@ preroute_standard_cells -extend_for_multiple_connections  -extension_gap 20 -connect horizontal  -remove_floating_pieces  -do_not_route_over_macros  -fill_empty_rows  -port_filter_mode off -cell_master_filter_mode off -cell_instance_filter_mode off -voltage_area_filter_mode off -route_type {P/G Std. Cell Pin Conn}
#@ #analyze_fp_rail  -nets {VDD VSS} -power_budget 80 -voltage_supply 1# 
#@ create_fp_placement -incremental all
#@ 
#@ #########################################################################
#@ ########################<<< Place_opt>>>#################################
#@ #########################################################################
#@ read_sdc  -version Latest "../../dc/run/netlist/risc8.sdc"
#@ # GUI Debug: Building dc from empty. -- Time: 2sec 183ms

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/syn/all_command_option_def.tcl

#@ define_proc_attributes all_physical_only_cells -info "Get the collection of physical only cells" -define_args {
#@ { -coordinates "coordinates of bounding box" "llx lly urx ury" string {optional}} 
#@ { -lib_cells "get cells related to these objects" "objects" list {optional}} 
#@ { -cell_name "list of cell name patterns and collections" "patterns" list {optional}} 
#@ { "" "Existing collection" "arguments" list {optional}} 
#@ }
#@ define_proc_attributes all_physical_only_nets  -info "Get the collection of physical only nets" -define_args {
#@ { "" "list of cell name patterns and collections" "arguments" list {optional}} 
#@ } 
#@ define_proc_attributes all_drc_violated_nets -info "Returns all DRC violated nets" -define_args { 
#@ { -max_capacitance "max Cap DRC violated nets" "" string {optional}} 
#@ { -max_transition "max transition time DRC violated nets" "" string {optional}} 
#@ { -max_fanout "max fanout DRC violated nets" "" string {optional}}
#@ { -threshold "Captures all values more than or equal to threshold" "threshold" string {optional}} 
#@ { -bound "Captures all values less than or equal to bound bound" "upper" string {optional}} 
#@ { "" "objects patterns OR collection" "arguments"  list {optional}} 
#@ }
#@ define_proc_attributes all_fanin -info "return pins or cells in transitive fanin" -define_args { 
#@ { -to "set of sink ports, pins, or nets" "sink_list" list {optional}} 
#@ { -startpoints_only  "return only the timing startpoints" "" string {optional}} 
#@ { -exclude_bboxes "black-boxes are not included in return-set" "" string {optional}} 
#@ { -break_on_bboxes  "traversal stops at black-boxes" "" string {optional}} 
#@ { -only_cells "only cells are included in the return-set" "" string {optional}} 
#@ { -flat "trace entire design instead of just current hierarchy" "" string {optional}} 
#@ { -levels "maximum number of levels of logic to traverse" "n" string {optional}} 
#@ { -trace_arcs "Type of network arcs to trace. Values: timing, all" "arc_type" string {optional}}
#@ }
#@ define_proc_attributes all_high_fanout -info "Returns all high fanout objects" -define_args { 
#@ { -nets "high fanout nets" "" string {optional}} 
#@ { -threshold "high fanout threshold: value>=0" "threshold" string {optional}} 
#@ { -through_buf_inv "treat buffers and inverters as transparent -check for transitive fanout" "" string {optional}} 
#@ { "" "objects patterns OR collection" "arguments" string {optional}} 
#@ }
#@ define_proc_attributes all_ideal_nets -info "Returns all ideal nets" -define_args { 
#@ { "" "objects patterns OR collection" "arguments" string {optional}} 
#@ }
#@ define_proc_attributes all_inputs -info "return input ports" -define_args { 
#@ { -clock "ports with input delay relative to clock" "clock" string {optional}} 
#@ { -edge_triggered "ports with non-level-sensitive input delay" "" string {optional}} 
#@ { -level_sensitive "ports with level-sensitive input delay" "" string {optional}} 
#@ }
#@ define_proc_attributes all_outputs -info "return output ports" -define_args { 
#@ { -clock "ports with output delay relative to clock" "clock" string {optional}} 
#@ { -edge_triggered "ports with non-level-sensitive output delay" "" string {optional}} 
#@ { -level_sensitive "ports with level-sensitive output delay" "" string {optional}} 
#@ }
#@ define_proc_attributes all_threestate -info "Returns all threestate objects" -define_args { 
#@ { -nets "threestate nets" "" string {optional}} 
#@ { "" "objects patterns OR collection" "arguments" string {optional}} 
#@ }
#@ define_proc_attributes all_dont_touch -info "Returns all dont touch objects" -define_args { 
#@ { -nets "Dont touch nets" "" string {optional}} 
#@ { -cells "Dont touch cells" "" string {optional}} 
#@ { "" "Dont touch patterns OR collections" "patterns" string {optional}} 
#@ }
#@ define_proc_attributes all_size_only_cells -info "Returns all size_only cells" -define_args { 
#@ { "" "Object patterns OD collections" "patterns" string {optional}} 
#@ }
#@ define_proc_attributes all_clocks -info "return all clocks in the current design"  
#@ define_proc_attributes all_designs -info "return all designs" 
#@ define_proc_attributes all_registers  -info "create a collection of register cells or pins" -define_args { 
#@ { -no_hierarchy "only search the top level of hierarchy" "" string {optional}} 
#@ {-rise_clock "return registers triggered by rise edge of this clock" "rise_clock" string {optional}}
#@ {-fall_clock "return registers triggered by rise edge of this clock" "fall_clock" string {optional}}
#@ { -clock "return registers of this clock" "clock" string {optional}} 
#@ { -cells "return cells - this is the default" "" string {optional}} 
#@ { -data_pins "return data_pins" "" string {optional}} 
#@ { -clock_pins "return clock_pins" "" string {optional}} 
#@ { -slave_clock_pins "return slave_clock_pin" "" string {optional}} 
#@ { -inverted_output "return FF's with inverted output phase" "" string {optional}} 
#@ { -output_pins "return output_pins" "" string {optional}} 
#@ { -level_sensitive "only consider level sensitive registers" "" string {optional}} 
#@ { -edge_triggered "only consider edge triggered register" "" string {optional}} 
#@ { -master_slave "only consider master/slave registers" "" string {optional}} 
#@ }
#@ define_proc_attributes all_critical_cells -info "return critical cells" -define_args { 
#@ { -slack_range "critical range to select cells:value>=0" "range_value" string {optional}} 
#@ }
#@ define_proc_attributes all_critical_pins -info "return critical pins" -define_args { 
#@ { -slack_range "critical range to select cells:value>=0" "range_value" string {optional}} 
#@ { -type "pintype: Values: endpoint, startpoint" "pin_type" string {optional}} 
#@ }
#@ define_proc_attributes get_magnet_cells -info "return magnet cells collection" -define_args {
#@ { -stop_by_sequential_cells "don't pull sequential cells" "" string {optional}} 
#@ { -exclude_buffers "skip through buffers in levels" "" string {optional}} 
#@ { -exclude_cells "list of excluded cells list" "" string {optional}}
#@ { -logical_level "number of logical levels to pull for placement" "integer" string {optional}} 
#@ { -stop_points "list of stop points where to stop magnetizing paths" "object_list" list {optional}} 
#@ { "" "a list of magnet objects" "magnet_objects" list {optional}} 
#@ }
#@ define_proc_attributes all_fanout -info "return pins or cells in transitive fanout" -define_args {
#@ {-clock_tree "return all clock tree components in design" "" string {optional}}
#@ {-from "set of source ports, pins, or nets" "source_list" list {optional}}
#@ {-endpoints_only "return only the timing endpoints" "" string {optional}}
#@ {-exclude_bboxes "black-boxes are not included in return-set" "" string {optional}}
#@ {-break_on_bboxes "traversal stops at black-boxes" "" string {optional}}
#@ {-only_cells "only cells are included in the return-set" "" string {optional}}
#@ {-flat "trace entire design instead of just current hierarchy" "" string {optional}}
#@ {-levels "maximum number of levels of logic to traverse" "n" string {optional}}
#@ {-trace_arcs "Type of network arcs to trace. Values: timing, all" "arc_type" string {optional}}
#@ }
#@ define_proc_attributes all_physical_only_ports -info " Get the collection of physical only ports" -define_args {
#@ {"" "list of cell name patterns and collections" "arguments" list {optional}}
#@ }
#@ define_proc_attributes get_matching_nets_for_pattern -info "Get matched nets for a certain net pattern" -define_args { 
#@ { -pattern "pattern id" "integer" string {optional}} 
#@ { -optimizable "Return all nets that can be optimized" "" string {optional}} 
#@ { -transition_lower_limit "nets with transition equal or greater than lower limit" "lower_limit" string {optional}} 
#@ { -transition_upper_limit "nets with transition less than upper limit" "upper_limit" string {optional}} 
#@ { -setup_slack_lower_limit "nets with slack equal or greater than lower limit" "lower_limit" string {optional}} 
#@ { -setup_slack_upper_limit "nets with slack less than upper limit" "upper_limit" string {optional}} 
#@ { -hold_slack_lower_limit "nets with hold slack equal or greater than lower limit" "lower_limit" string {optional}} 
#@ { -hold_slack_upper_limit "nets with hold slack less than upper limit" "upper_limit" string {optional}} 
#@ }
#@ # -- End source /opt/synopsys/icc-201506/auxx/syn/all_command_option_def.tcl

#@ #read_def chip.scandef
#@ set_dont_touch_placement [all_macro_cells]
#@ check_physical_design -stage pre_place_opt
#@ source -encrypted /opt/synopsys/icc-201506/auxx/syn/psyn/analyze_physical_design.tcl.e

#@ analyze_physical_design_internal {pre_place_opt} {} 1 1 {} {} {0}

#@ 
#@ 
#@ derive_pg_connection -power_net VDD  -power_pin VDD  -ground_net VSS  -ground_pin VSS
#@ derive_pg_connection -power_net VDD  -ground_net VSS -tie
#@ 
#@ 
#@ 
#@ #set_switching_activity -toggle_rate 0.03 -static_probability 0.5 [get_ports  "ppar_in pframe_n_in ptrdy_n_in pirdy_n_in pdevsel_n_in pstop_n_in pperr_n_in pserr_n_in"]
#@ 
#@ #########################################################################
#@ ###########################<<< CTS>>>####################################
#@ #########################################################################
#@ set power_cg_auto_identify true
#@ 
#@ check_physical_design -stage pre_clock_opt 
#@ source -encrypted /opt/synopsys/icc-201506/auxx/syn/psyn/analyze_physical_design.tcl.e

#@ analyze_physical_design_internal {pre_clock_opt} {} 1 1 {} {} {0}

#@ 
#@ set_fix_hold [all_clocks]
#@ set physopt_area_critical_range 0.1
#@ clock_opt -fix_hold_all_clocks -no_clock_route
#@ derive_pg_connection -power_net VDD  -power_pin VDD  -ground_net VSS  -ground_pin VSS
#@ derive_pg_connection -power_net VDD  -ground_net VSS -tie
#@ 
#@ 
#@ 
#@ 
#@ #########################################################################
#@ ############################<<< Route>>>#################################
#@ #########################################################################
#@ check_routeability -error_cell risc8.err
#@ source ../../IC_Compiler_2010.12-SP2/lab6_chip_finishing/scripts/cb13_6m_antenna.tcl
#@ # -- Starting source ../../IC_Compiler_2010.12-SP2/lab6_chip_finishing/scripts/cb13_6m_antenna.tcl

#@ #####################################################################################
#@ # Define Antenna Rules
#@ 
#@ # For lab use only!  Obtain correct value from your library vendor.
#@ set ratio 60
#@ set metal_ratio 60
#@ set_parameter -module droute -name defaultDiodeProtect -value 0.5
#@ set dmode 2
#@ 
#@ set_parameter -module droute -name doAntennaConx -value 4
#@ # report_parameter -module droute
#@ 
#@ #dbClearLibAntennaRules _libId
#@ remove_antenna_rules
#@ 
#@ #dbDefineAntennaRule _libId 1 2 125 20
#@ define_antenna_rule -mode 1 -diode_mode $dmode -metal_ratio $metal_ratio -cut_ratio 20
#@ 
#@ #dbAddAntennaLayerRule _libId 1 "METAL" 125 '( 0.203 0 400 3700)
#@ define_antenna_layer_rule -mode 1 -layer "METAL"  -ratio $ratio  -diode_ratio {0.203 0 400 3700}
#@ define_antenna_layer_rule -mode 1 -layer "METAL2" -ratio $ratio  -diode_ratio {0.203 0 400 3700}
#@ define_antenna_layer_rule -mode 1 -layer "METAL3" -ratio $ratio  -diode_ratio {0.203 0 400 3700}
#@ define_antenna_layer_rule -mode 1 -layer "METAL4" -ratio $ratio  -diode_ratio {0.203 0 400 3700}
#@ define_antenna_layer_rule -mode 1 -layer "METAL5" -ratio $ratio  -diode_ratio {0.203 0 400 3700}
#@ define_antenna_layer_rule -mode 1 -layer "METAL6" -ratio $ratio  -diode_ratio {0.203 0 8000 50000}
#@ 
#@ define_antenna_layer_rule -mode 1 -layer "VIA"  -ratio 20 -diode_ratio {0.203 0 83.33 75}
#@ define_antenna_layer_rule -mode 1 -layer "VIA2" -ratio 20 -diode_ratio {0.203 0 83.33 75}
#@ define_antenna_layer_rule -mode 1 -layer "VIA3" -ratio 20 -diode_ratio {0.203 0 83.33 75}
#@ define_antenna_layer_rule -mode 1 -layer "VIA4" -ratio 20 -diode_ratio {0.203 0 83.33 75}
#@ define_antenna_layer_rule -mode 1 -layer "VIA5" -ratio 20 -diode_ratio {0.203 0 83.33 75}
#@ 
#@ #report_antenna_rules
#@ #report_antenna_ratio
#@ 
#@ 
#@ 
#@ 
#@ # Man Pages:
#@ #####################################################################################
#@ # 
#@ # define_antenna_rule   2.  Synopsys Commands       Command Reference
#@ # 
#@ # NAME
#@ #           define_antenna_rule
#@ #                          Defines an advanced antenna rule for the
#@ #                          specified mode and stores it in the
#@ #                          library.
#@ # 
#@ # SYNTAX
#@ #           status_value define_antenna_rule
#@ #                  [mw_lib]
#@ #                  -mode mode
#@ #                  -diode_mode diode_mode
#@ #                  -metal_ratio metal_ratio
#@ #                  -cut_ratio cut_ratio
#@ #                  [-protected_metal_scale metal_scale]
#@ #                  [-protected_cut_scale cut_scale]
#@ # 
#@ #   Data Types
#@ #           mw_lib          list
#@ #           mode            int
#@ #           diode_mode      int
#@ #           metal_ratio     float
#@ #           cut_ratio       float
#@ #           metal_scale     float
#@ #           cut_scale       float
#@ # 
#@ # ARGUMENTS
#@ #           mw_lib         Specifies the Milkyway library to be
#@ #                          updated. The value of mw_lib can be a
#@ #                          library name or a one-element collection
#@ #                          of a library. The mw_lib option is
#@ #                          optional. The default is to use the
#@ #                          current Milkyway library.
#@ # 
#@ #           -mode mode     Defines the way antenna areas are
#@ #                          computed.  Valid values: 1-Uses polygon
#@ #                          area, ignoring all lower-layer segments.
#@ #                          2-Uses polygon area, including all
#@ #                          lower-layer segments to the input pins.
#@ #                          3-Uses polygon area, including all
#@ #                          lower-layer segments. 4-Uses side-wall
#@ #                          area, ignoring all lower-layer segments.
#@ #                          5-Uses side-wall area, including all
#@ #                          lower-layer segments to the input pins.
#@ #                          6-Uses side-wall area, including all
#@ #                          lower-layer segments.
#@ # 
#@ #                          Note that only one rule can be defined
#@ #                          for every mode. If two commands contain
#@ #                          the same mode number, the second command
#@ #                          will overwrite the first one.
#@ # 
#@ #           -diode_mode diode_mode
#@ #                          Defines the protection capability of the
#@ #                          diode. By default, all output pins are
#@ #                          considered as a diode.  Valid values:
#@ #                          0-Output pin cannot protect antenna.
#@ #                          1-Any diode can provide unlimited
#@ #                          protection.  2-Diode protection is
#@ #                          limited; if more than one diode is
#@ #                          connected, the largest value of max-
#@ #                          antenna-ratio of all diodes will be
#@ #                          used.  3-Diode protection is limited; if
#@ #                          more than one diode is connected, the
#@ #                          sum of max-antenna-ratio of all diodes
#@ #                          will be used.  4-Diode protection is
#@ #                          limited; if more than one diode is
#@ #                          connected, the sum of all diode-
#@ #                          protection value of all diodes will be
#@ #                          used to compute max-antenna-ratio.  5-
#@ #                          Diode protection is limited; the maximum
#@ #                          diode-protection value of all diodes
#@ #                          will be used to calculate the equivalent
#@ #                          gate area.  6-Diode protection is
#@ #                          limited; the sum of all diode-protection
#@ #                          value of all diodes will be used to
#@ #                          calculate the equivalent gate area.  7-
#@ #                          Diode protection is limited; the maximum
#@ #                          diode-protection value of all diodes
#@ #                          will be used to calculate the equivalent
#@ #                          metal area.  8-Diode protection is
#@ #                          limited; the sum of all diode-protection
#@ #                          value of all diodes will be used to
#@ #                          calculate the equivalent metal area.
#@ # 
#@ #           -metal_ratio metal_ratio
#@ #                          Maximum allowable ratio for metal area
#@ #                          to gate size if the metal layer is not
#@ #                          defined with define_antenna_layer_rule.
#@ # 
#@ #                          If this value is zero, the ratio will be
#@ #                          ignored.
#@ # 
#@ #                          Valid value: any non-negative number.
#@ # 
#@ #           -cut_ratio cut_ratio
#@ #                          Maximum allowable ratio for cut area to
#@ #                          gate size if the cut layer is not
#@ #                          defined with define_antenna_layer_rule.
#@ # 
#@ #                          If this value is zero, the ratio will be
#@ #                          ignored.
#@ # 
#@ #                          Valid value: any non-negative number.
#@ # 
#@ #           -protected_metal_scale metal_scale
#@ #                          The option is used when mode is 2 or 5
#@ #                          only.  The area of the metal layer that
#@ #                          is protected by diode will be scaled by
#@ #                          this value. By default, the value is set
#@ #                          to 1.0.
#@ # 
#@ #                          If this value is zero, the scale will be
#@ #                          ignored.
#@ # 
#@ #                          Valid value: any non-negative number.
#@ # 
#@ #           -protected_cut_scale cut_scale
#@ #                          The option is used when mode is 2 or 5
#@ #                          only.  The area of the cut layer that is
#@ #                          protected by diode will be scaled by
#@ #                          this value. By default, the value is set
#@ #                          to 1.0.
#@ # 
#@ #                          If this value is zero, the scale will be
#@ #                          ignored.
#@ # 
#@ #                          Valid value: any non-negative number.
#@ # 
#@ # DESCRIPTION
#@ #           This command defines an advanced antenna rule for the
#@ #           specified mode and stores it in the library.  The
#@ #           command returns a status indicating success or failure.
#@ # 
#@ # EXAMPLES
#@ #             prompt> define_antenna_rule -mode 1 -diode_mode 2       -metal_ratio 1000 -cut_ratio 0
#@ # 
#@ # SEE ALSO
#@ #           define_antenna_layer_ratio_scale(2)
#@ #           define_antenna_layer_rule(2)
#@ #           report_antenna_rules(2)
#@ #           remove_antenna_rules(2)
#@ # 
#@ #####################################################################################
#@ # 
#@ # NAME
#@ #           define_antenna_layer_rule
#@ #                          Defines an advanced antenna rule for the
#@ #                          specified layer and stores it in the
#@ #                          library.
#@ # 
#@ # SYNTAX
#@ #           status_value define_antenna_layer_rule
#@ #                  [mw_lib]
#@ #                  -mode mode
#@ #                  -layer layer_name
#@ #                  -ratio ratio
#@ #                  -diode_ratio diode_ratio
#@ # 
#@ #   Data Types
#@ #           mw_lib          list
#@ #           mode            int
#@ #           layer_name      string
#@ #           ratio           float
#@ #           diode_ratio     list
#@ # 
#@ # ARGUMENTS
#@ #           mw_lib         Specifies the Milkyway library to be
#@ #                          updated. The value of mw_lib can be a
#@ #                          library name or a one-element collection
#@ #                          of a library. The mw_lib option is
#@ #                          optional. The default is to use the
#@ #                          current Milkyway library.
#@ # 
#@ #           -mode mode     Defines the way antenna areas are
#@ #                          computed.  Valid values: 1-Uses polygon
#@ #                          area, ignoring all lower-layer segments.
#@ #                          2-Uses polygon area, including all
#@ #                          lower-layer segments to the input pins.
#@ #                          3-Uses polygon area, including all
#@ #                          lower-layer segments. 4-Uses side-wall
#@ #                          area, ignoring all lower-layer segments.
#@ #                          5-Uses side-wall area, including all
#@ #                          lower-layer segments to the input pins.
#@ #                          6-Uses side-wall area, including all
#@ #                          lower-layer segments.
#@ # 
#@ #                          Note that only one rule can be defined
#@ #                          for every mode. If two commands contain
#@ #                          the same mode number, the second command
#@ #                          will overwrite the first one.
#@ # 
#@ #           -layer layer_name
#@ #                          Name of the valid metal layer or cut
#@ #                          layer in the library.
#@ # 
#@ #           -ratio ratio   The maximum allowable ratio of the
#@ #                          antenna area to the gate area if the
#@ #                          antenna is not protected by any diode.
#@ # 
#@ #                          Valid values: Any number.
#@ # 
#@ #           -diode_ratio diode_ratio
#@ #                          Specify the allowable ratio in the
#@ #                          antenna area to the gate area if the
#@ #                          antenna is protected by a diode.  Valid
#@ #                          values:  {v0 v1 v2 v3 [v4]}
#@ # 
#@ #                          If the output pin protection value is
#@ #                          dp, the allowable ratio will be: ((dp +
#@ #                          v1) * v2 + v3), if (dp) > (v0)
#@ #                          layer_max_ratio, if (dp) <= (v0)
#@ # 
#@ #                          The dp is specified in the CLF file.
#@ # 
#@ #                          The default value of diode_ratio is {0 1
#@ #                          0 0}.
#@ # 
#@ # DESCRIPTION
#@ #           This command defines an advanced antenna rule for the
#@ #           specified layer and stores it in the library.  The
#@ #           command returns a status indicating success or failure.
#@ # 
#@ # EXAMPLES
#@ #             prompt> define_antenna_layer_rule 4 metal1 400 {0.336 -0.5 400 2400
#@ # 
#@ # SEE ALSO
#@ #           define_antenna_rule(2)
#@ #           report_antenna_rules(2)
#@ #           remove_antenna_rules(2)
#@ # 
#@ # 
#@ #####################################################################################
#@ # -- End source ../../IC_Compiler_2010.12-SP2/lab6_chip_finishing/scripts/cb13_6m_antenna.tcl

#@ source ../../IC_Compiler_2010.12-SP2/lab5_route/scripts/common_route_si_settings_zrt_icc.tcl
#@ # -- Starting source ../../IC_Compiler_2010.12-SP2/lab5_route/scripts/common_route_si_settings_zrt_icc.tcl

#@ ##########################################################################################
#@ # Version: C-2009.06 (Jun 29th, 2009)
#@ # Copyright (C) 2007-2009 Synopsys, Inc. All rights reserved.
#@ ##########################################################################################
#@ 
#@ echo "\tLoading :\t\t [info script]"
#@ 
#@ #########################################
#@ #           TIMING OPTIONS              #
#@ #########################################
#@ 
#@ ## By default, Xtalk Delta Delay is enabled for all flows
#@ set_si_options -delta_delay true                 -route_xtalk_prevention true                -route_xtalk_prevention_threshold 0.25
#@ 
#@ ## For the QoR flow, we also enable min_delta_delay
#@ set_si_options -min_delta_delay true 
#@ 
#@ #########################################
#@ #    MAX_TRAN FIXING                    #
#@ #########################################
#@ ## From 2006.06-SP4 onwards, route_opt will NOT fix nor report Delta Max 
#@ ## Tran violations.  Hence all max_tran violations exclude the portion 
#@ ## that is introduced by Xtalk.
#@ ## If you want to change this behavior, and fix max_transition violations 
#@ ## including these caused by Xtalk, please use the switch -max_transition_mode
#@ ## in set_si_options. Keep in mind that you can expect a runtime hit of up 
#@ ## to 2x in DRC fixing during route_opt.
#@ 
#@ # set_si_options -delta_delay true #                -route_xtalk_prevention true #                -route_xtalk_prevention_threshold 0.25 #                -max_transition_mode total_slew
#@ 
#@ #########################################
#@ #      ADVANCED TIMING FEATURES         #
#@ #########################################
#@ 
#@ ## if static noise (aka glitches) needs to be reduced, please use the extra options below :
#@ # set_si_options -delta_delay true #                -static_noise true #                -static_noise_threshold_above_low 0.35 #                -static_noise_threshold_below_high 0.35 #                -route_xtalk_prevention true #                -route_xtalk_prevention_threshold 0.25
#@ 
#@ 
#@ set_delay_calculation -arnoldi
#@ set ICC_FULL_ARNOLDI FALSE 
#@ if {$ICC_FULL_ARNOLDI} { 
#@     echo "SCRIPT-Info : Enabling Arnoldi for all nets of the design"
#@     set rc_rd_more_than_rnet_arnoldi_threshold 100000000
#@ } 
#@ 
#@ ## if you want to enable Timing Windows during XDD calculation, please use :
#@ #  set_si_options -timing_window true
#@ 
#@ ########################################
#@ #          ZROUTE OPTIONS              #
#@ ########################################
#@ 
#@ #### MultiThreading - extraction, MCMM timing, ZRoute
#@ set ICC_NUM_CORES 1
#@ set_host_options -max_cores $ICC_NUM_CORES
#@ 
#@ ## Zroute Global route options
#@ # set_route_zrt_global_options 
#@ 
#@ ## Zroute Track assign options
#@ # set_route_zrt_track_options 
#@ 
#@ ## Zroute Detail route options
#@ # set_route_zrt_detail_options
#@ 
#@ ## Set Area Critical Range
#@ ## Typical value: 3-4 percent of critical clock period
#@ #set_app_var physopt_area_critical_range 0.32 
#@ 
#@ ## Set Power Critical Range
#@ ## Typical value: 3-4 percent of critical clock period
#@ #set_app_var physopt_power_critical_range 0.32
#@ 
#@ ########################################
#@ #       ROUTE_OPT ONLY OPTIONS         #
#@ ########################################
#@ 
#@ ## Disable fanout opto during route_opt. Max fanout has to be taken care of earlier in the flow.
#@ set_app_var psyn_onroute_disable_fanout_drc true
#@ 
#@ ##default is false - set to skip second report_qor in route_opt
#@ set_app_var routeopt_skip_report_qor true  
#@ 
#@ # set_app_var routeopt_xtalk_reduction_setup_threshold 0.10
#@ 
#@ set ICC_DBL_VIA TRUE
#@ set ICC_DBL_VIA_FLOW_EFFORT "LOW"
#@ if {$ICC_DBL_VIA } {
#@   define_zrt_redundant_vias -from_via { VIA12A VIA12B VIA23 VIA34 VIA45 VIA56 }         -to_via { VIA12A VIA12B VIA23 VIA34 VIA45 VIA56 }         -to_via_x_size { 1 1 1 1 1 1 }        -to_via_y_size { 2 2 2 2 2 2 }
#@ 
#@   if {$ICC_DBL_VIA_FLOW_EFFORT != "LOW"} {
#@     set_route_zrt_detail_options -optimize_wire_via_effort_level high    ;#low is default
#@     set_route_zrt_common_options -concurrent_redundant_via_mode reserve_space
#@   }
#@   if {$ICC_DBL_VIA_FLOW_EFFORT == "HIGH"} {
#@     #low is default: low|medium|high
#@     set_route_zrt_common_options -concurrent_redundant_via_effort_level medium   
#@     #set_route_zrt_common_options -eco_route_concurrent_redundant_via_mode reserve_space
#@     #low is default: low|medium|high
#@     #set_route_zrt_common_options -eco_route_concurrent_redundant_via_effort_level low  
#@   }
#@ }
#@ 
#@ set ICC_FIX_ANTENNA 0
#@ set ANTENNA_RULES_FILE ""
#@ 
#@ if {$ICC_FIX_ANTENNA } {
#@ 
#@   ########################################
#@   #        ANTENNA JOGGING FIXING        #
#@   ########################################
#@  
#@   if {[file exists [which $ANTENNA_RULES_FILE]]} {
#@        set_route_zrt_detail_options -antenna true
#@        source -echo $ANTENNA_RULES_FILE
#@    } else {
#@        echo "SCRIPT-Info : Antenna rules file does not exist"
#@        echo "SCRIPT-Info : Turning off antenna fixing"
#@        set_route_zrt_detail_options -antenna false
#@    }
#@ 
#@ } else {
#@        echo "SCRIPT-Info : Turning off antenna fixing"
#@        set_route_zrt_detail_options -antenna false
#@   }
#@ 
#@ # -- End source ../../IC_Compiler_2010.12-SP2/lab5_route/scripts/common_route_si_settings_zrt_icc.tcl

#@ route_opt
#@ 
#@ 
#@ derive_pg_connection -power_net VDD  -power_pin VDD  -ground_net VSS  -ground_pin VSS
#@ derive_pg_connection -power_net VDD  -ground_net VSS -tie
#@ 
#@ 
#@ 
#@ if { ! [ file exists outputs ] } { file mkdir ../outputs }
#@ report_timing -max_paths 10  > ../outputs/$design_name.rpt
#@ report_constraints -all      >> ../outputs/$design_name.rpt
#@ report_power                 >> ../outputs/$design_name.rpt
#@ report_placement_utilization >> ../outputs/$design_name.rpt
#@ 
#@ set_write_stream_options -map_layer ../outputs/macro.map -child_depth 20 -flatten_via
#@ write_stream -format gds -lib_name ../outputs -cells {rics8_icc} $design_name.gds
#@ write_sdf -version 1.0 -context verilog -load_delay net $design_name.sdf
#@ write_verilog -unconnected_ports -diode_ports -wire_declaration -keep_backslash_before_hiersep -no_physical_only_cells ${design_name}_route.v
#@ start_gui
#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/iwidgets4.0.2/lib/iwidgets/iwidgets.tcl

#@ #
#@ # iwidgets.tcl
#@ # ----------------------------------------------------------------------
#@ # Invoked automatically by [incr Tk] upon startup to initialize
#@ # the [incr Widgets] package.
#@ # ----------------------------------------------------------------------
#@ #  AUTHOR: Mark L. Ulferts               EMAIL: mulferts@spd.dsccc.com
#@ #
#@ #  @(#) $Id: iwidgets.tcl.in,v 1.5 2007/06/10 19:28:16 hobbs Exp $
#@ # ----------------------------------------------------------------------
#@ #                Copyright (c) 1995  Mark L. Ulferts
#@ # ======================================================================
#@ # See the file "license.terms" for information on usage and
#@ # redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ package require Tcl 8.0
#@ package require Tk 8.0
#@ package require Itcl 3.2
#@ package require Itk 3.2
#@ 
#@ namespace eval ::iwidgets {
#@     namespace export *
#@ 
#@     variable library [file dirname [info script]]
#@     variable version 4.0.2
#@ 
#@     lappend auto_path $iwidgets::library
#@     variable subdir
#@     foreach subdir {generic scripts} {
#@ 	if {[file isdirectory [file join $iwidgets::library $subdir]]} {
#@ 	    lappend auto_path [file join $iwidgets::library $subdir]
#@ 	}
#@     }
#@     unset subdir
#@ }
#@ 
#@ package provide Iwidgets $iwidgets::version
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/iwidgets4.0.2/lib/iwidgets/iwidgets.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/syn/fp/bw/pkgIndex.tcl

#@ if {[catch {package require Tcl}]} return
#@ package ifneeded BWidget 1.9.2 "    package require Tk 8.1.1;    [list tclPkgSetup $dir BWidget 1.9.2 {
#@ {arrow.tcl source {ArrowButton ArrowButton::create ArrowButton::use}}
#@ {labelframe.tcl source {LabelFrame LabelFrame::create LabelFrame::use}}
#@ {labelentry.tcl source {LabelEntry LabelEntry::create LabelEntry::use}}
#@ {bitmap.tcl source {Bitmap::get Bitmap::use}}
#@ {button.tcl source {Button Button::create Button::use}}
#@ {buttonbox.tcl source {ButtonBox ButtonBox::create ButtonBox::use}}
#@ {combobox.tcl source {ComboBox ComboBox::create ComboBox::use}}
#@ {label.tcl source {Label Label::create Label::use}}
#@ {entry.tcl source {Entry Entry::create Entry::use}}
#@ {pagesmgr.tcl source {PagesManager PagesManager::create PagesManager::use}}
#@ {notebook.tcl source {NoteBook NoteBook::create NoteBook::use}}
#@ {panedw.tcl source {PanedWindow PanedWindow::create PanedWindow::use}}
#@ {scrollw.tcl source {ScrolledWindow ScrolledWindow::create ScrolledWindow::use}}
#@ {scrollview.tcl source {ScrollView ScrollView::create ScrollView::use}}
#@ {scrollframe.tcl source {ScrollableFrame ScrollableFrame::create ScrollableFrame::use}}
#@ {panelframe.tcl source {PanelFrame PanelFrame::create PanelFrame::use}}
#@ {progressbar.tcl source {ProgressBar ProgressBar::create ProgressBar::use}}
#@ {progressdlg.tcl source {ProgressDlg ProgressDlg::create ProgressDlg::use}}
#@ {passwddlg.tcl source {PasswdDlg PasswdDlg::create PasswdDlg::use}}
#@ {dragsite.tcl source {DragSite::register DragSite::include DragSite::use}}
#@ {dropsite.tcl source {DropSite::register DropSite::include DropSite::use}}
#@ {separator.tcl source {Separator Separator::create Separator::use}}
#@ {spinbox.tcl source {SpinBox SpinBox::create SpinBox::use}}
#@ {statusbar.tcl source {StatusBar StatusBar::create StatusBar::use}}
#@ {titleframe.tcl source {TitleFrame TitleFrame::create TitleFrame::use}}
#@ {mainframe.tcl source {MainFrame MainFrame::create MainFrame::use}}
#@ {listbox.tcl source {ListBox ListBox::create ListBox::use}}
#@ {tree.tcl source {Tree Tree::create Tree::use}}
#@ {color.tcl source {SelectColor SelectColor::menu SelectColor::dialog SelectColor::setcolor}}
#@ {dynhelp.tcl source {DynamicHelp::configure DynamicHelp::use DynamicHelp::register DynamicHelp::include DynamicHelp::add DynamicHelp::delete}}
#@ {dialog.tcl source {Dialog Dialog::create Dialog::use}}
#@ {messagedlg.tcl source {MessageDlg MessageDlg::create MessageDlg::use}}
#@ {font.tcl source {SelectFont SelectFont::create SelectFont::use SelectFont::loadfont}}
#@ {widgetdoc.tcl source {Widget::generate-doc Widget::generate-widget-doc}}
#@ {wizard.tcl source {Wizard Wizard::create Wizard::use SimpleWizard ClassicWizard}}
#@ {xpm2image.tcl source {xpm-to-image}}
#@ }]; 	[list namespace eval ::BWIDGET {}]; 	[list set ::BWIDGET::LIBRARY $dir];     [list source [file join $dir widget.tcl]];     [list source [file join $dir init.tcl]];     [list source [file join $dir utils.tcl]]; "
#@ # -- End source /opt/synopsys/icc-201506/auxx/syn/fp/bw/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/iwidgets4.0.2/lib/iwidgets/pkgIndex.tcl

#@ # Tcl package index file, version 1.0
#@ 
#@ package ifneeded Iwidgets 4.0.2 [list source [file join $dir iwidgets.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/iwidgets4.0.2/lib/iwidgets/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tix8.4.3/pref/pkgIndex.tcl

#@ # -*-mode: tcl; fill-column: 75; tab-width: 8; coding: iso-latin-1-unix -*-
#@ #
#@ # Tcl package index file, version 1.0
#@ #
#@ # $Id: pkgIndex.tcl,v 1.2 2002/01/24 09:17:02 idiscovery Exp $
#@ #
#@ 
#@ package ifneeded wm_default 1.0 [list source [file join $dir WmDefault.tcl]]
#@ 
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tix8.4.3/pref/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/syn/layout/pkgIndex.tcl

#@ ###
#@ ### This layout package is originally a snapshot of icc/layout 6/20/07.
#@ ### The version is bumped from 1.0 to 1.2 
#@ ### Subsequently merged with ICC on July 2007 and became the only version
#@ ### available 
#@ ### The migration of the package is to facilitate code sharing between
#@ ### applications which need layout view customizations.
#@ ###
#@ ### Updates:
#@ ###        added package snpsPathsSlackVM
#@ ###        added package snpsCellSlackVM 
#@ ###        added package snpsNetCapacitanceVM
#@ ###        added package snpsScanChainVM 
#@ 
#@ package ifneeded snpsVMDialogPathsSlack     1.2 [list source -direct [file join $dir DialogVMPathsSlack.tcl]]
#@ package ifneeded snpsVMDialogCellSlack      1.2 [list source -direct [file join $dir DialogVMCellSlack.tcl]]
#@ package ifneeded snpsVMDialogNetCapacitance 1.2 [list source -direct [file join $dir DialogVMNetCapacitance.tcl]]
#@ package ifneeded snpsVMDialogClockLT 1.2 [list source -direct [file join $dir DialogVMClockLT.tcl]]
#@ 
#@ package ifneeded snpsImportedPathPinsVM     1.2 [list source -direct [file join $dir snpsImportedPathPinsVM.tcl]]
#@ package ifneeded snpsPathsSlackVM     1.2 [list source -direct [file join $dir snpsPathsSlackVM.tcl]]
#@ package ifneeded snpsCellSlackVM      1.2 [list source -direct [file join $dir snpsCellSlackVM.tcl]]
#@ package ifneeded snpsIllegalCellPlacementVM      1.2 [list source -direct [file join $dir snpsIllegalCellPlacementVM.tcl]]
#@ package ifneeded snpsVoltageAreaVM      1.2 [list source -direct [file join $dir snpsVoltageAreaVM.tcl]]
#@ package ifneeded snpsXTalkVM      1.2 [list source -direct [file join $dir snpsXTalkVM.tcl]]
#@ package ifneeded snpsDeltaDelayVM      1.2 [list source -direct [file join $dir snpsDeltaDelayVM.tcl]]
#@ package ifneeded snpsNoiseVM      1.2 [list source -direct [file join $dir snpsNoiseVM.tcl]]
#@ package ifneeded snpsCellDisplacementVM      1.2 [list source -direct [file join $dir snpsCellDisplacementVM.tcl]]
#@ package ifneeded snpsAreaNetConnectionVM      1.2 [list source -direct [file join $dir snpsAreaNetConnectionVM.tcl]]
#@ package ifneeded snpsNetCapacitanceVM 1.2 [list source -direct [file join $dir snpsNetCapacitanceVM.tcl]]
#@ package ifneeded snpsClockLTVM 1.2 [list source -direct [file join $dir snpsClockLTVM.tcl]]
#@ package ifneeded snpsScanChainVM 1.2 [list source -direct [file join $dir snpsScanChainVM.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/syn/layout/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/tcl-dp/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded EkkiInterProcessSelect 1.0 [list source -direct [file join $dir ekkiCrossSelect.tcl]]
#@ package ifneeded snpsInterProcessCommunication 1.0 [list source -direct [file join $dir serv.tcl]]
#@ package ifneeded snpsUpdateTimer 1.0 [list source -direct [file join $dir timer.tcl]]
#@ package ifneeded tcl-dp 1.0 [list source -direct [file join $dir acl.tcl]]\n[list source -direct [file join $dir distribObj.tcl]]\n[list source -direct [file join $dir dp_atclose.tcl]]\n[list source -direct [file join $dir dp_atexit.tcl]]\n[list source -direct [file join $dir ldelete.tcl]]\n[list source -direct [file join $dir oo.tcl]]\n[list source -direct [file join $dir rpc.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/tcl-dp/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/fanoutviewer/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsCTB 1.0 [list source -direct [file join $dir ctb.tcl]]
#@ package ifneeded snpsCTBInternal 1.0 [list source -direct [file join $dir ctbInternal.tcl]]
#@ package ifneeded snpsFanoutViewer 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/fanoutviewer/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/view/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/view/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/acg/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsAcg 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/acg/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/dialogs/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsDialogsBinsOnlyInformation 1.0 [list source -direct [file join $dir BinsOnlyInformation.tcl]]
#@ package ifneeded snpsDialogsCompileLinkDesign 1.0 [list source -direct [file join $dir CompileLinkDesign.tcl]]
#@ package ifneeded snpsDialogsFanInOutInfo 1.0 [list source -direct [file join $dir FanInOutInfo.tcl]]
#@ package ifneeded snpsDialogsFileChooser 1.0 [list source -direct [file join $dir FileChooser.tcl]]
#@ package ifneeded snpsDialogsHistBin1Information 1.0 [list source -direct [file join $dir HistBin1Information.tcl]]
#@ package ifneeded snpsDialogsHistBinInformation 1.0 [list source -direct [file join $dir HistBinInformation.tcl]]
#@ package ifneeded snpsDialogsHistBumpNoise 1.0 [list source -direct [file join $dir HistBumpNoise.tcl]]
#@ package ifneeded snpsDialogsHistBumpVoltage 1.0 [list source -direct [file join $dir HistBumpVoltage.tcl]]
#@ package ifneeded snpsDialogsHistDeltaDelay 1.0 [list source -direct [file join $dir HistDeltaDelay.tcl]]
#@ package ifneeded snpsDialogsClockMapInformation 1.0 [list source -direct [file join $dir ClockMapInformation.tcl]]
#@ package ifneeded snpsDialogsNumberOfLevelsChooser 1.0 [list source -direct [file join $dir NumberOfLevelsChooser.tcl]]
#@ package ifneeded snpsDialogsObjectChooser 1.0 [list source -direct [file join $dir ObjectChooser.tcl]]
#@ package ifneeded snpsDialogsObjectListInfo 1.0 [list source -direct [file join $dir ObjectListInfo.tcl]]
#@ package ifneeded snpsDialogsPathPinSimpleInfo 1.0 [list source -direct [file join $dir PathPinSimpleInfo.tcl]]
#@ package ifneeded snpsDialogsPathsBasicInfo 1.0 [list source -direct [file join $dir PathsBasicInfo.tcl]]
#@ package ifneeded snpsDialogsPathsBasicSimpleInfo 1.0 [list source -direct [file join $dir PathsBasicSimpleInfo.tcl]]
#@ package ifneeded snpsDialogsReportOutputOptionInfo 1.0 [list source -direct [file join $dir ReportOutputOptionInfo.tcl]]
#@ package ifneeded snpsDialogsSchematicWhatIf 1.0 [list source -direct [file join $dir SchematicWhatIf.tcl]]
#@ package ifneeded snpsDialogsSlctOperationInfo 1.0 [list source -direct [file join $dir SlctOperationInfo.tcl]]
#@ package ifneeded snpsDialogsWindowReuseInfo 1.0 [list source -direct [file join $dir WindowReuseInfo.tcl]]
#@ package ifneeded snpsDialogsPath 1.0 [list source -direct [file join $dir PathDialog.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/dialogs/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/qtcl/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsQtcl 1.0           [list source -direct [file join $dir .synopsys_qtcl.tcl]]
#@ package ifneeded snpsQtclExtensions 1.0 [list source -direct [file join $dir qtcl_extensions.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/qtcl/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/hierarchy/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsDesignObjectBrowser 1.0 [list source -direct [file join $dir DesignObjectBrowser.tcl]]
#@ package ifneeded snpsHier 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsHier::children 1.0 [list source -direct [file join $dir children.tcl]]
#@ package ifneeded snpsHier::columns 1.0 [list source -direct [file join $dir columns.tcl]]
#@ package ifneeded snpsHier::dialogs 1.0 [list source -direct [file join $dir dialogs.tcl]]
#@ package ifneeded snpsHier::hierarchies 1.0 [list source -direct [file join $dir hierarchies.tcl]]
#@ package ifneeded snpsHier::rootFcts 1.0 [list source -direct [file join $dir rootFcts.tcl]]
#@ package ifneeded snpsHierExample1 1.0 [list source -direct [file join $dir Example1.tcl]]
#@ package ifneeded snpsHierExample2 1.0 [list source -direct [file join $dir Example2.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/hierarchy/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/libviewer/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsLibViewer 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/libviewer/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/profiler/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsProfiler 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/profiler/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/palettegroup/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsPaletteGroup 1.0 [list source -direct [file join $dir palettegroup.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/palettegroup/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/mrupalette/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsMRUPalette 1.0 [list source -direct [file join $dir mrupalette.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/mrupalette/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/setup/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsCommonSetup 1.0 [list source -direct [file join $dir snpsCommonSetup.tcl]]
#@ package ifneeded snpsCustomize 1.0 [list source -direct [file join $dir snpsCustomize.tcl]]
#@ package ifneeded snpsCollections 1.0 [list source -direct [file join $dir snpsCollections.tcl]]
#@ package ifneeded snpsProcheck 1.0 [list source -direct [file join $dir snpsProcheck.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/setup/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/table/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTable 1.0 [list source -direct [file join $dir table.tcl]]
#@ package ifneeded snpsTableInternal 1.0 [list source -direct [file join $dir table_internal.tcl]]
#@ package ifneeded snpsTableCustomize 1.0 [list source -direct [file join $dir table_customize.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/table/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/WindowFrameWork/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsWindowFrameWork 1.0 [list source -direct [file join $dir windowFrameWork.tcl]]
#@ package ifneeded snpsBusyCursorSkipList 1.0 [list source -direct [file join $dir skipBusyCursorCmdList.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/WindowFrameWork/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/select/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsSelectDialogFanInOut 1.0 [list source -direct [file join $dir DialogSelectFanInOut.tcl]]
#@ package ifneeded snpsSelection 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsSelectionInternal 1.0 [list source -direct [file join $dir baseInternal.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/select/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/histogram/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsHistogram 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsHistogramDialogBottleneck 1.0 [list source -direct [file join $dir DialogBottleneck.tcl]]
#@ package ifneeded snpsHistogramDialogTable 1.0 [list source -direct [file join $dir DialogTable.tcl]]
#@ package ifneeded snpsHistogramDialogBumpNoise 1.0 [list source -direct [file join $dir DialogBumpNoise.tcl]]
#@ package ifneeded snpsHistogramDialogBumpVoltage 1.0 [list source -direct [file join $dir DialogBumpVoltage.tcl]]
#@ package ifneeded snpsHistogramDialogDRC 1.0 [list source -direct [file join $dir DialogDRC.tcl]]
#@ package ifneeded snpsHistogramDialogDeltaDelay 1.0 [list source -direct [file join $dir DialogDeltaDelay.tcl]]
#@ package ifneeded snpsHistogramDialogEndpointSlack 1.0 [list source -direct [file join $dir DialogEndpointSlack.tcl]]
#@ package ifneeded snpsHistogramDialogNetCapacitance 1.0 [list source -direct [file join $dir DialogNetCapacitance.tcl]]
#@ package ifneeded snpsHistogramDialogPathsSlack 1.0 [list source -direct [file join $dir DialogPathsSlack.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/histogram/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/regressionToolkit/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsGUITest 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsDialogTest 1.0 [list source -direct [file join $dir dialogTest.tcl]]
#@ package ifneeded snpsCommandHelpTest 1.0 [list source -direct [file join $dir commandHelpTest.tcl]]
#@ package ifneeded snpsGUIAppSpecifics 1.0 [list source -direct [file join $dir appSpecifics.tcl]]
#@ package ifneeded snpsQtclCoreTests 1.0 [list source -direct [file join $dir snpsQtclCoreTests.tcl]]
#@ package ifneeded snpsTestBinning 1.0 [list source -direct [file join $dir binning.tcl]]
#@ package ifneeded snpsTestDialogAddFaninFanout 1.0 [list source -direct [file join $dir dialogAddFaninFanout.tcl]]
#@ package ifneeded snpsTestDialogAddPaths 1.0 [list source -direct [file join $dir dialogAddPaths.tcl]]
#@ package ifneeded snpsTestDialogEndpointSlackHistogram 1.0 [list source -direct [file join $dir dialogEndpointSlackHistogram.tcl]]
#@ package ifneeded snpsTestDialogNetCapacitanceHistogram 1.0 [list source -direct [file join $dir dialogNetCapacitanceHistogram.tcl]]
#@ package ifneeded snpsTestDialogObjectChooser 1.0 [list source -direct [file join $dir dialogObjectChooser.tcl]]
#@ package ifneeded snpsTestDialogPathsSlackHistogram 1.0 [list source -direct [file join $dir dialogPathsSlackHistogram.tcl]]
#@ package ifneeded snpsTestDialogs 1.0 [list source -direct [file join $dir dialogs.tcl]]
#@ package ifneeded snpsTestDialogSelectByName 1.0 [list source -direct [file join $dir dialogSelectByName.tcl]]
#@ package ifneeded snpsTestHistogram 1.0 [list source -direct [file join $dir histogram.tcl]]
#@ package ifneeded snpsTestList 1.0 [list source -direct [file join $dir list.tcl]]
#@ package ifneeded snpsTestListUtils 1.0 [list source -direct [file join $dir listUtils.tcl]]
#@ package ifneeded snpsTestMenu 1.0 [list source -direct [file join $dir menu.tcl]]
#@ package ifneeded snpsTestMouse 1.0 [list source -direct [file join $dir mouse.tcl]]
#@ package ifneeded snpsTestNl 1.0 [list source -direct [file join $dir nl.tcl]]
#@ package ifneeded snpsWriteXMLNl 1.0 [list source -direct [file join $dir writeXMLNl.tcl]]
#@ package ifneeded snpsTestObjectAtPoint 1.0 [list source -direct [file join $dir testObjectAtPoint.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/regressionToolkit/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/menus/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsMenus 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/menus/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/layout/pkgIndex.tcl

#@ package ifneeded snpsLayout                 1.2 [list source -direct [file join $dir layout.tcl]]
#@ package ifneeded snpsLayoutTools            1.2 [list source -direct [file join $dir snpsLayoutTools.tcl]]
#@ package ifneeded snpsLayoutLayers           1.2 [list source -direct [file join $dir layout_layers.tcl]]
#@ package ifneeded snpsLayoutTest             1.2 [list source -direct [file join $dir layout_test.tcl]]
#@ 
#@ package ifneeded colSrv                    1.2 [list source -direct [file join $dir colSrv.tcl]]
#@ package ifneeded snpsVM                     1.2 [list source -direct [file join $dir snpsVM.tcl]]
#@ package ifneeded snpsMM                     1.2 [list source -direct [file join $dir snpsMM.tcl]]
#@ 
#@ package ifneeded snpsLayoutPreferences      1.0 [list source -direct [file join $dir preferences.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/layout/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/strokes/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded strokes 1.0 [list source -direct [file join $dir stroke_defaults.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/strokes/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/timing/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTimingGUI 1.0 [list source -direct [file join $dir base.tcl]]
#@ 
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/timing/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/misc/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsCalculateWindowGeometry 1.0 [list source -direct [file join $dir calculateWindowGeometry.tcl]]
#@ package ifneeded snpsCommonViewMenu 1.0 [list source -direct [file join $dir viewmenu.tcl]]
#@ package ifneeded snpsCopyPaste 1.0 [list source -direct [file join $dir copyPaste.tcl]]
#@ package ifneeded snpsCreateViewType 1.0 [list source -direct [file join $dir createViewType.tcl]]
#@ package ifneeded snpsCurrInst 1.0 [list source -direct [file join $dir snpsCurrInst.tcl]]
#@ package ifneeded snpsDebug 1.0 [list source -direct [file join $dir debug.tcl]]
#@ package ifneeded snpsDemo 1.0 [list source -direct [file join $dir demo.tcl]]
#@ package ifneeded snpsFile 1.0 [list source -direct [file join $dir file.tcl]]
#@ package ifneeded snpsFollowNlFactory 1.0 [list source -direct [file join $dir followNlFactory.tcl]]
#@ package ifneeded snpsGuiMenuEnable 1.0 [list source -direct [file join $dir GuiMenuEnable.tcl]]
#@ package ifneeded snpsInfotips 1.0 [list source -direct [file join $dir infotip.tcl]]
#@ package ifneeded snpsLoadsDrivers 1.0 [list source -direct [file join $dir loadsDrivers.tcl]]
#@ package ifneeded snpsMisc 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsMiscAnchorPoint 1.0 [list source -direct [file join $dir anchor.tcl]]
#@ package ifneeded snpsMiscDialogObjectChooser 1.0 [list source -direct [file join $dir DialogObjectChooser.tcl]]
#@ package ifneeded snpsMiscEditMovebounds 1.0 [list source -direct [file join $dir EditMovebounds.tcl]]
#@ package ifneeded snpsMiscSetting 1.0 [list source -direct [file join $dir setting.tcl]]
#@ package ifneeded snpsMiscTiming 1.0 [list source -direct [file join $dir timing.tcl]]
#@ package ifneeded snpsMiscViewportHistory 1.0 [list source -direct [file join $dir viewporthistory.tcl]]
#@ package ifneeded snpsOutput 1.0 [list source -direct [file join $dir output.tcl]]
#@ package ifneeded snpsQObjectViewer 1.0 [list source -direct [file join $dir qobjectviewer.tcl]]
#@ package ifneeded snpsStack 1.0 [list source -direct [file join $dir stack.tcl]]
#@ package ifneeded snpsTypedText 1.0 [list source -direct [file join $dir typedText.tcl]]
#@ package ifneeded snpsViewMgr 1.0 [list source -direct [file join $dir viewmgr.tcl]]
#@ package ifneeded snpsMiscPreset 1.0 [list source -direct [file join $dir preset.tcl]]
#@ package ifneeded snpsTaskAssistant 1.0 [list source -direct [file join $dir taskassistant.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/misc/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/schematic/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsSchematic 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsSchematicDialogPathSchematicAddFanInOut 1.0 [list source -direct [file join $dir DialogPathSchematicFanInOut.tcl]]
#@ package ifneeded snpsSchematicDialogPathSchematicAddPaths 1.0 [list source -direct [file join $dir DialogPathSchematicAddPaths.tcl]]
#@ package ifneeded snpsSchematicDialogSchematicSizeCell 1.0 [list source -direct [file join $dir DialogSchematicWhatIf.tcl]]
#@ package ifneeded snpsSchematicEnable 1.0 [list source -direct [file join $dir enable.tcl]]
#@ package ifneeded snpsSchematicMethod 1.0 [list source -direct [file join $dir method.tcl]]
#@ package ifneeded snpsSchematicNetlist 1.0 [list source -direct [file join $dir netlist.tcl]]
#@ package ifneeded snpsSchematicNetlistInternal 1.0 [list source -direct [file join $dir schematicNetlistInternal.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/schematic/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/tiledview/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTiledView 1.0 [list source -direct [file join $dir tiledview.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/tiledview/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/tq/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTkStyle 1.0 [list source -direct [file join $dir snpsTkStyle.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/tq/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/docBrowser/pkgIndex.tcl

#@ 
#@ package ifneeded snpsDocBrowser 1.0 [list source -direct [file join $dir docBrowser.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/docBrowser/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/highlight/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded Highlight 1.0 [list source -direct [file join $dir highlight.tcl]]
#@ package ifneeded snpsHighlight 1.0 [list source -direct [file join $dir highlight.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/highlight/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/opdlg/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsOpDlg 1.0 [list source -direct [file join $dir base.tcl]]\n[list source -direct [file join $dir data.tcl]]\n[list source -direct [file join $dir frame1.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/opdlg/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/commandform/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsCommandForm 1.0 [list source -direct [file join $dir commandform.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/commandform/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/common/pathinspector/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsPathInspector 1.0 [list source -direct [file join $dir base.tcl]]\n[list source -direct [file join $dir create_window_and_menu.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/common/pathinspector/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/gui/dv/pkgIndex.tcl

#@ 
#@ package ifneeded snpsPathAnalyzer 1.0 [list source -direct [file join $dir dv_path_cat_view.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/gui/dv/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/syn/ors/pkgIndex.tcl

#@ package ifneeded snpsArchSolnORS 1.0 [list source [file join $dir ors.tbc]]\n
#@ package ifneeded snpsArchSolnCSL 1.0 [list source [file join $dir color_swap_legal.tbc]]\n
#@ package ifneeded snpsArchSolnVAC 1.0 [list source [file join $dir vacgen.tbc]]\n
#@ package ifneeded snpsArchSolnCPODE 1.0 [list source [file join $dir cpode_l2_rule.tbc]]\n
#@ # -- End source /opt/synopsys/icc-201506/auxx/syn/ors/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/snps_tcl/snpsTclPro/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTclPro 1.0 [list source [file join $dir			snpsTclPro.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/snps_tcl/snpsTclPro/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/snps_tcl/snpsUtils/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsUtils 1.0 [list source [file join $dir snpsUtils.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/snps_tcl/snpsUtils/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/snps_tcl/snpsTest/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTest 1.0 [list source [file join $dir snpsTest.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/snps_tcl/snpsTest/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/snps_tcl/pkgIndex.tcl

#@ package ifneeded Itcl 3.4 {load {} Itcl}
#@ package ifneeded tbcload 1.7 {load {} tbcload}
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/snps_tcl/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/msgcat/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded msgcat 1.4.5 [list source [file join $dir msgcat.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/msgcat/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/reg/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8]} return
#@ if {[info sharedlibextension] != ".dll"} return
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/reg/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/platform/pkgIndex.tcl

#@ package ifneeded platform        1.0.10 [list source [file join $dir platform.tcl]]
#@ package ifneeded platform::shell 1.1.4 [list source [file join $dir shell.tcl]]
#@ 
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/platform/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/tcltest/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded tcltest 2.3.4 [list source [file join $dir tcltest.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/tcltest/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/http1.0/pkgIndex.tcl

#@ # Tcl package index file, version 1.0
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded http 1.0 [list tclPkgSetup $dir http 1.0 {{http.tcl source {httpCopyDone httpCopyStart httpEof httpEvent httpFinish httpMapReply httpProxyRequired http_code http_config http_data http_formatQuery http_get http_reset http_size http_status http_wait}}}]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/http1.0/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/opt/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded opt 0.4.5 [list source [file join $dir optparse.tcl]]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/opt/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/dde/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8]} return
#@ if {[info sharedlibextension] != ".dll"} return
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/dde/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/http/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded http 2.7.9 [list tclPkgSetup $dir http 2.7.9 {{http.tcl source {::http::config ::http::formatQuery ::http::geturl ::http::reset ::http::wait ::http::register ::http::unregister ::http::mapReply}}}]
#@ # -- End source /opt/synopsys/icc-201506/auxx/tcllib/lib/tcl8.5/http/pkgIndex.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/syn/fp/bw/widget.tcl

#@ # ----------------------------------------------------------------------------
#@ #  widget.tcl
#@ #  This file is part of Unifix BWidget Toolkit
#@ #  $Id: widget.tcl,v 1.35 2009/07/02 16:22:18 oehhar Exp $
#@ # ----------------------------------------------------------------------------
#@ #  Index of commands:
#@ #     - Widget::tkinclude
#@ #     - Widget::bwinclude
#@ #     - Widget::declare
#@ #     - Widget::addmap
#@ #     - Widget::init
#@ #     - Widget::destroy
#@ #     - Widget::setoption
#@ #     - Widget::configure
#@ #     - Widget::cget
#@ #     - Widget::subcget
#@ #     - Widget::hasChanged
#@ #     - Widget::options
#@ #     - Widget::_get_tkwidget_options
#@ #     - Widget::_test_tkresource
#@ #     - Widget::_test_bwresource
#@ #     - Widget::_test_synonym
#@ #     - Widget::_test_string
#@ #     - Widget::_test_flag
#@ #     - Widget::_test_enum
#@ #     - Widget::_test_int
#@ #     - Widget::_test_boolean
#@ # ----------------------------------------------------------------------------
#@ # Each megawidget gets a namespace of the same name inside the Widget namespace
#@ # Each of these has an array opt, which contains information about the 
#@ # megawidget options.  It maps megawidget options to a list with this format:
#@ #     {optionType defaultValue isReadonly {additionalOptionalInfo}}
#@ # Option types and their additional optional info are:
#@ #	TkResource	{genericTkWidget genericTkWidgetOptionName}
#@ #	BwResource	{nothing}
#@ #	Enum		{list of enumeration values}
#@ #	Int		{Boundary information}
#@ #	Boolean		{nothing}
#@ #	String		{nothing}
#@ #	Flag		{string of valid flag characters}
#@ #	Synonym		{nothing}
#@ #	Color		{nothing}
#@ #
#@ # Next, each namespace has an array map, which maps class options to their
#@ # component widget options:
#@ #	map(-foreground) => {.e -foreground .f -foreground}
#@ #
#@ # Each has an array ${path}:opt, which contains the value of each megawidget
#@ # option for a particular instance $path of the megawidget, and an array
#@ # ${path}:mod, which stores the "changed" status of configuration options.
#@ 
#@ # Steps for creating a bwidget megawidget:
#@ # 1. parse args to extract subwidget spec
#@ # 2. Create frame with appropriate class and command line options
#@ # 3. Get initialization options from optionDB, using frame
#@ # 4. create subwidgets
#@ 
#@ # Uses newer string operations
#@ package require Tcl 8.1.1
#@ 
#@ namespace eval Widget {
#@     variable _optiontype
#@     variable _class
#@     variable _tk_widget
#@ 
#@     # This controls whether we try to use themed widgets from Tile
#@     variable _theme 0
#@ 
#@     variable _aqua [expr {($::tcl_version >= 8.4) &&
#@ 			  [string equal [tk windowingsystem] "aqua"]}]
#@ 
#@     array set _optiontype {
#@         TkResource Widget::_test_tkresource
#@         BwResource Widget::_test_bwresource
#@         Enum       Widget::_test_enum
#@         Int        Widget::_test_int
#@         Boolean    Widget::_test_boolean
#@         String     Widget::_test_string
#@         Flag       Widget::_test_flag
#@         Synonym    Widget::_test_synonym
#@         Color      Widget::_test_color
#@         Padding    Widget::_test_padding
#@     }
#@ 
#@     proc use {} {}
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::tkinclude
#@ #     Includes tk widget resources to BWidget widget.
#@ #  class      class name of the BWidget
#@ #  tkwidget   tk widget to include
#@ #  subpath    subpath to configure
#@ #  args       additionnal args for included options
#@ # ----------------------------------------------------------------------------
#@ proc Widget::tkinclude { class tkwidget subpath args } {
#@     foreach {cmd lopt} $args {
#@         # cmd can be
#@         #   include      options to include            lopt = {opt ...}
#@         #   remove       options to remove             lopt = {opt ...}
#@         #   rename       options to rename             lopt = {opt newopt ...}
#@         #   prefix       options to prefix             lopt = {pref opt opt ..}
#@         #   initialize   set default value for options lopt = {opt value ...}
#@         #   readonly     set readonly flag for options lopt = {opt flag ...}
#@         switch -- $cmd {
#@             remove {
#@                 foreach option $lopt {
#@                     set remove($option) 1
#@                 }
#@             }
#@             include {
#@                 foreach option $lopt {
#@                     set include($option) 1
#@                 }
#@             }
#@             prefix {
#@                 set prefix [lindex $lopt 0]
#@                 foreach option [lrange $lopt 1 end] {
#@                     set rename($option) "-$prefix[string range $option 1 end]"
#@                 }
#@             }
#@             rename     -
#@             readonly   -
#@             initialize {
#@                 array set $cmd $lopt
#@             }
#@             default {
#@                 return -code error "invalid argument \"$cmd\""
#@             }
#@         }
#@     }
#@ 
#@     namespace eval $class {}
#@     upvar 0 ${class}::opt classopt
#@     upvar 0 ${class}::map classmap
#@     upvar 0 ${class}::map$subpath submap
#@     upvar 0 ${class}::optionExports exports
#@ 
#@     set foo [$tkwidget ".ericFoo###"]
#@     # create resources informations from tk widget resources
#@     foreach optdesc [_get_tkwidget_options $tkwidget] {
#@         set option [lindex $optdesc 0]
#@         if { (![info exists include] || [info exists include($option)]) &&
#@              ![info exists remove($option)] } {
#@             if { [llength $optdesc] == 3 } {
#@                 # option is a synonym
#@                 set syn [lindex $optdesc 1]
#@                 if { ![info exists remove($syn)] } {
#@                     # original option is not removed
#@                     if { [info exists rename($syn)] } {
#@                         set classopt($option) [list Synonym $rename($syn)]
#@                     } else {
#@                         set classopt($option) [list Synonym $syn]
#@                     }
#@                 }
#@             } else {
#@                 if { [info exists rename($option)] } {
#@                     set realopt $option
#@                     set option  $rename($option)
#@                 } else {
#@                     set realopt $option
#@                 }
#@                 if { [info exists initialize($option)] } {
#@                     set value $initialize($option)
#@                 } else {
#@                     set value [lindex $optdesc 1]
#@                 }
#@                 if { [info exists readonly($option)] } {
#@                     set ro $readonly($option)
#@                 } else {
#@                     set ro 0
#@                 }
#@                 set classopt($option) 			[list TkResource $value $ro [list $tkwidget $realopt]]
#@ 
#@ 		# Add an option database entry for this option
#@ 		set optionDbName ".[lindex [_configure_option $realopt ""] 0]"
#@ 		if { ![string equal $subpath ":cmd"] } {
#@ 		    set optionDbName "$subpath$optionDbName"
#@ 		}
#@ 		option add *${class}$optionDbName $value widgetDefault
#@ 		lappend exports($option) "$optionDbName"
#@ 
#@ 		# Store the forward and backward mappings for this
#@ 		# option <-> realoption pair
#@                 lappend classmap($option) $subpath "" $realopt
#@ 		set submap($realopt) $option
#@             }
#@         }
#@     }
#@     ::destroy $foo
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::bwinclude
#@ #     Includes BWidget resources to BWidget widget.
#@ #  class    class name of the BWidget
#@ #  subclass BWidget class to include
#@ #  subpath  subpath to configure
#@ #  args     additionnal args for included options
#@ # ----------------------------------------------------------------------------
#@ proc Widget::bwinclude { class subclass subpath args } {
#@     foreach {cmd lopt} $args {
#@         # cmd can be
#@         #   include      options to include            lopt = {opt ...}
#@         #   remove       options to remove             lopt = {opt ...}
#@         #   rename       options to rename             lopt = {opt newopt ...}
#@         #   prefix       options to prefix             lopt = {prefix opt opt ...}
#@         #   initialize   set default value for options lopt = {opt value ...}
#@         #   readonly     set readonly flag for options lopt = {opt flag ...}
#@         switch -- $cmd {
#@             remove {
#@                 foreach option $lopt {
#@                     set remove($option) 1
#@                 }
#@             }
#@             include {
#@                 foreach option $lopt {
#@                     set include($option) 1
#@                 }
#@             }
#@             prefix {
#@                 set prefix [lindex $lopt 0]
#@                 foreach option [lrange $lopt 1 end] {
#@                     set rename($option) "-$prefix[string range $option 1 end]"
#@                 }
#@             }
#@             rename     -
#@             readonly   -
#@             initialize {
#@                 array set $cmd $lopt
#@             }
#@             default {
#@                 return -code error "invalid argument \"$cmd\""
#@             }
#@         }
#@     }
#@ 
#@     namespace eval $class {}
#@     upvar 0 ${class}::opt classopt
#@     upvar 0 ${class}::map classmap
#@     upvar 0 ${class}::map$subpath submap
#@     upvar 0 ${class}::optionExports exports
#@     upvar 0 ${subclass}::opt subclassopt
#@     upvar 0 ${subclass}::optionExports subexports
#@ 
#@     # create resources informations from BWidget resources
#@     foreach {option optdesc} [array get subclassopt] {
#@ 	set subOption $option
#@         if { (![info exists include] || [info exists include($option)]) &&
#@              ![info exists remove($option)] } {
#@             set type [lindex $optdesc 0]
#@             if { [string equal $type "Synonym"] } {
#@                 # option is a synonym
#@                 set syn [lindex $optdesc 1]
#@                 if { ![info exists remove($syn)] } {
#@                     if { [info exists rename($syn)] } {
#@                         set classopt($option) [list Synonym $rename($syn)]
#@                     } else {
#@                         set classopt($option) [list Synonym $syn]
#@                     }
#@                 }
#@             } else {
#@                 if { [info exists rename($option)] } {
#@                     set realopt $option
#@                     set option  $rename($option)
#@                 } else {
#@                     set realopt $option
#@                 }
#@                 if { [info exists initialize($option)] } {
#@                     set value $initialize($option)
#@                 } else {
#@                     set value [lindex $optdesc 1]
#@                 }
#@                 if { [info exists readonly($option)] } {
#@                     set ro $readonly($option)
#@                 } else {
#@                     set ro [lindex $optdesc 2]
#@                 }
#@                 set classopt($option) 			[list $type $value $ro [lindex $optdesc 3]]
#@ 
#@ 		# Add an option database entry for this option
#@ 		foreach optionDbName $subexports($subOption) {
#@ 		    if { ![string equal $subpath ":cmd"] } {
#@ 			set optionDbName "$subpath$optionDbName"
#@ 		    }
#@ 		    # Only add the option db entry if we are overriding the
#@ 		    # normal widget default
#@ 		    if { [info exists initialize($option)] } {
#@ 			option add *${class}$optionDbName $value 				widgetDefault
#@ 		    }
#@ 		    lappend exports($option) "$optionDbName"
#@ 		}
#@ 
#@ 		# Store the forward and backward mappings for this
#@ 		# option <-> realoption pair
#@                 lappend classmap($option) $subpath $subclass $realopt
#@ 		set submap($realopt) $option
#@             }
#@         }
#@     }
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::declare
#@ #    Declares new options to BWidget class.
#@ # ----------------------------------------------------------------------------
#@ proc Widget::declare { class optlist } {
#@     variable _optiontype
#@ 
#@     namespace eval $class {}
#@     upvar 0 ${class}::opt classopt
#@     upvar 0 ${class}::optionExports exports
#@     upvar 0 ${class}::optionClass optionClass
#@ 
#@     foreach optdesc $optlist {
#@         set option  [lindex $optdesc 0]
#@         set optdesc [lrange $optdesc 1 end]
#@         set type    [lindex $optdesc 0]
#@ 
#@         if { ![info exists _optiontype($type)] } {
#@             # invalid resource type
#@             return -code error "invalid option type \"$type\""
#@         }
#@ 
#@         if { [string equal $type "Synonym"] } {
#@             # test existence of synonym option
#@             set syn [lindex $optdesc 1]
#@             if { ![info exists classopt($syn)] } {
#@                 return -code error "unknow option \"$syn\" for Synonym \"$option\""
#@             }
#@             set classopt($option) [list Synonym $syn]
#@             continue
#@         }
#@ 
#@         # all other resource may have default value, readonly flag and
#@         # optional arg depending on type
#@         set value [lindex $optdesc 1]
#@         set ro    [lindex $optdesc 2]
#@         set arg   [lindex $optdesc 3]
#@ 
#@         if { [string equal $type "BwResource"] } {
#@             # We don't keep BwResource. We simplify to type of sub BWidget
#@             set subclass    [lindex $arg 0]
#@             set realopt     [lindex $arg 1]
#@             if { ![string length $realopt] } {
#@                 set realopt $option
#@             }
#@ 
#@             upvar 0 ${subclass}::opt subclassopt
#@             if { ![info exists subclassopt($realopt)] } {
#@                 return -code error "unknow option \"$realopt\""
#@             }
#@             set suboptdesc $subclassopt($realopt)
#@             if { $value == "" } {
#@                 # We initialize default value
#@                 set value [lindex $suboptdesc 1]
#@             }
#@             set type [lindex $suboptdesc 0]
#@             set ro   [lindex $suboptdesc 2]
#@             set arg  [lindex $suboptdesc 3]
#@ 	    set optionDbName ".[lindex [_configure_option $option ""] 0]"
#@ 	    option add *${class}${optionDbName} $value widgetDefault
#@ 	    set exports($option) $optionDbName
#@             set classopt($option) [list $type $value $ro $arg]
#@             continue
#@         }
#@ 
#@         # retreive default value for TkResource
#@         if { [string equal $type "TkResource"] } {
#@             set tkwidget [lindex $arg 0]
#@ 	    set foo [$tkwidget ".ericFoo##"]
#@             set realopt  [lindex $arg 1]
#@             if { ![string length $realopt] } {
#@                 set realopt $option
#@             }
#@             set tkoptions [_get_tkwidget_options $tkwidget]
#@             if { ![string length $value] } {
#@                 # We initialize default value
#@ 		set ind [lsearch $tkoptions [list $realopt *]]
#@                 set value [lindex [lindex $tkoptions $ind] end]
#@             }
#@ 	    set optionDbName ".[lindex [_configure_option $option ""] 0]"
#@ 	    option add *${class}${optionDbName} $value widgetDefault
#@ 	    set exports($option) $optionDbName
#@             set classopt($option) [list TkResource $value $ro 		    [list $tkwidget $realopt]]
#@ 	    set optionClass($option) [lindex [$foo configure $realopt] 1]
#@ 	    ::destroy $foo
#@             continue
#@         }
#@ 
#@ 	set optionDbName ".[lindex [_configure_option $option ""] 0]"
#@ 	option add *${class}${optionDbName} $value widgetDefault
#@ 	set exports($option) $optionDbName
#@         # for any other resource type, we keep original optdesc
#@         set classopt($option) [list $type $value $ro $arg]
#@     }
#@ }
#@ 
#@ 
#@ proc Widget::define { class filename args } {
#@     variable ::BWidget::use
#@     set use($class)      $args
#@     set use($class,file) $filename
#@     lappend use(classes) $class
#@ 
#@     if {[set x [lsearch -exact $args "-classonly"]] > -1} {
#@ 	set args [lreplace $args $x $x]
#@     } else {
#@ 	interp alias {} ::${class} {} ${class}::create
#@ 	proc ::${class}::use {} {}
#@ 
#@ 	bind $class <Destroy> [list Widget::destroy %W]
#@     }
#@ 
#@     foreach class $args { ${class}::use }
#@ }
#@ 
#@ 
#@ proc Widget::create { class path {rename 1} } {
#@     if {$rename} { rename $path ::$path:cmd }
#@     proc ::$path { cmd args }     	[subst {return \[eval \[linsert \$args 0 ${class}::\$cmd [list $path]\]\]}]
#@     return $path
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::addmap
#@ # ----------------------------------------------------------------------------
#@ proc Widget::addmap { class subclass subpath options } {
#@     upvar 0 ${class}::opt classopt
#@     upvar 0 ${class}::optionExports exports
#@     upvar 0 ${class}::optionClass optionClass
#@     upvar 0 ${class}::map classmap
#@     upvar 0 ${class}::map$subpath submap
#@ 
#@     foreach {option realopt} $options {
#@         if { ![string length $realopt] } {
#@             set realopt $option
#@         }
#@ 	set val [lindex $classopt($option) 1]
#@ 	set optDb ".[lindex [_configure_option $realopt ""] 0]"
#@ 	if { ![string equal $subpath ":cmd"] } {
#@ 	    set optDb "$subpath$optDb"
#@ 	}
#@ 	option add *${class}${optDb} $val widgetDefault
#@ 	lappend exports($option) $optDb
#@ 	# Store the forward and backward mappings for this
#@ 	# option <-> realoption pair
#@         lappend classmap($option) $subpath $subclass $realopt
#@ 	set submap($realopt) $option
#@     }
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::syncoptions
#@ # ----------------------------------------------------------------------------
#@ proc Widget::syncoptions { class subclass subpath options } {
#@     upvar 0 ${class}::sync classync
#@ 
#@     foreach {option realopt} $options {
#@         if { ![string length $realopt] } {
#@             set realopt $option
#@         }
#@         set classync($option) [list $subpath $subclass $realopt]
#@     }
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::init
#@ # ----------------------------------------------------------------------------
#@ proc Widget::init { class path options } {
#@     variable _inuse
#@     variable _class
#@     variable _optiontype
#@ 
#@     upvar 0 ${class}::opt classopt
#@     upvar 0 ${class}::$path:opt  pathopt
#@     upvar 0 ${class}::$path:mod  pathmod
#@     upvar 0 ${class}::map classmap
#@     upvar 0 ${class}::$path:init pathinit
#@ 
#@     if { [info exists pathopt] } {
#@ 	unset pathopt
#@     }
#@     if { [info exists pathmod] } {
#@ 	unset pathmod
#@     }
#@     # We prefer to use the actual widget for option db queries, but if it
#@     # doesn't exist yet, do the next best thing:  create a widget of the
#@     # same class and use that.
#@     set fpath $path
#@     set rdbclass [string map [list :: ""] $class]
#@     if { ![winfo exists $path] } {
#@ 	set fpath ".#BWidget.#Class#$class"
#@ 	# encapsulation frame to not pollute '.' childspace
#@ 	if {![winfo exists ".#BWidget"]} { frame ".#BWidget" }
#@ 	if { ![winfo exists $fpath] } {
#@ 	    frame $fpath -class $rdbclass
#@ 	}
#@     }
#@     foreach {option optdesc} [array get classopt] {
#@         set pathmod($option) 0
#@ 	if { [info exists classmap($option)] } {
#@ 	    continue
#@ 	}
#@         set type [lindex $optdesc 0]
#@         if { [string equal $type "Synonym"] } {
#@ 	    continue
#@         }
#@         if { [string equal $type "TkResource"] } {
#@             set alt [lindex [lindex $optdesc 3] 1]
#@         } else {
#@             set alt ""
#@         }
#@         set optdb [lindex [_configure_option $option $alt] 0]
#@         set def   [option get $fpath $optdb $rdbclass]
#@         if { [string length $def] } {
#@             set pathopt($option) $def
#@         } else {
#@             set pathopt($option) [lindex $optdesc 1]
#@         }
#@     }
#@ 
#@     if {![info exists _inuse($class)]} { set _inuse($class) 0 }
#@     incr _inuse($class)
#@ 
#@     set _class($path) $class
#@     foreach {option value} $options {
#@         if { ![info exists classopt($option)] } {
#@             unset pathopt
#@             unset pathmod
#@             return -code error "unknown option \"$option\""
#@         }
#@         set optdesc $classopt($option)
#@         set type    [lindex $optdesc 0]
#@         if { [string equal $type "Synonym"] } {
#@             set option  [lindex $optdesc 1]
#@             set optdesc $classopt($option)
#@             set type    [lindex $optdesc 0]
#@         }
#@         # this may fail if a wrong enum element was used
#@         if {[catch {
#@              $_optiontype($type) $option $value [lindex $optdesc 3]
#@         } msg]} {
#@             if {[info exists pathopt]} {
#@                 unset pathopt
#@             }
#@             unset pathmod
#@             return -code error $msg
#@         }
#@         set pathopt($option) $msg
#@ 	set pathinit($option) $pathopt($option)
#@     }
#@ }
#@ 
#@ # Bastien Chevreux (bach@mwgdna.com)
#@ #
#@ # copyinit performs basically the same job as init, but it uses a
#@ #  existing template to initialize its values. So, first a perferct copy
#@ #  from the template is made just to be altered by any existing options
#@ #  afterwards.
#@ # But this still saves time as the first initialization parsing block is
#@ #  skipped.
#@ # As additional bonus, items that differ in just a few options can be
#@ #  initialized faster by leaving out the options that are equal.
#@ 
#@ # This function is currently used only by ListBox::multipleinsert, but other
#@ #  calls should follow :)
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::copyinit
#@ # ----------------------------------------------------------------------------
#@ proc Widget::copyinit { class templatepath path options } {
#@     variable _class
#@     variable _optiontype
#@     upvar 0 ${class}::opt classopt 	    ${class}::$path:opt	 pathopt 	    ${class}::$path:mod	 pathmod 	    ${class}::$path:init pathinit 	    ${class}::$templatepath:opt	  templatepathopt 	    ${class}::$templatepath:mod	  templatepathmod 	    ${class}::$templatepath:init  templatepathinit
#@ 
#@     if { [info exists pathopt] } {
#@ 	unset pathopt
#@     }
#@     if { [info exists pathmod] } {
#@ 	unset pathmod
#@     }
#@ 
#@     # We use the template widget for option db copying, but it has to exist!
#@     array set pathmod  [array get templatepathmod]
#@     array set pathopt  [array get templatepathopt]
#@     array set pathinit [array get templatepathinit]
#@ 
#@     set _class($path) $class
#@     foreach {option value} $options {
#@ 	if { ![info exists classopt($option)] } {
#@ 	    unset pathopt
#@ 	    unset pathmod
#@ 	    return -code error "unknown option \"$option\""
#@ 	}
#@ 	set optdesc $classopt($option)
#@ 	set type    [lindex $optdesc 0]
#@ 	if { [string equal $type "Synonym"] } {
#@ 	    set option	[lindex $optdesc 1]
#@ 	    set optdesc $classopt($option)
#@ 	    set type	[lindex $optdesc 0]
#@ 	}
#@ 	set pathopt($option) [$_optiontype($type) $option $value [lindex $optdesc 3]]
#@ 	set pathinit($option) $pathopt($option)
#@     }
#@ }
#@ 
#@ # Widget::parseArgs --
#@ #
#@ #	Given a widget class and a command-line spec, cannonize and validate
#@ #	the given options, and return a keyed list consisting of the 
#@ #	component widget and its masked portion of the command-line spec, and
#@ #	one extra entry consisting of the portion corresponding to the 
#@ #	megawidget itself.
#@ #
#@ # Arguments:
#@ #	class	widget class to parse for.
#@ #	options	command-line spec
#@ #
#@ # Results:
#@ #	result	keyed list of portions of the megawidget and that segment of
#@ #		the command line in which that portion is interested.
#@ 
#@ proc Widget::parseArgs {class options} {
#@     variable _optiontype
#@     upvar 0 ${class}::opt classopt
#@     upvar 0 ${class}::map classmap
#@     
#@     foreach {option val} $options {
#@ 	if { ![info exists classopt($option)] } {
#@ 	    error "unknown option \"$option\""
#@ 	}
#@         set optdesc $classopt($option)
#@         set type    [lindex $optdesc 0]
#@         if { [string equal $type "Synonym"] } {
#@             set option  [lindex $optdesc 1]
#@             set optdesc $classopt($option)
#@             set type    [lindex $optdesc 0]
#@         }
#@ 	if { [string equal $type "TkResource"] } {
#@ 	    # Make sure that the widget used for this TkResource exists
#@ 	    Widget::_get_tkwidget_options [lindex [lindex $optdesc 3] 0]
#@ 	}
#@ 	set val [$_optiontype($type) $option $val [lindex $optdesc 3]]
#@ 		
#@ 	if { [info exists classmap($option)] } {
#@ 	    foreach {subpath subclass realopt} $classmap($option) {
#@ 		lappend maps($subpath) $realopt $val
#@ 	    }
#@ 	} else {
#@ 	    lappend maps($class) $option $val
#@ 	}
#@     }
#@     return [array get maps]
#@ }
#@ 
#@ # Widget::initFromODB --
#@ #
#@ #	Initialize a megawidgets options with information from the option
#@ #	database and from the command-line arguments given.
#@ #
#@ # Arguments:
#@ #	class	class of the widget.
#@ #	path	path of the widget -- should already exist.
#@ #	options	command-line arguments.
#@ #
#@ # Results:
#@ #	None.
#@ 
#@ proc Widget::initFromODB {class path options} {
#@     variable _inuse
#@     variable _class
#@ 
#@     upvar 0 ${class}::$path:opt  pathopt
#@     upvar 0 ${class}::$path:mod  pathmod
#@     upvar 0 ${class}::map classmap
#@ 
#@     if { [info exists pathopt] } {
#@ 	unset pathopt
#@     }
#@     if { [info exists pathmod] } {
#@ 	unset pathmod
#@     }
#@     # We prefer to use the actual widget for option db queries, but if it
#@     # doesn't exist yet, do the next best thing:  create a widget of the
#@     # same class and use that.
#@     set fpath [_get_window $class $path]
#@     set rdbclass [string map [list :: ""] $class]
#@     if { ![winfo exists $path] } {
#@ 	set fpath ".#BWidget.#Class#$class"
#@ 	# encapsulation frame to not pollute '.' childspace
#@ 	if {![winfo exists ".#BWidget"]} { frame ".#BWidget" }
#@ 	if { ![winfo exists $fpath] } {
#@ 	    frame $fpath -class $rdbclass
#@ 	}
#@     }
#@ 
#@     foreach {option optdesc} [array get ${class}::opt] {
#@         set pathmod($option) 0
#@ 	if { [info exists classmap($option)] } {
#@ 	    continue
#@ 	}
#@         set type [lindex $optdesc 0]
#@         if { [string equal $type "Synonym"] } {
#@ 	    continue
#@         }
#@ 	if { [string equal $type "TkResource"] } {
#@             set alt [lindex [lindex $optdesc 3] 1]
#@         } else {
#@             set alt ""
#@         }
#@         set optdb [lindex [_configure_option $option $alt] 0]
#@         set def   [option get $fpath $optdb $rdbclass]
#@         if { [string length $def] } {
#@             set pathopt($option) $def
#@         } else {
#@             set pathopt($option) [lindex $optdesc 1]
#@         }
#@     }
#@ 
#@     if {![info exists _inuse($class)]} { set _inuse($class) 0 }
#@     incr _inuse($class)
#@ 
#@     set _class($path) $class
#@     array set pathopt $options
#@ }
#@ 
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::destroy
#@ # ----------------------------------------------------------------------------
#@ proc Widget::destroy { path } {
#@     variable _class
#@     variable _inuse
#@ 
#@     if {![info exists _class($path)]} { return }
#@ 
#@     set class $_class($path)
#@     upvar 0 ${class}::$path:opt pathopt
#@     upvar 0 ${class}::$path:mod pathmod
#@     upvar 0 ${class}::$path:init pathinit
#@ 
#@     if {[info exists _inuse($class)]} { incr _inuse($class) -1 }
#@ 
#@     if {[info exists pathopt]} {
#@         unset pathopt
#@     }
#@     if {[info exists pathmod]} {
#@         unset pathmod
#@     }
#@     if {[info exists pathinit]} {
#@         unset pathinit
#@     }
#@ 
#@     if {![string equal [info commands $path] ""]} { rename $path "" }
#@ 
#@     ## Unset any variables used in this widget.
#@     foreach var [info vars ::${class}::$path:*] { unset $var }
#@ 
#@     unset _class($path)
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::configure
#@ # ----------------------------------------------------------------------------
#@ proc Widget::configure { path options } {
#@     set len [llength $options]
#@     if { $len <= 1 } {
#@         return [_get_configure $path $options]
#@     } elseif { $len % 2 == 1 } {
#@         return -code error "incorrect number of arguments"
#@     }
#@ 
#@     variable _class
#@     variable _optiontype
#@ 
#@     set class $_class($path)
#@     upvar 0 ${class}::opt  classopt
#@     upvar 0 ${class}::map  classmap
#@     upvar 0 ${class}::$path:opt pathopt
#@     upvar 0 ${class}::$path:mod pathmod
#@ 
#@     set window [_get_window $class $path]
#@     foreach {option value} $options {
#@         if { ![info exists classopt($option)] } {
#@             return -code error "unknown option \"$option\""
#@         }
#@         set optdesc $classopt($option)
#@         set type    [lindex $optdesc 0]
#@         if { [string equal $type "Synonym"] } {
#@             set option  [lindex $optdesc 1]
#@             set optdesc $classopt($option)
#@             set type    [lindex $optdesc 0]
#@         }
#@         if { ![lindex $optdesc 2] } {
#@             set newval [$_optiontype($type) $option $value [lindex $optdesc 3]]
#@             if { [info exists classmap($option)] } {
#@ 		set window [_get_window $class $window]
#@                 foreach {subpath subclass realopt} $classmap($option) {
#@                     # Interpretation of special pointers:
#@                     # | subclass | subpath | widget           | path           | class   |
#@                     # +----------+---------+------------------+----------------+-context-+
#@                     # | :cmd     | :cmd    | herited widget   | window:cmd     |window   |
#@                     # | :cmd     | *       | subwidget        | window.subpath | window  |
#@                     # | ""       | :cmd    | herited widget   | window:cmd     | window  |
#@                     # | ""       | *       | own              | window         | window  |
#@                     # | *        | :cmd    | own              | window         | current |
#@                     # | *        | *       | subwidget        | window.subpath | current |
#@                     if { [string length $subclass] && ! [string equal $subclass ":cmd"] } {
#@                         if { [string equal $subpath ":cmd"] } {
#@                             set subpath ""
#@                         }
#@                         set curval [${subclass}::cget $window$subpath $realopt]
#@                         ${subclass}::configure $window$subpath $realopt $newval
#@                     } else {
#@                         set curval [$window$subpath cget $realopt]
#@                         $window$subpath configure $realopt $newval
#@                     }
#@                 }
#@             } else {
#@ 		set curval $pathopt($option)
#@ 		set pathopt($option) $newval
#@ 	    }
#@ 	    set pathmod($option) [expr {![string equal $newval $curval]}]
#@         }
#@     }
#@ 
#@     return {}
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::cget
#@ # ----------------------------------------------------------------------------
#@ proc Widget::cget { path option } {
#@     variable _class
#@     if { ![info exists _class($path)] } {
#@         return -code error "unknown widget $path"
#@     }
#@ 
#@     set class $_class($path)
#@     if { ![info exists ${class}::opt($option)] } {
#@         return -code error "unknown option \"$option\""
#@     }
#@ 
#@     set optdesc [set ${class}::opt($option)]
#@     set type    [lindex $optdesc 0]
#@     if {[string equal $type "Synonym"]} {
#@         set option [lindex $optdesc 1]
#@     }
#@ 
#@     if { [info exists ${class}::map($option)] } {
#@ 	foreach {subpath subclass realopt} [set ${class}::map($option)] {break}
#@ 	set path "[_get_window $class $path]$subpath"
#@ 	return [$path cget $realopt]
#@     }
#@     upvar 0 ${class}::$path:opt pathopt
#@     set pathopt($option)
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::subcget
#@ # ----------------------------------------------------------------------------
#@ proc Widget::subcget { path subwidget } {
#@     variable _class
#@     set class $_class($path)
#@     upvar 0 ${class}::$path:opt pathopt
#@     upvar 0 ${class}::map$subwidget submap
#@     upvar 0 ${class}::$path:init pathinit
#@ 
#@     set result {}
#@     foreach realopt [array names submap] {
#@ 	if { [info exists pathinit($submap($realopt))] } {
#@ 	    lappend result $realopt $pathopt($submap($realopt))
#@ 	}
#@     }
#@     return $result
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::hasChanged
#@ # ----------------------------------------------------------------------------
#@ proc Widget::hasChanged { path option pvalue } {
#@     variable _class
#@     upvar $pvalue value
#@     set class $_class($path)
#@     upvar 0 ${class}::$path:mod pathmod
#@ 
#@     set value   [Widget::cget $path $option]
#@     set result  $pathmod($option)
#@     set pathmod($option) 0
#@ 
#@     return $result
#@ }
#@ 
#@ proc Widget::hasChangedX { path option args } {
#@     variable _class
#@     set class $_class($path)
#@     upvar 0 ${class}::$path:mod pathmod
#@ 
#@     set result  $pathmod($option)
#@     set pathmod($option) 0
#@     foreach option $args {
#@ 	lappend result $pathmod($option)
#@ 	set pathmod($option) 0
#@     }
#@ 
#@     set result
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::setoption
#@ # ----------------------------------------------------------------------------
#@ proc Widget::setoption { path option value } {
#@ #    variable _class
#@ 
#@ #    set class $_class($path)
#@ #    upvar 0 ${class}::$path:opt pathopt
#@ 
#@ #    set pathopt($option) $value
#@     Widget::configure $path [list $option $value]
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::getoption
#@ # ----------------------------------------------------------------------------
#@ proc Widget::getoption { path option } {
#@ #    set class $::Widget::_class($path)
#@ #    upvar 0 ${class}::$path:opt pathopt
#@ 
#@ #    return $pathopt($option)
#@     return [Widget::cget $path $option]
#@ }
#@ 
#@ # Widget::getMegawidgetOption --
#@ #
#@ #	Bypass the superfluous checks in cget and just directly peer at the
#@ #	widget's data space.  This is much more fragile than cget, so it 
#@ #	should only be used with great care, in places where speed is critical.
#@ #
#@ # Arguments:
#@ #	path	widget to lookup options for.
#@ #	option	option to retrieve.
#@ #
#@ # Results:
#@ #	value	option value.
#@ 
#@ proc Widget::getMegawidgetOption {path option} {
#@     variable _class
#@     set class $_class($path)
#@     upvar 0 ${class}::${path}:opt pathopt
#@     set pathopt($option)
#@ }
#@ 
#@ # Widget::setMegawidgetOption --
#@ #
#@ #	Bypass the superfluous checks in cget and just directly poke at the
#@ #	widget's data space.  This is much more fragile than configure, so it 
#@ #	should only be used with great care, in places where speed is critical.
#@ #
#@ # Arguments:
#@ #	path	widget to lookup options for.
#@ #	option	option to retrieve.
#@ #	value	option value.
#@ #
#@ # Results:
#@ #	value	option value.
#@ 
#@ proc Widget::setMegawidgetOption {path option value} {
#@     variable _class
#@     set class $_class($path)
#@     upvar 0 ${class}::${path}:opt pathopt
#@     set pathopt($option) $value
#@ }
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_get_window
#@ #  returns the window corresponding to widget path
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_get_window { class path } {
#@     set idx [string last "#" $path]
#@     if { $idx != -1 && [string equal [string range $path [expr {$idx+1}] end] $class] } {
#@         return [string range $path 0 [expr {$idx-1}]]
#@     } else {
#@         return $path
#@     }
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_get_configure
#@ #  returns the configuration list of options
#@ #  (as tk widget do - [$w configure ?option?])
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_get_configure { path options } {
#@     variable _class
#@ 
#@     set class $_class($path)
#@     upvar 0 ${class}::opt classopt
#@     upvar 0 ${class}::map classmap
#@     upvar 0 ${class}::$path:opt pathopt
#@     upvar 0 ${class}::$path:mod pathmod
#@ 
#@     set len [llength $options]
#@     if { !$len } {
#@         set result {}
#@         foreach option [lsort [array names classopt]] {
#@             set optdesc $classopt($option)
#@             set type    [lindex $optdesc 0]
#@             if { [string equal $type "Synonym"] } {
#@                 set syn     $option
#@                 set option  [lindex $optdesc 1]
#@                 set optdesc $classopt($option)
#@                 set type    [lindex $optdesc 0]
#@             } else {
#@                 set syn ""
#@             }
#@             if { [string equal $type "TkResource"] } {
#@                 set alt [lindex [lindex $optdesc 3] 1]
#@             } else {
#@                 set alt ""
#@             }
#@             set res [_configure_option $option $alt]
#@             if { $syn == "" } {
#@                 lappend result [concat $option $res [list [lindex $optdesc 1]] [list [cget $path $option]]]
#@             } else {
#@                 lappend result [list $syn [lindex $res 0]]
#@             }
#@         }
#@         return $result
#@     } elseif { $len == 1 } {
#@         set option  [lindex $options 0]
#@         if { ![info exists classopt($option)] } {
#@             return -code error "unknown option \"$option\""
#@         }
#@         set optdesc $classopt($option)
#@         set type    [lindex $optdesc 0]
#@         if { [string equal $type "Synonym"] } {
#@             set option  [lindex $optdesc 1]
#@             set optdesc $classopt($option)
#@             set type    [lindex $optdesc 0]
#@         }
#@         if { [string equal $type "TkResource"] } {
#@             set alt [lindex [lindex $optdesc 3] 1]
#@         } else {
#@             set alt ""
#@         }
#@         set res [_configure_option $option $alt]
#@         return [concat $option $res [list [lindex $optdesc 1]] [list [cget $path $option]]]
#@     }
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_configure_option
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_configure_option { option altopt } {
#@     variable _optiondb
#@     variable _optionclass
#@ 
#@     if { [info exists _optiondb($option)] } {
#@         set optdb $_optiondb($option)
#@     } else {
#@         set optdb [string range $option 1 end]
#@     }
#@     if { [info exists _optionclass($option)] } {
#@         set optclass $_optionclass($option)
#@     } elseif { [string length $altopt] } {
#@         if { [info exists _optionclass($altopt)] } {
#@             set optclass $_optionclass($altopt)
#@         } else {
#@             set optclass [string range $altopt 1 end]
#@         }
#@     } else {
#@         set optclass [string range $option 1 end]
#@     }
#@     return [list $optdb $optclass]
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_get_tkwidget_options
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_get_tkwidget_options { tkwidget } {
#@     variable _tk_widget
#@     variable _optiondb
#@     variable _optionclass
#@ 
#@     set widget ".#BWidget.#$tkwidget"
#@     # encapsulation frame to not pollute '.' childspace
#@     if {![winfo exists ".#BWidget"]} { frame ".#BWidget" }
#@     if { ![winfo exists $widget] || ![info exists _tk_widget($tkwidget)] } {
#@ 	set widget [$tkwidget $widget]
#@ 	# JDC: Withdraw toplevels, otherwise visible
#@ 	if {[string equal $tkwidget "toplevel"]} {
#@ 	    wm withdraw $widget
#@ 	}
#@ 	set config [$widget configure]
#@ 	foreach optlist $config {
#@ 	    set opt [lindex $optlist 0]
#@ 	    if { [llength $optlist] == 2 } {
#@ 		set refsyn [lindex $optlist 1]
#@ 		# search for class
#@ 		set idx [lsearch $config [list * $refsyn *]]
#@ 		if { $idx == -1 } {
#@ 		    if { [string index $refsyn 0] == "-" } {
#@ 			# search for option (tk8.1b1 bug)
#@ 			set idx [lsearch $config [list $refsyn * *]]
#@ 		    } else {
#@ 			# last resort
#@ 			set idx [lsearch $config [list -[string tolower $refsyn] * *]]
#@ 		    }
#@ 		    if { $idx == -1 } {
#@ 			# fed up with "can't read classopt()"
#@ 			return -code error "can't find option of synonym $opt"
#@ 		    }
#@ 		}
#@ 		set syn [lindex [lindex $config $idx] 0]
#@ 		# JDC: used 4 (was 3) to get def from optiondb
#@ 		set def [lindex [lindex $config $idx] 4]
#@ 		lappend _tk_widget($tkwidget) [list $opt $syn $def]
#@ 	    } else {
#@ 		# JDC: used 4 (was 3) to get def from optiondb
#@ 		set def [lindex $optlist 4]
#@ 		lappend _tk_widget($tkwidget) [list $opt $def]
#@ 		set _optiondb($opt)    [lindex $optlist 1]
#@ 		set _optionclass($opt) [lindex $optlist 2]
#@ 	    }
#@ 	}
#@     }
#@     return $_tk_widget($tkwidget)
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_test_tkresource
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_test_tkresource { option value arg } {
#@ #    set tkwidget [lindex $arg 0]
#@ #    set realopt  [lindex $arg 1]
#@     foreach {tkwidget realopt} $arg break
#@     set path     ".#BWidget.#$tkwidget"
#@     set old      [$path cget $realopt]
#@     $path configure $realopt $value
#@     set res      [$path cget $realopt]
#@     $path configure $realopt $old
#@ 
#@     return $res
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_test_bwresource
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_test_bwresource { option value arg } {
#@     return -code error "bad option type BwResource in widget"
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_test_synonym
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_test_synonym { option value arg } {
#@     return -code error "bad option type Synonym in widget"
#@ }
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_test_color
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_test_color { option value arg } {
#@     if {[catch {winfo rgb . $value} color]} {
#@         return -code error "bad $option value \"$value\": must be a colorname 		or #RRGGBB triplet"
#@     }
#@ 
#@     return $value
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_test_string
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_test_string { option value arg } {
#@     set value
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::_test_flag
#@ # ----------------------------------------------------------------------------
#@ proc Widget::_test_flag { option value arg } {
#@     set len [string length $value]
#@     set res ""
#@     for {set i 0} {$i < $len} {incr i} {
#@         set c [string index $value $i]
#@         if { [string first $c $arg] == -1 } {
#@             return -code error "bad [string range $option 1 end] value \"$value\": characters must be in \"$arg\""
#@         }
#@         if { [string first $c $res] == -1 } {
#@             append res $c
#@         }
#@     }
#@     return $res
#@ }
#@ 
#@ 
#@ # -----------------------------------------------------------------------------
#@ #  Command Widget::_test_enum
#@ # -----------------------------------------------------------------------------
#@ proc Widget::_test_enum { option value arg } {
#@     if { [lsearch $arg $value] == -1 } {
#@         set last [lindex   $arg end]
#@         set sub  [lreplace $arg end end]
#@         if { [llength $sub] } {
#@             set str "[join $sub ", "] or $last"
#@         } else {
#@             set str $last
#@         }
#@         return -code error "bad [string range $option 1 end] value \"$value\": must be $str"
#@     }
#@     return $value
#@ }
#@ 
#@ 
#@ # -----------------------------------------------------------------------------
#@ #  Command Widget::_test_int
#@ # -----------------------------------------------------------------------------
#@ proc Widget::_test_int { option value arg } {
#@     if { ![string is int -strict $value] || 	    ([string length $arg] && 	    ![expr [string map [list %d $value] $arg]]) } {
#@ 		    return -code error "bad $option value			    \"$value\": must be integer ($arg)"
#@     }
#@     return $value
#@ }
#@ 
#@ 
#@ # -----------------------------------------------------------------------------
#@ #  Command Widget::_test_boolean
#@ # -----------------------------------------------------------------------------
#@ proc Widget::_test_boolean { option value arg } {
#@     if { ![string is boolean -strict $value] } {
#@         return -code error "bad $option value \"$value\": must be boolean"
#@     }
#@ 
#@     # Get the canonical form of the boolean value (1 for true, 0 for false)
#@     return [string is true $value]
#@ }
#@ 
#@ 
#@ # -----------------------------------------------------------------------------
#@ #  Command Widget::_test_padding
#@ # -----------------------------------------------------------------------------
#@ proc Widget::_test_padding { option values arg } {
#@     set len [llength $values]
#@     if {$len < 1 || $len > 2} {
#@         return -code error "bad pad value \"$values\":                        must be positive screen distance"
#@     }
#@ 
#@     foreach value $values {
#@         if { ![string is int -strict $value] ||             ([string length $arg] &&             ![expr [string map [list %d $value] $arg]]) } {
#@                 return -code error "bad pad value \"$value\":                                must be positive screen distance ($arg)"
#@         }
#@     }
#@     return $values
#@ }
#@ 
#@ 
#@ # Widget::_get_padding --
#@ #
#@ #       Return the requesting padding value for a padding option.
#@ #
#@ # Arguments:
#@ #	path		Widget to get the options for.
#@ #       option          The name of the padding option.
#@ #	index		The index of the padding.  If the index is empty,
#@ #                       the first padding value is returned.
#@ #
#@ # Results:
#@ #	Return a numeric value that can be used for padding.
#@ proc Widget::_get_padding { path option {index 0} } {
#@     set pad [Widget::cget $path $option]
#@     set val [lindex $pad $index]
#@     if {$val == ""} { set val [lindex $pad 0] }
#@     return $val
#@ }
#@ 
#@ 
#@ # -----------------------------------------------------------------------------
#@ #  Command Widget::focusNext
#@ #  Same as tk_focusNext, but call Widget::focusOK
#@ # -----------------------------------------------------------------------------
#@ proc Widget::focusNext { w } {
#@     set cur $w
#@     while 1 {
#@ 
#@ 	# Descend to just before the first child of the current widget.
#@ 
#@ 	set parent $cur
#@ 	set children [winfo children $cur]
#@ 	set i -1
#@ 
#@ 	# Look for the next sibling that isn't a top-level.
#@ 
#@ 	while 1 {
#@ 	    incr i
#@ 	    if {$i < [llength $children]} {
#@ 		set cur [lindex $children $i]
#@ 		if {[string equal [winfo toplevel $cur] $cur]} {
#@ 		    continue
#@ 		} else {
#@ 		    break
#@ 		}
#@ 	    }
#@ 
#@ 	    # No more siblings, so go to the current widget's parent.
#@ 	    # If it's a top-level, break out of the loop, otherwise
#@ 	    # look for its next sibling.
#@ 
#@ 	    set cur $parent
#@ 	    if {[string equal [winfo toplevel $cur] $cur]} {
#@ 		break
#@ 	    }
#@ 	    set parent [winfo parent $parent]
#@ 	    set children [winfo children $parent]
#@ 	    set i [lsearch -exact $children $cur]
#@ 	}
#@ 	if {[string equal $cur $w] || [focusOK $cur]} {
#@ 	    return $cur
#@ 	}
#@     }
#@ }
#@ 
#@ 
#@ # -----------------------------------------------------------------------------
#@ #  Command Widget::focusPrev
#@ #  Same as tk_focusPrev, except:
#@ #	+ Don't traverse from a child to a direct ancestor
#@ #	+ Call Widget::focusOK instead of tk::focusOK
#@ # -----------------------------------------------------------------------------
#@ proc Widget::focusPrev { w } {
#@     set cur $w
#@     set origParent [winfo parent $w]
#@     while 1 {
#@ 
#@ 	# Collect information about the current window's position
#@ 	# among its siblings.  Also, if the window is a top-level,
#@ 	# then reposition to just after the last child of the window.
#@ 
#@ 	if {[string equal [winfo toplevel $cur] $cur]}  {
#@ 	    set parent $cur
#@ 	    set children [winfo children $cur]
#@ 	    set i [llength $children]
#@ 	} else {
#@ 	    set parent [winfo parent $cur]
#@ 	    set children [winfo children $parent]
#@ 	    set i [lsearch -exact $children $cur]
#@ 	}
#@ 
#@ 	# Go to the previous sibling, then descend to its last descendant
#@ 	# (highest in stacking order.  While doing this, ignore top-levels
#@ 	# and their descendants.  When we run out of descendants, go up
#@ 	# one level to the parent.
#@ 
#@ 	while {$i > 0} {
#@ 	    incr i -1
#@ 	    set cur [lindex $children $i]
#@ 	    if {[string equal [winfo toplevel $cur] $cur]} {
#@ 		continue
#@ 	    }
#@ 	    set parent $cur
#@ 	    set children [winfo children $parent]
#@ 	    set i [llength $children]
#@ 	}
#@ 	set cur $parent
#@ 	if {[string equal $cur $w]} {
#@ 	    return $cur
#@ 	}
#@ 	# If we are just at the original parent of $w, skip it as a
#@ 	# potential focus accepter.  Extra safety in this is to see if
#@ 	# that parent is also a proc (not a C command), which is what
#@ 	# BWidgets makes for any megawidget.  Could possibly also check
#@ 	# for '[info commands ::${origParent}:cmd] != ""'.  [Bug 765667]
#@ 	if {[string equal $cur $origParent]
#@ 	    && [info procs ::$origParent] != ""} {
#@ 	    continue
#@ 	}
#@ 	if {[focusOK $cur]} {
#@ 	    return $cur
#@ 	}
#@     }
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command Widget::focusOK
#@ #  Same as tk_focusOK, but handles -editable option and whole tags list.
#@ # ----------------------------------------------------------------------------
#@ proc Widget::focusOK { w } {
#@     set code [catch {$w cget -takefocus} value]
#@     if { $code == 1 } {
#@         return 0
#@     }
#@     if {($code == 0) && ($value != "")} {
#@ 	if {$value == 0} {
#@ 	    return 0
#@ 	} elseif {$value == 1} {
#@ 	    return [winfo viewable $w]
#@ 	} else {
#@ 	    set value [uplevel \#0 $value $w]
#@             if {$value != ""} {
#@ 		return $value
#@ 	    }
#@         }
#@     }
#@     if {![winfo viewable $w]} {
#@ 	return 0
#@     }
#@     set code [catch {$w cget -state} value]
#@     if {($code == 0) && ($value == "disabled")} {
#@ 	return 0
#@     }
#@     set code [catch {$w cget -editable} value]
#@     if {($code == 0) && ($value == 0)} {
#@         return 0
#@     }
#@ 
#@     set top [winfo toplevel $w]
#@     foreach tags [bindtags $w] {
#@         if { ![string equal $tags $top]  &&
#@              ![string equal $tags "all"] &&
#@              [regexp Key [bind $tags]] } {
#@             return 1
#@         }
#@     }
#@     return 0
#@ }
#@ 
#@ 
#@ proc Widget::traverseTo { w } {
#@     set focus [focus]
#@     if {![string equal $focus ""]} {
#@ 	event generate $focus <<TraverseOut>>
#@     }
#@     focus $w
#@ 
#@     event generate $w <<TraverseIn>>
#@ }
#@ 
#@ 
#@ # Widget::varForOption --
#@ #
#@ #	Retrieve a fully qualified variable name for the option specified.
#@ #	If the option is not one for which a variable exists, throw an error 
#@ #	(ie, those options that map directly to widget options).
#@ #
#@ # Arguments:
#@ #	path	megawidget to get an option var for.
#@ #	option	option to get a var for.
#@ #
#@ # Results:
#@ #	varname	name of the variable, fully qualified, suitable for tracing.
#@ 
#@ proc Widget::varForOption {path option} {
#@     variable _class
#@     variable _optiontype
#@ 
#@     set class $_class($path)
#@     upvar 0 ${class}::$path:opt pathopt
#@ 
#@     if { ![info exists pathopt($option)] } {
#@ 	error "unable to find variable for option \"$option\""
#@     }
#@     set varname "::Widget::${class}::$path:opt($option)"
#@     return $varname
#@ }
#@ 
#@ # Widget::getVariable --
#@ #
#@ #       Get a variable from within the namespace of the widget.
#@ #
#@ # Arguments:
#@ #	path		Megawidget to get the variable for.
#@ #	varName		The variable name to retrieve.
#@ #       newVarName	The variable name to refer to in the calling proc.
#@ #
#@ # Results:
#@ #	Creates a reference to newVarName in the calling proc.
#@ proc Widget::getVariable { path varName {newVarName ""} } {
#@     variable _class
#@     set class $_class($path)
#@     if {![string length $newVarName]} { set newVarName $varName }
#@     uplevel 1 [list upvar \#0 ${class}::$path:$varName $newVarName]
#@ }
#@ 
#@ # Widget::options --
#@ #
#@ #       Return a key-value list of options for a widget.  This can
#@ #       be used to serialize the options of a widget and pass them
#@ #       on to a new widget with the same options.
#@ #
#@ # Arguments:
#@ #	path		Widget to get the options for.
#@ #	args		A list of options.  If empty, all options are returned.
#@ #
#@ # Results:
#@ #	Returns list of options as: -option value -option value ...
#@ proc Widget::options { path args } {
#@     if {[llength $args]} {
#@         foreach option $args {
#@             lappend options [_get_configure $path $option]
#@         }
#@     } else {
#@         set options [_get_configure $path {}]
#@     }
#@ 
#@     set result [list]
#@     foreach list $options {
#@         if {[llength $list] < 5} { continue }
#@         lappend result [lindex $list 0] [lindex $list end]
#@     }
#@     return $result
#@ }
#@ 
#@ 
#@ # Widget::getOption --
#@ #
#@ #	Given a list of widgets, determine which option value to use.
#@ #	The widgets are given to the command in order of highest to
#@ #	lowest.  Starting with the lowest widget, whichever one does
#@ #	not match the default option value is returned as the value.
#@ #	If all the widgets are default, we return the highest widget's
#@ #	value.
#@ #
#@ # Arguments:
#@ #	option		The option to check.
#@ #	default		The default value.  If any widget in the list
#@ #			does not match this default, its value is used.
#@ #	args		A list of widgets.
#@ #
#@ # Results:
#@ #	Returns the value of the given option to use.
#@ #
#@ proc Widget::getOption { option default args } {
#@     for {set i [expr [llength $args] -1]} {$i >= 0} {incr i -1} {
#@ 	set widget [lindex $args $i]
#@ 	set value  [Widget::cget $widget $option]
#@ 	if {[string equal $value $default]} { continue }
#@ 	return $value
#@     }
#@     return $value
#@ }
#@ 
#@ 
#@ proc Widget::nextIndex { path node } {
#@     Widget::getVariable $path autoIndex
#@     if {![info exists autoIndex]} { set autoIndex -1 }
#@     return [string map [list #auto [incr autoIndex]] $node]
#@ }
#@ 
#@ 
#@ proc Widget::exists { path } {
#@     variable _class
#@     return [info exists _class($path)]
#@ }
#@ 
#@ proc Widget::theme {{bool {}}} {
#@     # Private, *experimental* API that may change at any time - JH
#@     variable _theme
#@     if {[llength [info level 0]] == 2} {
#@ 	# set theme-ability
#@ 	if {[catch {package require Tk 8.5a6}]
#@ 	    && [catch {package require tile 0.6}]
#@ 	    && [catch {package require tile 1}]} {
#@ 	    return -code error "BWidget's theming requires tile 0.6+"
#@ 	} else {
#@ 	    catch {style default BWSlim.Toolbutton -padding 0}
#@ 	}
#@ 	set _theme [string is true -strict $bool]
#@     }
#@     return $_theme
#@ }
#@ # -- End source /opt/synopsys/icc-201506/auxx/syn/fp/bw/widget.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/syn/fp/bw/init.tcl

#@ namespace eval Widget {}
#@ proc Widget::_opt_defaults {{prio widgetDefault}} {
#@     if {$::tcl_version >= 8.4} {
#@ 	set plat [tk windowingsystem]
#@     } else {
#@ 	set plat $::tcl_platform(platform)
#@     }
#@     switch -exact $plat {
#@ 	"aqua" {
#@ 	}
#@ 	"win32" -
#@ 	"windows" {
#@ 	    #option add *Listbox.background	SystemWindow $prio
#@ 	    option add *ListBox.background	SystemWindow $prio
#@ 	    #option add *Button.padY		0 $prio
#@ 	    option add *ButtonBox.padY		0 $prio
#@ 	    option add *Dialog.padY		0 $prio
#@ 	    option add *Dialog.anchor		e $prio
#@ 	}
#@ 	"x11" -
#@ 	default {
#@ 	    option add *Scrollbar.width		12 $prio
#@ 	    option add *Scrollbar.borderWidth	1  $prio
#@ 	    option add *Dialog.separator	1  $prio
#@ 	    option add *MainFrame.relief	raised $prio
#@ 	    option add *MainFrame.separator	none   $prio
#@ 	}
#@     }
#@ }
#@ Widget::_opt_defaults
#@ 
#@ option read [file join $::BWIDGET::LIBRARY "lang" "en.rc"]
#@ 
#@ ## Add a TraverseIn binding to standard Tk widgets to handle some of
#@ ## the BWidget-specific things we do.
#@ bind Entry   <<TraverseIn>> { %W selection range 0 end; %W icursor end }
#@ bind Spinbox <<TraverseIn>> { %W selection range 0 end; %W icursor end }
#@ 
#@ bind all <Key-Tab>       { Widget::traverseTo [Widget::focusNext %W] }
#@ bind all <<PrevWindow>>  { Widget::traverseTo [Widget::focusPrev %W] }
#@ # -- End source /opt/synopsys/icc-201506/auxx/syn/fp/bw/init.tcl

#@ # -- Starting source /opt/synopsys/icc-201506/auxx/syn/fp/bw/utils.tcl

#@ # ----------------------------------------------------------------------------
#@ #  utils.tcl
#@ #  This file is part of Unifix BWidget Toolkit
#@ #  $Id: utils.tcl,v 1.15.2.1 2009/09/03 17:29:03 oehhar Exp $
#@ # ----------------------------------------------------------------------------
#@ #  Index of commands:
#@ #     - GlobalVar::exists
#@ #     - GlobalVar::setvarvar
#@ #     - GlobalVar::getvarvar
#@ #     - BWidget::assert
#@ #     - BWidget::clonename
#@ #     - BWidget::get3dcolor
#@ #     - BWidget::XLFDfont
#@ #     - BWidget::place
#@ #     - BWidget::grab
#@ #     - BWidget::focus
#@ # ----------------------------------------------------------------------------
#@ 
#@ namespace eval GlobalVar {
#@     proc use {} {}
#@ }
#@ 
#@ 
#@ namespace eval BWidget {
#@     variable _top
#@     variable _gstack {}
#@     variable _fstack {}
#@     proc use {} {}
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command GlobalVar::exists
#@ # ----------------------------------------------------------------------------
#@ proc GlobalVar::exists { varName } {
#@     return [uplevel \#0 [list info exists $varName]]
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command GlobalVar::setvar
#@ # ----------------------------------------------------------------------------
#@ proc GlobalVar::setvar { varName value } {
#@     return [uplevel \#0 [list set $varName $value]]
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command GlobalVar::getvar
#@ # ----------------------------------------------------------------------------
#@ proc GlobalVar::getvar { varName } {
#@     return [uplevel \#0 [list set $varName]]
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command GlobalVar::tracevar
#@ # ----------------------------------------------------------------------------
#@ proc GlobalVar::tracevar { cmd varName args } {
#@     return [uplevel \#0 [list trace $cmd $varName] $args]
#@ }
#@ 
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::lreorder
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::lreorder { list neworder } {
#@     set pos     0
#@     set newlist {}
#@     foreach e $neworder {
#@         if { [lsearch -exact $list $e] != -1 } {
#@             lappend newlist $e
#@             set tabelt($e)  1
#@         }
#@     }
#@     set len [llength $newlist]
#@     if { !$len } {
#@         return $list
#@     }
#@     if { $len == [llength $list] } {
#@         return $newlist
#@     }
#@     set pos 0
#@     foreach e $list {
#@         if { ![info exists tabelt($e)] } {
#@             set newlist [linsert $newlist $pos $e]
#@         }
#@         incr pos
#@     }
#@     return $newlist
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::assert
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::assert { exp {msg ""}} {
#@     set res [uplevel 1 expr $exp]
#@     if { !$res} {
#@         if { $msg == "" } {
#@             return -code error "Assertion failed: {$exp}"
#@         } else {
#@             return -code error $msg
#@         }
#@     }
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::clonename
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::clonename { menu } {
#@     set path     ""
#@     set menupath ""
#@     set found    0
#@     foreach widget [lrange [split $menu "."] 1 end] {
#@         if { $found || [winfo class "$path.$widget"] == "Menu" } {
#@             set found 1
#@             append menupath "#" $widget
#@             append path "." $menupath
#@         } else {
#@             append menupath "#" $widget
#@             append path "." $widget
#@         }
#@     }
#@     return $path
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::getname
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::getname { name } {
#@     if { [string length $name] } {
#@         set text [option get . "${name}Name" ""]
#@         if { [string length $text] } {
#@             return [parsetext $text]
#@         }
#@     }
#@     return {}
#@  }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::parsetext
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::parsetext { text } {
#@     set result ""
#@     set index  -1
#@     set start  0
#@     while { [string length $text] } {
#@         set idx [string first "&" $text]
#@         if { $idx == -1 } {
#@             append result $text
#@             set text ""
#@         } else {
#@             set char [string index $text [expr {$idx+1}]]
#@             if { $char == "&" } {
#@                 append result [string range $text 0 $idx]
#@                 set    text   [string range $text [expr {$idx+2}] end]
#@                 set    start  [expr {$start+$idx+1}]
#@             } else {
#@                 append result [string range $text 0 [expr {$idx-1}]]
#@                 set    text   [string range $text [expr {$idx+1}] end]
#@                 incr   start  $idx
#@                 set    index  $start
#@             }
#@         }
#@     }
#@     return [list $result $index]
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::get3dcolor
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::get3dcolor { path bgcolor } {
#@     foreach val [winfo rgb $path $bgcolor] {
#@         lappend dark [expr {60*$val/100}]
#@         set tmp1 [expr {14*$val/10}]
#@         if { $tmp1 > 65535 } {
#@             set tmp1 65535
#@         }
#@         set tmp2 [expr {(65535+$val)/2}]
#@         lappend light [expr {($tmp1 > $tmp2) ? $tmp1:$tmp2}]
#@     }
#@     return [list [eval format "#%04x%04x%04x" $dark] [eval format "#%04x%04x%04x" $light]]
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::XLFDfont
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::XLFDfont { cmd args } {
#@     switch -- $cmd {
#@         create {
#@             set font "-*-*-*-*-*-*-*-*-*-*-*-*-*-*"
#@         }
#@         configure {
#@             set font [lindex $args 0]
#@             set args [lrange $args 1 end]
#@         }
#@         default {
#@             return -code error "XLFDfont: commande incorrect: $cmd"
#@         }
#@     }
#@     set lfont [split $font "-"]
#@     if { [llength $lfont] != 15 } {
#@         return -code error "XLFDfont: description XLFD incorrect: $font"
#@     }
#@ 
#@     foreach {option value} $args {
#@         switch -- $option {
#@             -foundry { set index 1 }
#@             -family  { set index 2 }
#@             -weight  { set index 3 }
#@             -slant   { set index 4 }
#@             -size    { set index 7 }
#@             default  { return -code error "XLFDfont: option incorrecte: $option" }
#@         }
#@         set lfont [lreplace $lfont $index $index $value]
#@     }
#@     return [join $lfont "-"]
#@ }
#@ 
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::place
#@ # ----------------------------------------------------------------------------
#@ #
#@ # Notes:
#@ #  For Windows systems with more than one monitor the available screen area may
#@ #  have negative positions. Geometry settings with negative numbers are used
#@ #  under X to place wrt the right or bottom of the screen. On windows, Tk
#@ #  continues to do this. However, a geometry such as 100x100+-200-100 can be
#@ #  used to place a window onto a secondary monitor. Passing the + gets Tk
#@ #  to pass the remainder unchanged so the Windows manager then handles -200
#@ #  which is a position on the left hand monitor.
#@ #  I've tested this for left, right, above and below the primary monitor.
#@ #  Currently there is no way to ask Tk the extent of the Windows desktop in 
#@ #  a multi monitor system. Nor what the legal co-ordinate range might be.
#@ #
#@ proc BWidget::place { path w h args } {
#@     variable _top
#@ 
#@     update idletasks
#@ 
#@     # If the window is not mapped, it may have any current size.
#@     # Then use required size, but bound it to the screen width.
#@     # This is mostly inexact, because any toolbars will still be removed
#@     # which may reduce size.
#@     if { $w == 0 && [winfo ismapped $path] } {
#@         set w [winfo width $path]
#@     } else {
#@         if { $w == 0 } {
#@             set w [winfo reqwidth $path]
#@         }
#@         set vsw [winfo vrootwidth  $path]
#@         if { $w > $vsw } { set w $vsw }
#@     }
#@ 
#@     if { $h == 0 && [winfo ismapped $path] } {
#@         set h [winfo height $path]
#@     } else {
#@         if { $h == 0 } {
#@             set h [winfo reqheight $path]
#@         }
#@         set vsh [winfo vrootheight $path]
#@         if { $h > $vsh } { set h $vsh }
#@     }
#@ 
#@     set arglen [llength $args]
#@     if { $arglen > 3 } {
#@         return -code error "BWidget::place: bad number of argument"
#@     }
#@ 
#@     if { $arglen > 0 } {
#@         set where [lindex $args 0]
#@ 	set list  [list "at" "center" "left" "right" "above" "below"]
#@         set idx   [lsearch $list $where]
#@         if { $idx == -1 } {
#@ 	    return -code error [BWidget::badOptionString position $where $list]
#@         }
#@         if { $idx == 0 } {
#@             set err [catch {
#@                 # purposely removed the {} around these expressions - [PT]
#@                 set x [expr int([lindex $args 1])]
#@                 set y [expr int([lindex $args 2])]
#@             }]
#@             if { $err } {
#@                 return -code error "BWidget::place: incorrect position"
#@             }
#@             if {$::tcl_platform(platform) == "windows"} {
#@                 # handle windows multi-screen. -100 != +-100
#@                 if {[string index [lindex $args 1] 0] != "-"} {
#@                     set x "+$x"
#@                 }
#@                 if {[string index [lindex $args 2] 0] != "-"} {
#@                     set y "+$y"
#@                 }
#@             } else {
#@                 if { $x >= 0 } {
#@                     set x "+$x"
#@                 }
#@                 if { $y >= 0 } {
#@                     set y "+$y"
#@                 }
#@             }
#@         } else {
#@             if { $arglen == 2 } {
#@                 set widget [lindex $args 1]
#@                 if { ![winfo exists $widget] } {
#@                     return -code error "BWidget::place: \"$widget\" does not exist"
#@                 }
#@ 	    } else {
#@ 		set widget .
#@ 	    }
#@             set sw [winfo screenwidth  $path]
#@             set sh [winfo screenheight $path]
#@             if { $idx == 1 } {
#@                 if { $arglen == 2 } {
#@                     # center to widget
#@                     set x0 [expr {[winfo rootx $widget] + ([winfo width  $widget] - $w)/2}]
#@                     set y0 [expr {[winfo rooty $widget] + ([winfo height $widget] - $h)/2}]
#@                 } else {
#@                     # center to screen
#@                     set x0 [expr {($sw - $w)/2 - [winfo vrootx $path]}]
#@                     set y0 [expr {($sh - $h)/2 - [winfo vrooty $path]}]
#@                 }
#@                 set x "+$x0"
#@                 set y "+$y0"
#@                 if {$::tcl_platform(platform) != "windows"} {
#@                     if { $x0+$w > $sw } {set x "-0"; set x0 [expr {$sw-$w}]}
#@                     if { $x0 < 0 }      {set x "+0"}
#@                     if { $y0+$h > $sh } {set y "-0"; set y0 [expr {$sh-$h}]}
#@                     if { $y0 < 0 }      {set y "+0"}
#@                 }
#@             } else {
#@                 set x0 [winfo rootx $widget]
#@                 set y0 [winfo rooty $widget]
#@                 set x1 [expr {$x0 + [winfo width  $widget]}]
#@                 set y1 [expr {$y0 + [winfo height $widget]}]
#@                 if { $idx == 2 || $idx == 3 } {
#@                     set y "+$y0"
#@                     if {$::tcl_platform(platform) != "windows"} {
#@                         if { $y0+$h > $sh } {set y "-0"; set y0 [expr {$sh-$h}]}
#@                         if { $y0 < 0 }      {set y "+0"}
#@                     }
#@                     if { $idx == 2 } {
#@                         # try left, then right if out, then 0 if out
#@                         if { $x0 >= $w } {
#@                             set x [expr {$x0-$w}]
#@                         } elseif { $x1+$w <= $sw } {
#@                             set x "+$x1"
#@                         } else {
#@                             set x "+0"
#@                         }
#@                     } else {
#@                         # try right, then left if out, then 0 if out
#@                         if { $x1+$w <= $sw } {
#@                             set x "+$x1"
#@                         } elseif { $x0 >= $w } {
#@                             set x [expr {$x0-$w}]
#@                         } else {
#@                             set x "-0"
#@                         }
#@                     }
#@                 } else {
#@                     set x "+$x0"
#@                     if {$::tcl_platform(platform) != "windows"} {
#@                         if { $x0+$w > $sw } {set x "-0"; set x0 [expr {$sw-$w}]}
#@                         if { $x0 < 0 }      {set x "+0"}
#@                     }
#@                     if { $idx == 4 } {
#@                         # try top, then bottom, then 0
#@                         if { $h <= $y0 } {
#@                             set y [expr {$y0-$h}]
#@                         } elseif { $y1+$h <= $sh } {
#@                             set y "+$y1"
#@                         } else {
#@                             set y "+0"
#@                         }
#@                     } else {
#@                         # try bottom, then top, then 0
#@                         if { $y1+$h <= $sh } {
#@                             set y "+$y1"
#@                         } elseif { $h <= $y0 } {
#@                             set y [expr {$y0-$h}]
#@                         } else {
#@                             set y "-0"
#@                         }
#@                     }
#@                 }
#@             }
#@         }
#@ 
#@         ## If there's not a + or - in front of the number, we need to add one.
#@         if {[string is integer [string index $x 0]]} { set x +$x }
#@         if {[string is integer [string index $y 0]]} { set y +$y }
#@ 
#@         wm geometry $path "${w}x${h}${x}${y}"
#@     } else {
#@         wm geometry $path "${w}x${h}"
#@     }
#@     update idletasks
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::grab
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::grab { option path } {
#@     variable _gstack
#@ 
#@     if { $option == "release" } {
#@         catch {::grab release $path}
#@         while { [llength $_gstack] } {
#@             set grinfo  [lindex $_gstack end]
#@             set _gstack [lreplace $_gstack end end]
#@             foreach {oldg mode} $grinfo {
#@                 if { ![string equal $oldg $path] && [winfo exists $oldg] } {
#@                     if { $mode == "global" } {
#@                         catch {::grab -global $oldg}
#@                     } else {
#@                         catch {::grab $oldg}
#@                     }
#@                     return
#@                 }
#@             }
#@         }
#@     } else {
#@         set oldg [::grab current]
#@         if { $oldg != "" } {
#@             lappend _gstack [list $oldg [::grab status $oldg]]
#@         }
#@         if { $option == "global" } {
#@             ::grab -global $path
#@         } else {
#@             ::grab $path
#@         }
#@     }
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------------
#@ #  Command BWidget::focus
#@ # ----------------------------------------------------------------------------
#@ proc BWidget::focus { option path {refocus 1} } {
#@     variable _fstack
#@ 
#@     if { $option == "release" } {
#@         while { [llength $_fstack] } {
#@             set oldf [lindex $_fstack end]
#@             set _fstack [lreplace $_fstack end end]
#@             if { ![string equal $oldf $path] && [winfo exists $oldf] } {
#@                 if {$refocus} {catch {::focus -force $oldf}}
#@                 return
#@             }
#@         }
#@     } elseif { $option == "set" } {
#@         lappend _fstack [::focus]
#@         ::focus -force $path
#@     }
#@ }
#@ 
#@ # BWidget::refocus --
#@ #
#@ #	Helper function used to redirect focus from a container frame in 
#@ #	a megawidget to a component widget.  Only redirects focus if
#@ #	focus is already on the container.
#@ #
#@ # Arguments:
#@ #	container	container widget to redirect from.
#@ #	component	component widget to redirect to.
#@ #
#@ # Results:
#@ #	None.
#@ 
#@ proc BWidget::refocus {container component} {
#@     if { [string equal $container [::focus]] } {
#@ 	::focus $component
#@     }
#@     return
#@ }
#@ 
#@ ## These mirror tk::(Set|Restore)FocusGrab
#@ 
#@ # BWidget::SetFocusGrab --
#@ #   swap out current focus and grab temporarily (for dialogs)
#@ # Arguments:
#@ #   grab	new window to grab
#@ #   focus	window to give focus to
#@ # Results:
#@ #   Returns nothing
#@ #
#@ proc BWidget::SetFocusGrab {grab {focus {}}} {
#@     variable _focusGrab
#@     set index "$grab,$focus"
#@ 
#@     lappend _focusGrab($index) [::focus]
#@     set oldGrab [::grab current $grab]
#@     lappend _focusGrab($index) $oldGrab
#@     if {[winfo exists $oldGrab]} {
#@ 	lappend _focusGrab($index) [::grab status $oldGrab]
#@     }
#@     # The "grab" command will fail if another application
#@     # already holds the grab.  So catch it.
#@     catch {::grab $grab}
#@     if {[winfo exists $focus]} {
#@ 	::focus $focus
#@     }
#@ }
#@ 
#@ # BWidget::RestoreFocusGrab --
#@ #   restore old focus and grab (for dialogs)
#@ # Arguments:
#@ #   grab	window that had taken grab
#@ #   focus	window that had taken focus
#@ #   destroy	destroy|withdraw - how to handle the old grabbed window
#@ # Results:
#@ #   Returns nothing
#@ #
#@ proc BWidget::RestoreFocusGrab {grab focus {destroy destroy}} {
#@     variable _focusGrab
#@     set index "$grab,$focus"
#@     if {[info exists _focusGrab($index)]} {
#@ 	foreach {oldFocus oldGrab oldStatus} $_focusGrab($index) break
#@ 	unset _focusGrab($index)
#@     } else {
#@ 	set oldGrab ""
#@     }
#@ 
#@     catch {::focus $oldFocus}
#@     ::grab release $grab
#@     if {[string equal $destroy "withdraw"]} {
#@ 	wm withdraw $grab
#@     } else {
#@ 	::destroy $grab
#@     }
#@     if {[winfo exists $oldGrab] && [winfo ismapped $oldGrab]} {
#@ 	if {[string equal $oldStatus "global"]} {
#@ 	    ::grab -global $oldGrab
#@ 	} else {
#@ 	    ::grab $oldGrab
#@ 	}
#@     }
#@ }
#@ 
#@ # BWidget::badOptionString --
#@ #
#@ #	Helper function to return a proper error string when an option
#@ #       doesn't match a list of given options.
#@ #
#@ # Arguments:
#@ #	type	A string that represents the type of option.
#@ #	value	The value that is in-valid.
#@ #       list	A list of valid options.
#@ #
#@ # Results:
#@ #	None.
#@ proc BWidget::badOptionString {type value list} {
#@     set last [lindex $list end]
#@     set list [lreplace $list end end]
#@     return "bad $type \"$value\": must be [join $list ", "], or $last"
#@ }
#@ 
#@ 
#@ proc BWidget::wrongNumArgsString { string } {
#@     return "wrong # args: should be \"$string\""
#@ }
#@ 
#@ 
#@ proc BWidget::read_file { file } {
#@     set fp [open $file]
#@     set x  [read $fp [file size $file]]
#@     close $fp
#@     return $x
#@ }
#@ 
#@ 
#@ proc BWidget::classes { class } {
#@     variable use
#@ 
#@     ${class}::use
#@     set classes [list $class]
#@     if {![info exists use($class)]} { return }
#@     foreach class $use($class) {
#@         if {![string equal $class "-classonly"]} {
#@             eval lappend classes [classes $class]
#@         }
#@     }
#@     return [lsort -unique $classes]
#@ }
#@ 
#@ 
#@ proc BWidget::library { args } {
#@     variable use
#@ 
#@     set libs    [list widget init utils]
#@     set classes [list]
#@     foreach class $args {
#@ 	${class}::use
#@         eval lappend classes [classes $class]
#@     }
#@ 
#@     eval lappend libs [lsort -unique $classes]
#@ 
#@     set library ""
#@     foreach lib $libs {
#@ 	if {![info exists use($lib,file)]} {
#@ 	    set file [file join $::BWIDGET::LIBRARY $lib.tcl]
#@ 	} else {
#@ 	    set file [file join $::BWIDGET::LIBRARY $use($lib,file).tcl]
#@ 	}
#@         append library [read_file $file]
#@     }
#@ 
#@     return $library
#@ }
#@ 
#@ 
#@ proc BWidget::inuse { class } {
#@     variable ::Widget::_inuse
#@ 
#@     if {![info exists _inuse($class)]} { return 0 }
#@     return [expr $_inuse($class) > 0]
#@ }
#@ 
#@ 
#@ proc BWidget::write { filename {mode w} } {
#@     variable use
#@ 
#@     if {![info exists use(classes)]} { return }
#@ 
#@     set classes [list]
#@     foreach class $use(classes) {
#@ 	if {![inuse $class]} { continue }
#@ 	lappend classes $class
#@     }
#@ 
#@     set fp [open $filename $mode]
#@     puts $fp [eval library $classes]
#@     close $fp
#@ 
#@     return
#@ }
#@ 
#@ 
#@ # BWidget::bindMouseWheel --
#@ #
#@ #	Bind mouse wheel actions to a given widget.
#@ #
#@ # Arguments:
#@ #	widget - The widget to bind.
#@ #
#@ # Results:
#@ #	None.
#@ proc BWidget::bindMouseWheel { widget } {
#@     if {[bind all <MouseWheel>] eq ""} {
#@ 	# style::as and Tk 8.5 have global bindings
#@ 	# Only enable these if no global binding for MouseWheel exists
#@ 	bind $widget <MouseWheel> 	    {%W yview scroll [expr {-%D/24}]  units}
#@ 	bind $widget <Shift-MouseWheel> 	    {%W yview scroll [expr {-%D/120}] pages}
#@ 	bind $widget <Control-MouseWheel> 	    {%W yview scroll [expr {-%D/120}] units}
#@     }
#@ 
#@     if {[bind all <Button-4>] eq ""} {
#@ 	# style::as and Tk 8.5 have global bindings
#@ 	# Only enable these if no global binding for them exists
#@ 	bind $widget <Button-4> {event generate %W <MouseWheel> -delta  120}
#@ 	bind $widget <Button-5> {event generate %W <MouseWheel> -delta -120}
#@     }
#@ }
#@ 
#@ 
#@ # -- End source /opt/synopsys/icc-201506/auxx/syn/fp/bw/utils.tcl

#@ if { [info exists ::env(STARTGUI)   ] } {
#@         start_gui
#@ } else {
#@  quit
#@ }
#@ 
#@ # -- End source /home/zhouwt/risc8/icc/run/../scripts/syn.tcl

win_set_filter -visible -class cell -filter {hard_macro_margin hard_margin route_blockage_margin soft_margin}
win_set_filter -visible -class polygon -layer {85 86 87 88 89 90 91 92 93 94 101 111}
win_set_filter -visible -class placement_blockage -filter {wiring} -layer {}
win_set_filter -expand_cell_types {std io hard_macro soft_macro ilm other  }
win_set_select_class -visible {cell port plan_group block_shielding plangroup_padding core_area die_area polygon group shape via terminal fill_cell placement_blockage }
win_set_filter -class cell -filter {cell_array cell_cover hard_macro_margin hard_margin route_blockage_margin soft_margin}
win_set_filter -class placement_blockage -filter {wiring} -layer {}
win_set_select_class {cell port plan_group group shape via placement_blockage }
